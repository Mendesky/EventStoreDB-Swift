// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: persistent.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

package struct EventStore_Client_PersistentSubscriptions_ReadReq: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var content: EventStore_Client_PersistentSubscriptions_ReadReq.OneOf_Content? = nil

    package var options: EventStore_Client_PersistentSubscriptions_ReadReq.Options {
        get {
            if case let .options(v)? = content { return v }
            return EventStore_Client_PersistentSubscriptions_ReadReq.Options()
        }
        set { content = .options(newValue) }
    }

    package var ack: EventStore_Client_PersistentSubscriptions_ReadReq.Ack {
        get {
            if case let .ack(v)? = content { return v }
            return EventStore_Client_PersistentSubscriptions_ReadReq.Ack()
        }
        set { content = .ack(newValue) }
    }

    package var nack: EventStore_Client_PersistentSubscriptions_ReadReq.Nack {
        get {
            if case let .nack(v)? = content { return v }
            return EventStore_Client_PersistentSubscriptions_ReadReq.Nack()
        }
        set { content = .nack(newValue) }
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_Content: Equatable, Sendable {
        case options(EventStore_Client_PersistentSubscriptions_ReadReq.Options)
        case ack(EventStore_Client_PersistentSubscriptions_ReadReq.Ack)
        case nack(EventStore_Client_PersistentSubscriptions_ReadReq.Nack)
    }

    package struct Options: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var streamOption: EventStore_Client_PersistentSubscriptions_ReadReq.Options.OneOf_StreamOption? = nil

        package var streamIdentifier: EventStore_Client_StreamIdentifier {
            get {
                if case let .streamIdentifier(v)? = streamOption { return v }
                return EventStore_Client_StreamIdentifier()
            }
            set { streamOption = .streamIdentifier(newValue) }
        }

        package var all: EventStore_Client_Empty {
            get {
                if case let .all(v)? = streamOption { return v }
                return EventStore_Client_Empty()
            }
            set { streamOption = .all(newValue) }
        }

        package var groupName: String = .init()

        package var bufferSize: Int32 = 0

        package var uuidOption: EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption {
            get { _uuidOption ?? EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption() }
            set { _uuidOption = newValue }
        }

        /// Returns true if `uuidOption` has been explicitly set.
        package var hasUuidOption: Bool { _uuidOption != nil }
        /// Clears the value of `uuidOption`. Subsequent reads from it will return its default value.
        package mutating func clearUuidOption() { _uuidOption = nil }

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_StreamOption: Equatable, Sendable {
            case streamIdentifier(EventStore_Client_StreamIdentifier)
            case all(EventStore_Client_Empty)
        }

        package struct UUIDOption: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            package var content: EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption.OneOf_Content? = nil

            package var structured: EventStore_Client_Empty {
                get {
                    if case let .structured(v)? = content { return v }
                    return EventStore_Client_Empty()
                }
                set { content = .structured(newValue) }
            }

            package var string: EventStore_Client_Empty {
                get {
                    if case let .string(v)? = content { return v }
                    return EventStore_Client_Empty()
                }
                set { content = .string(newValue) }
            }

            package var unknownFields = SwiftProtobuf.UnknownStorage()

            package enum OneOf_Content: Equatable, Sendable {
                case structured(EventStore_Client_Empty)
                case string(EventStore_Client_Empty)
            }

            package init() {}
        }

        package init() {}

        fileprivate var _uuidOption: EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption? = nil
    }

    package struct Ack: @unchecked Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var id: Data = .init()

        package var ids: [EventStore_Client_UUID] = []

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package init() {}
    }

    package struct Nack: @unchecked Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var id: Data = .init()

        package var ids: [EventStore_Client_UUID] = []

        package var action: EventStore_Client_PersistentSubscriptions_ReadReq.Nack.Action = .unknown

        package var reason: String = .init()

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum Action: SwiftProtobuf.Enum, Swift.CaseIterable {
            package typealias RawValue = Int
            case unknown // = 0
            case park // = 1
            case retry // = 2
            case skip // = 3
            case stop // = 4
            case UNRECOGNIZED(Int)

            package init() {
                self = .unknown
            }

            package init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .unknown
                case 1: self = .park
                case 2: self = .retry
                case 3: self = .skip
                case 4: self = .stop
                default: self = .UNRECOGNIZED(rawValue)
                }
            }

            package var rawValue: Int {
                switch self {
                case .unknown: 0
                case .park: 1
                case .retry: 2
                case .skip: 3
                case .stop: 4
                case let .UNRECOGNIZED(i): i
                }
            }

            // The compiler won't synthesize support with the UNRECOGNIZED case.
            package static let allCases: [EventStore_Client_PersistentSubscriptions_ReadReq.Nack.Action] = [
                .unknown,
                .park,
                .retry,
                .skip,
                .stop,
            ]
        }

        package init() {}
    }

    package init() {}
}

package struct EventStore_Client_PersistentSubscriptions_ReadResp: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var content: EventStore_Client_PersistentSubscriptions_ReadResp.OneOf_Content? = nil

    package var event: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent {
        get {
            if case let .event(v)? = content { return v }
            return EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent()
        }
        set { content = .event(newValue) }
    }

    package var subscriptionConfirmation: EventStore_Client_PersistentSubscriptions_ReadResp.SubscriptionConfirmation {
        get {
            if case let .subscriptionConfirmation(v)? = content { return v }
            return EventStore_Client_PersistentSubscriptions_ReadResp.SubscriptionConfirmation()
        }
        set { content = .subscriptionConfirmation(newValue) }
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_Content: Equatable, Sendable {
        case event(EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent)
        case subscriptionConfirmation(EventStore_Client_PersistentSubscriptions_ReadResp.SubscriptionConfirmation)
    }

    package struct ReadEvent: @unchecked Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var event: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent {
            get { _storage._event ?? EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent() }
            set { _uniqueStorage()._event = newValue }
        }

        /// Returns true if `event` has been explicitly set.
        package var hasEvent: Bool { _storage._event != nil }
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        package mutating func clearEvent() { _uniqueStorage()._event = nil }

        package var link: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent {
            get { _storage._link ?? EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent() }
            set { _uniqueStorage()._link = newValue }
        }

        /// Returns true if `link` has been explicitly set.
        package var hasLink: Bool { _storage._link != nil }
        /// Clears the value of `link`. Subsequent reads from it will return its default value.
        package mutating func clearLink() { _uniqueStorage()._link = nil }

        package var position: OneOf_Position? {
            get { _storage._position }
            set { _uniqueStorage()._position = newValue }
        }

        package var commitPosition: UInt64 {
            get {
                if case let .commitPosition(v)? = _storage._position { return v }
                return 0
            }
            set { _uniqueStorage()._position = .commitPosition(newValue) }
        }

        package var noPosition: EventStore_Client_Empty {
            get {
                if case let .noPosition(v)? = _storage._position { return v }
                return EventStore_Client_Empty()
            }
            set { _uniqueStorage()._position = .noPosition(newValue) }
        }

        package var count: OneOf_Count? {
            get { _storage._count }
            set { _uniqueStorage()._count = newValue }
        }

        package var retryCount: Int32 {
            get {
                if case let .retryCount(v)? = _storage._count { return v }
                return 0
            }
            set { _uniqueStorage()._count = .retryCount(newValue) }
        }

        package var noRetryCount: EventStore_Client_Empty {
            get {
                if case let .noRetryCount(v)? = _storage._count { return v }
                return EventStore_Client_Empty()
            }
            set { _uniqueStorage()._count = .noRetryCount(newValue) }
        }

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_Position: Equatable, Sendable {
            case commitPosition(UInt64)
            case noPosition(EventStore_Client_Empty)
        }

        package enum OneOf_Count: Equatable, Sendable {
            case retryCount(Int32)
            case noRetryCount(EventStore_Client_Empty)
        }

        package struct RecordedEvent: @unchecked Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            package var id: EventStore_Client_UUID {
                get { _id ?? EventStore_Client_UUID() }
                set { _id = newValue }
            }

            /// Returns true if `id` has been explicitly set.
            package var hasID: Bool { _id != nil }
            /// Clears the value of `id`. Subsequent reads from it will return its default value.
            package mutating func clearID() { _id = nil }

            package var streamIdentifier: EventStore_Client_StreamIdentifier {
                get { _streamIdentifier ?? EventStore_Client_StreamIdentifier() }
                set { _streamIdentifier = newValue }
            }

            /// Returns true if `streamIdentifier` has been explicitly set.
            package var hasStreamIdentifier: Bool { _streamIdentifier != nil }
            /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
            package mutating func clearStreamIdentifier() { _streamIdentifier = nil }

            package var streamRevision: UInt64 = 0

            package var preparePosition: UInt64 = 0

            package var commitPosition: UInt64 = 0

            package var metadata: [String: String] = [:]

            package var customMetadata: Data = .init()

            package var data: Data = .init()

            package var unknownFields = SwiftProtobuf.UnknownStorage()

            package init() {}

            fileprivate var _id: EventStore_Client_UUID? = nil
            fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
        }

        package init() {}

        fileprivate var _storage = _StorageClass.defaultInstance
    }

    package struct SubscriptionConfirmation: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var subscriptionID: String = .init()

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package init() {}
    }

    package init() {}
}

package struct EventStore_Client_PersistentSubscriptions_CreateReq: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var options: EventStore_Client_PersistentSubscriptions_CreateReq.Options {
        get { _options ?? EventStore_Client_PersistentSubscriptions_CreateReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    package var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    package mutating func clearOptions() { _options = nil }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum ConsumerStrategy: SwiftProtobuf.Enum, Swift.CaseIterable {
        package typealias RawValue = Int
        case dispatchToSingle // = 0
        case roundRobin // = 1
        case pinned // = 2
        case UNRECOGNIZED(Int)

        package init() {
            self = .dispatchToSingle
        }

        package init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .dispatchToSingle
            case 1: self = .roundRobin
            case 2: self = .pinned
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        package var rawValue: Int {
            switch self {
            case .dispatchToSingle: 0
            case .roundRobin: 1
            case .pinned: 2
            case let .UNRECOGNIZED(i): i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        package static let allCases: [EventStore_Client_PersistentSubscriptions_CreateReq.ConsumerStrategy] = [
            .dispatchToSingle,
            .roundRobin,
            .pinned,
        ]
    }

    package struct Options: @unchecked Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var streamOption: OneOf_StreamOption? {
            get { _storage._streamOption }
            set { _uniqueStorage()._streamOption = newValue }
        }

        package var stream: EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions {
            get {
                if case let .stream(v)? = _storage._streamOption { return v }
                return EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions()
            }
            set { _uniqueStorage()._streamOption = .stream(newValue) }
        }

        package var all: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions {
            get {
                if case let .all(v)? = _storage._streamOption { return v }
                return EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions()
            }
            set { _uniqueStorage()._streamOption = .all(newValue) }
        }

        /// NOTE: This field was marked as deprecated in the .proto file.
        package var streamIdentifier: EventStore_Client_StreamIdentifier {
            get { _storage._streamIdentifier ?? EventStore_Client_StreamIdentifier() }
            set { _uniqueStorage()._streamIdentifier = newValue }
        }

        /// Returns true if `streamIdentifier` has been explicitly set.
        package var hasStreamIdentifier: Bool { _storage._streamIdentifier != nil }
        /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
        package mutating func clearStreamIdentifier() { _uniqueStorage()._streamIdentifier = nil }

        package var groupName: String {
            get { _storage._groupName }
            set { _uniqueStorage()._groupName = newValue }
        }

        package var settings: EventStore_Client_PersistentSubscriptions_CreateReq.Settings {
            get { _storage._settings ?? EventStore_Client_PersistentSubscriptions_CreateReq.Settings() }
            set { _uniqueStorage()._settings = newValue }
        }

        /// Returns true if `settings` has been explicitly set.
        package var hasSettings: Bool { _storage._settings != nil }
        /// Clears the value of `settings`. Subsequent reads from it will return its default value.
        package mutating func clearSettings() { _uniqueStorage()._settings = nil }

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_StreamOption: Equatable, Sendable {
            case stream(EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions)
            case all(EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions)
        }

        package init() {}

        fileprivate var _storage = _StorageClass.defaultInstance
    }

    package struct StreamOptions: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var streamIdentifier: EventStore_Client_StreamIdentifier {
            get { _streamIdentifier ?? EventStore_Client_StreamIdentifier() }
            set { _streamIdentifier = newValue }
        }

        /// Returns true if `streamIdentifier` has been explicitly set.
        package var hasStreamIdentifier: Bool { _streamIdentifier != nil }
        /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
        package mutating func clearStreamIdentifier() { _streamIdentifier = nil }

        package var revisionOption: EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions.OneOf_RevisionOption? = nil

        package var revision: UInt64 {
            get {
                if case let .revision(v)? = revisionOption { return v }
                return 0
            }
            set { revisionOption = .revision(newValue) }
        }

        package var start: EventStore_Client_Empty {
            get {
                if case let .start(v)? = revisionOption { return v }
                return EventStore_Client_Empty()
            }
            set { revisionOption = .start(newValue) }
        }

        package var end: EventStore_Client_Empty {
            get {
                if case let .end(v)? = revisionOption { return v }
                return EventStore_Client_Empty()
            }
            set { revisionOption = .end(newValue) }
        }

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_RevisionOption: Equatable, Sendable {
            case revision(UInt64)
            case start(EventStore_Client_Empty)
            case end(EventStore_Client_Empty)
        }

        package init() {}

        fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
    }

    package struct AllOptions: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var allOption: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.OneOf_AllOption? = nil

        package var position: EventStore_Client_PersistentSubscriptions_CreateReq.Position {
            get {
                if case let .position(v)? = allOption { return v }
                return EventStore_Client_PersistentSubscriptions_CreateReq.Position()
            }
            set { allOption = .position(newValue) }
        }

        package var start: EventStore_Client_Empty {
            get {
                if case let .start(v)? = allOption { return v }
                return EventStore_Client_Empty()
            }
            set { allOption = .start(newValue) }
        }

        package var end: EventStore_Client_Empty {
            get {
                if case let .end(v)? = allOption { return v }
                return EventStore_Client_Empty()
            }
            set { allOption = .end(newValue) }
        }

        package var filterOption: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.OneOf_FilterOption? = nil

        package var filter: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions {
            get {
                if case let .filter(v)? = filterOption { return v }
                return EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions()
            }
            set { filterOption = .filter(newValue) }
        }

        package var noFilter: EventStore_Client_Empty {
            get {
                if case let .noFilter(v)? = filterOption { return v }
                return EventStore_Client_Empty()
            }
            set { filterOption = .noFilter(newValue) }
        }

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_AllOption: Equatable, Sendable {
            case position(EventStore_Client_PersistentSubscriptions_CreateReq.Position)
            case start(EventStore_Client_Empty)
            case end(EventStore_Client_Empty)
        }

        package enum OneOf_FilterOption: Equatable, Sendable {
            case filter(EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions)
            case noFilter(EventStore_Client_Empty)
        }

        package struct FilterOptions: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            package var filter: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.OneOf_Filter? = nil

            package var streamIdentifier: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression {
                get {
                    if case let .streamIdentifier(v)? = filter { return v }
                    return EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression()
                }
                set { filter = .streamIdentifier(newValue) }
            }

            package var eventType: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression {
                get {
                    if case let .eventType(v)? = filter { return v }
                    return EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression()
                }
                set { filter = .eventType(newValue) }
            }

            package var window: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.OneOf_Window? = nil

            package var max: UInt32 {
                get {
                    if case let .max(v)? = window { return v }
                    return 0
                }
                set { window = .max(newValue) }
            }

            package var count: EventStore_Client_Empty {
                get {
                    if case let .count(v)? = window { return v }
                    return EventStore_Client_Empty()
                }
                set { window = .count(newValue) }
            }

            package var checkpointIntervalMultiplier: UInt32 = 0

            package var unknownFields = SwiftProtobuf.UnknownStorage()

            package enum OneOf_Filter: Equatable, Sendable {
                case streamIdentifier(EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression)
                case eventType(EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression)
            }

            package enum OneOf_Window: Equatable, Sendable {
                case max(UInt32)
                case count(EventStore_Client_Empty)
            }

            package struct Expression: Sendable {
                // SwiftProtobuf.Message conformance is added in an extension below. See the
                // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
                // methods supported on all messages.

                package var regex: String = .init()

                package var prefix: [String] = []

                package var unknownFields = SwiftProtobuf.UnknownStorage()

                package init() {}
            }

            package init() {}
        }

        package init() {}
    }

    package struct Position: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var commitPosition: UInt64 = 0

        package var preparePosition: UInt64 = 0

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package init() {}
    }

    package struct Settings: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var resolveLinks: Bool = false

        /// NOTE: This field was marked as deprecated in the .proto file.
        package var revision: UInt64 = 0

        package var extraStatistics: Bool = false

        package var maxRetryCount: Int32 = 0

        package var minCheckpointCount: Int32 = 0

        package var maxCheckpointCount: Int32 = 0

        package var maxSubscriberCount: Int32 = 0

        package var liveBufferSize: Int32 = 0

        package var readBatchSize: Int32 = 0

        package var historyBufferSize: Int32 = 0

        /// NOTE: This field was marked as deprecated in the .proto file.
        package var namedConsumerStrategy: EventStore_Client_PersistentSubscriptions_CreateReq.ConsumerStrategy = .dispatchToSingle

        package var messageTimeout: EventStore_Client_PersistentSubscriptions_CreateReq.Settings.OneOf_MessageTimeout? = nil

        package var messageTimeoutTicks: Int64 {
            get {
                if case let .messageTimeoutTicks(v)? = messageTimeout { return v }
                return 0
            }
            set { messageTimeout = .messageTimeoutTicks(newValue) }
        }

        package var messageTimeoutMs: Int32 {
            get {
                if case let .messageTimeoutMs(v)? = messageTimeout { return v }
                return 0
            }
            set { messageTimeout = .messageTimeoutMs(newValue) }
        }

        package var checkpointAfter: EventStore_Client_PersistentSubscriptions_CreateReq.Settings.OneOf_CheckpointAfter? = nil

        package var checkpointAfterTicks: Int64 {
            get {
                if case let .checkpointAfterTicks(v)? = checkpointAfter { return v }
                return 0
            }
            set { checkpointAfter = .checkpointAfterTicks(newValue) }
        }

        package var checkpointAfterMs: Int32 {
            get {
                if case let .checkpointAfterMs(v)? = checkpointAfter { return v }
                return 0
            }
            set { checkpointAfter = .checkpointAfterMs(newValue) }
        }

        package var consumerStrategy: String = .init()

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_MessageTimeout: Equatable, Sendable {
            case messageTimeoutTicks(Int64)
            case messageTimeoutMs(Int32)
        }

        package enum OneOf_CheckpointAfter: Equatable, Sendable {
            case checkpointAfterTicks(Int64)
            case checkpointAfterMs(Int32)
        }

        package init() {}
    }

    package init() {}

    fileprivate var _options: EventStore_Client_PersistentSubscriptions_CreateReq.Options? = nil
}

package struct EventStore_Client_PersistentSubscriptions_CreateResp: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
}

package struct EventStore_Client_PersistentSubscriptions_UpdateReq: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var options: EventStore_Client_PersistentSubscriptions_UpdateReq.Options {
        get { _options ?? EventStore_Client_PersistentSubscriptions_UpdateReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    package var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    package mutating func clearOptions() { _options = nil }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum ConsumerStrategy: SwiftProtobuf.Enum, Swift.CaseIterable {
        package typealias RawValue = Int
        case dispatchToSingle // = 0
        case roundRobin // = 1
        case pinned // = 2
        case UNRECOGNIZED(Int)

        package init() {
            self = .dispatchToSingle
        }

        package init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .dispatchToSingle
            case 1: self = .roundRobin
            case 2: self = .pinned
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        package var rawValue: Int {
            switch self {
            case .dispatchToSingle: 0
            case .roundRobin: 1
            case .pinned: 2
            case let .UNRECOGNIZED(i): i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        package static let allCases: [EventStore_Client_PersistentSubscriptions_UpdateReq.ConsumerStrategy] = [
            .dispatchToSingle,
            .roundRobin,
            .pinned,
        ]
    }

    package struct Options: @unchecked Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var streamOption: OneOf_StreamOption? {
            get { _storage._streamOption }
            set { _uniqueStorage()._streamOption = newValue }
        }

        package var stream: EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions {
            get {
                if case let .stream(v)? = _storage._streamOption { return v }
                return EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions()
            }
            set { _uniqueStorage()._streamOption = .stream(newValue) }
        }

        package var all: EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions {
            get {
                if case let .all(v)? = _storage._streamOption { return v }
                return EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions()
            }
            set { _uniqueStorage()._streamOption = .all(newValue) }
        }

        /// NOTE: This field was marked as deprecated in the .proto file.
        package var streamIdentifier: EventStore_Client_StreamIdentifier {
            get { _storage._streamIdentifier ?? EventStore_Client_StreamIdentifier() }
            set { _uniqueStorage()._streamIdentifier = newValue }
        }

        /// Returns true if `streamIdentifier` has been explicitly set.
        package var hasStreamIdentifier: Bool { _storage._streamIdentifier != nil }
        /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
        package mutating func clearStreamIdentifier() { _uniqueStorage()._streamIdentifier = nil }

        package var groupName: String {
            get { _storage._groupName }
            set { _uniqueStorage()._groupName = newValue }
        }

        package var settings: EventStore_Client_PersistentSubscriptions_UpdateReq.Settings {
            get { _storage._settings ?? EventStore_Client_PersistentSubscriptions_UpdateReq.Settings() }
            set { _uniqueStorage()._settings = newValue }
        }

        /// Returns true if `settings` has been explicitly set.
        package var hasSettings: Bool { _storage._settings != nil }
        /// Clears the value of `settings`. Subsequent reads from it will return its default value.
        package mutating func clearSettings() { _uniqueStorage()._settings = nil }

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_StreamOption: Equatable, Sendable {
            case stream(EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions)
            case all(EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions)
        }

        package init() {}

        fileprivate var _storage = _StorageClass.defaultInstance
    }

    package struct StreamOptions: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var streamIdentifier: EventStore_Client_StreamIdentifier {
            get { _streamIdentifier ?? EventStore_Client_StreamIdentifier() }
            set { _streamIdentifier = newValue }
        }

        /// Returns true if `streamIdentifier` has been explicitly set.
        package var hasStreamIdentifier: Bool { _streamIdentifier != nil }
        /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
        package mutating func clearStreamIdentifier() { _streamIdentifier = nil }

        package var revisionOption: EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions.OneOf_RevisionOption? = nil

        package var revision: UInt64 {
            get {
                if case let .revision(v)? = revisionOption { return v }
                return 0
            }
            set { revisionOption = .revision(newValue) }
        }

        package var start: EventStore_Client_Empty {
            get {
                if case let .start(v)? = revisionOption { return v }
                return EventStore_Client_Empty()
            }
            set { revisionOption = .start(newValue) }
        }

        package var end: EventStore_Client_Empty {
            get {
                if case let .end(v)? = revisionOption { return v }
                return EventStore_Client_Empty()
            }
            set { revisionOption = .end(newValue) }
        }

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_RevisionOption: Equatable, Sendable {
            case revision(UInt64)
            case start(EventStore_Client_Empty)
            case end(EventStore_Client_Empty)
        }

        package init() {}

        fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
    }

    package struct AllOptions: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var allOption: EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions.OneOf_AllOption? = nil

        package var position: EventStore_Client_PersistentSubscriptions_UpdateReq.Position {
            get {
                if case let .position(v)? = allOption { return v }
                return EventStore_Client_PersistentSubscriptions_UpdateReq.Position()
            }
            set { allOption = .position(newValue) }
        }

        package var start: EventStore_Client_Empty {
            get {
                if case let .start(v)? = allOption { return v }
                return EventStore_Client_Empty()
            }
            set { allOption = .start(newValue) }
        }

        package var end: EventStore_Client_Empty {
            get {
                if case let .end(v)? = allOption { return v }
                return EventStore_Client_Empty()
            }
            set { allOption = .end(newValue) }
        }

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_AllOption: Equatable, Sendable {
            case position(EventStore_Client_PersistentSubscriptions_UpdateReq.Position)
            case start(EventStore_Client_Empty)
            case end(EventStore_Client_Empty)
        }

        package init() {}
    }

    package struct Position: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var commitPosition: UInt64 = 0

        package var preparePosition: UInt64 = 0

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package init() {}
    }

    package struct Settings: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var resolveLinks: Bool = false

        /// NOTE: This field was marked as deprecated in the .proto file.
        package var revision: UInt64 = 0

        package var extraStatistics: Bool = false

        package var maxRetryCount: Int32 = 0

        package var minCheckpointCount: Int32 = 0

        package var maxCheckpointCount: Int32 = 0

        package var maxSubscriberCount: Int32 = 0

        package var liveBufferSize: Int32 = 0

        package var readBatchSize: Int32 = 0

        package var historyBufferSize: Int32 = 0

        package var namedConsumerStrategy: EventStore_Client_PersistentSubscriptions_UpdateReq.ConsumerStrategy = .dispatchToSingle

        package var messageTimeout: EventStore_Client_PersistentSubscriptions_UpdateReq.Settings.OneOf_MessageTimeout? = nil

        package var messageTimeoutTicks: Int64 {
            get {
                if case let .messageTimeoutTicks(v)? = messageTimeout { return v }
                return 0
            }
            set { messageTimeout = .messageTimeoutTicks(newValue) }
        }

        package var messageTimeoutMs: Int32 {
            get {
                if case let .messageTimeoutMs(v)? = messageTimeout { return v }
                return 0
            }
            set { messageTimeout = .messageTimeoutMs(newValue) }
        }

        package var checkpointAfter: EventStore_Client_PersistentSubscriptions_UpdateReq.Settings.OneOf_CheckpointAfter? = nil

        package var checkpointAfterTicks: Int64 {
            get {
                if case let .checkpointAfterTicks(v)? = checkpointAfter { return v }
                return 0
            }
            set { checkpointAfter = .checkpointAfterTicks(newValue) }
        }

        package var checkpointAfterMs: Int32 {
            get {
                if case let .checkpointAfterMs(v)? = checkpointAfter { return v }
                return 0
            }
            set { checkpointAfter = .checkpointAfterMs(newValue) }
        }

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_MessageTimeout: Equatable, Sendable {
            case messageTimeoutTicks(Int64)
            case messageTimeoutMs(Int32)
        }

        package enum OneOf_CheckpointAfter: Equatable, Sendable {
            case checkpointAfterTicks(Int64)
            case checkpointAfterMs(Int32)
        }

        package init() {}
    }

    package init() {}

    fileprivate var _options: EventStore_Client_PersistentSubscriptions_UpdateReq.Options? = nil
}

package struct EventStore_Client_PersistentSubscriptions_UpdateResp: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
}

package struct EventStore_Client_PersistentSubscriptions_DeleteReq: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var options: EventStore_Client_PersistentSubscriptions_DeleteReq.Options {
        get { _options ?? EventStore_Client_PersistentSubscriptions_DeleteReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    package var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    package mutating func clearOptions() { _options = nil }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package struct Options: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var streamOption: EventStore_Client_PersistentSubscriptions_DeleteReq.Options.OneOf_StreamOption? = nil

        package var streamIdentifier: EventStore_Client_StreamIdentifier {
            get {
                if case let .streamIdentifier(v)? = streamOption { return v }
                return EventStore_Client_StreamIdentifier()
            }
            set { streamOption = .streamIdentifier(newValue) }
        }

        package var all: EventStore_Client_Empty {
            get {
                if case let .all(v)? = streamOption { return v }
                return EventStore_Client_Empty()
            }
            set { streamOption = .all(newValue) }
        }

        package var groupName: String = .init()

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_StreamOption: Equatable, Sendable {
            case streamIdentifier(EventStore_Client_StreamIdentifier)
            case all(EventStore_Client_Empty)
        }

        package init() {}
    }

    package init() {}

    fileprivate var _options: EventStore_Client_PersistentSubscriptions_DeleteReq.Options? = nil
}

package struct EventStore_Client_PersistentSubscriptions_DeleteResp: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
}

package struct EventStore_Client_PersistentSubscriptions_GetInfoReq: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var options: EventStore_Client_PersistentSubscriptions_GetInfoReq.Options {
        get { _options ?? EventStore_Client_PersistentSubscriptions_GetInfoReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    package var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    package mutating func clearOptions() { _options = nil }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package struct Options: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var streamOption: EventStore_Client_PersistentSubscriptions_GetInfoReq.Options.OneOf_StreamOption? = nil

        package var streamIdentifier: EventStore_Client_StreamIdentifier {
            get {
                if case let .streamIdentifier(v)? = streamOption { return v }
                return EventStore_Client_StreamIdentifier()
            }
            set { streamOption = .streamIdentifier(newValue) }
        }

        package var all: EventStore_Client_Empty {
            get {
                if case let .all(v)? = streamOption { return v }
                return EventStore_Client_Empty()
            }
            set { streamOption = .all(newValue) }
        }

        package var groupName: String = .init()

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_StreamOption: Equatable, Sendable {
            case streamIdentifier(EventStore_Client_StreamIdentifier)
            case all(EventStore_Client_Empty)
        }

        package init() {}
    }

    package init() {}

    fileprivate var _options: EventStore_Client_PersistentSubscriptions_GetInfoReq.Options? = nil
}

package struct EventStore_Client_PersistentSubscriptions_GetInfoResp: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var subscriptionInfo: EventStore_Client_PersistentSubscriptions_SubscriptionInfo {
        get { _subscriptionInfo ?? EventStore_Client_PersistentSubscriptions_SubscriptionInfo() }
        set { _subscriptionInfo = newValue }
    }

    /// Returns true if `subscriptionInfo` has been explicitly set.
    package var hasSubscriptionInfo: Bool { _subscriptionInfo != nil }
    /// Clears the value of `subscriptionInfo`. Subsequent reads from it will return its default value.
    package mutating func clearSubscriptionInfo() { _subscriptionInfo = nil }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _subscriptionInfo: EventStore_Client_PersistentSubscriptions_SubscriptionInfo? = nil
}

package struct EventStore_Client_PersistentSubscriptions_SubscriptionInfo: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var eventSource: String {
        get { _storage._eventSource }
        set { _uniqueStorage()._eventSource = newValue }
    }

    package var groupName: String {
        get { _storage._groupName }
        set { _uniqueStorage()._groupName = newValue }
    }

    package var status: String {
        get { _storage._status }
        set { _uniqueStorage()._status = newValue }
    }

    package var connections: [EventStore_Client_PersistentSubscriptions_SubscriptionInfo.ConnectionInfo] {
        get { _storage._connections }
        set { _uniqueStorage()._connections = newValue }
    }

    package var averagePerSecond: Int32 {
        get { _storage._averagePerSecond }
        set { _uniqueStorage()._averagePerSecond = newValue }
    }

    package var totalItems: Int64 {
        get { _storage._totalItems }
        set { _uniqueStorage()._totalItems = newValue }
    }

    package var countSinceLastMeasurement: Int64 {
        get { _storage._countSinceLastMeasurement }
        set { _uniqueStorage()._countSinceLastMeasurement = newValue }
    }

    package var lastCheckpointedEventPosition: String {
        get { _storage._lastCheckpointedEventPosition }
        set { _uniqueStorage()._lastCheckpointedEventPosition = newValue }
    }

    package var lastKnownEventPosition: String {
        get { _storage._lastKnownEventPosition }
        set { _uniqueStorage()._lastKnownEventPosition = newValue }
    }

    package var resolveLinkTos: Bool {
        get { _storage._resolveLinkTos }
        set { _uniqueStorage()._resolveLinkTos = newValue }
    }

    package var startFrom: String {
        get { _storage._startFrom }
        set { _uniqueStorage()._startFrom = newValue }
    }

    package var messageTimeoutMilliseconds: Int32 {
        get { _storage._messageTimeoutMilliseconds }
        set { _uniqueStorage()._messageTimeoutMilliseconds = newValue }
    }

    package var extraStatistics: Bool {
        get { _storage._extraStatistics }
        set { _uniqueStorage()._extraStatistics = newValue }
    }

    package var maxRetryCount: Int32 {
        get { _storage._maxRetryCount }
        set { _uniqueStorage()._maxRetryCount = newValue }
    }

    package var liveBufferSize: Int32 {
        get { _storage._liveBufferSize }
        set { _uniqueStorage()._liveBufferSize = newValue }
    }

    package var bufferSize: Int32 {
        get { _storage._bufferSize }
        set { _uniqueStorage()._bufferSize = newValue }
    }

    package var readBatchSize: Int32 {
        get { _storage._readBatchSize }
        set { _uniqueStorage()._readBatchSize = newValue }
    }

    package var checkPointAfterMilliseconds: Int32 {
        get { _storage._checkPointAfterMilliseconds }
        set { _uniqueStorage()._checkPointAfterMilliseconds = newValue }
    }

    package var minCheckPointCount: Int32 {
        get { _storage._minCheckPointCount }
        set { _uniqueStorage()._minCheckPointCount = newValue }
    }

    package var maxCheckPointCount: Int32 {
        get { _storage._maxCheckPointCount }
        set { _uniqueStorage()._maxCheckPointCount = newValue }
    }

    package var readBufferCount: Int32 {
        get { _storage._readBufferCount }
        set { _uniqueStorage()._readBufferCount = newValue }
    }

    package var liveBufferCount: Int64 {
        get { _storage._liveBufferCount }
        set { _uniqueStorage()._liveBufferCount = newValue }
    }

    package var retryBufferCount: Int32 {
        get { _storage._retryBufferCount }
        set { _uniqueStorage()._retryBufferCount = newValue }
    }

    package var totalInFlightMessages: Int32 {
        get { _storage._totalInFlightMessages }
        set { _uniqueStorage()._totalInFlightMessages = newValue }
    }

    package var outstandingMessagesCount: Int32 {
        get { _storage._outstandingMessagesCount }
        set { _uniqueStorage()._outstandingMessagesCount = newValue }
    }

    package var namedConsumerStrategy: String {
        get { _storage._namedConsumerStrategy }
        set { _uniqueStorage()._namedConsumerStrategy = newValue }
    }

    package var maxSubscriberCount: Int32 {
        get { _storage._maxSubscriberCount }
        set { _uniqueStorage()._maxSubscriberCount = newValue }
    }

    package var parkedMessageCount: Int64 {
        get { _storage._parkedMessageCount }
        set { _uniqueStorage()._parkedMessageCount = newValue }
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package struct ConnectionInfo: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var from: String = .init()

        package var username: String = .init()

        package var averageItemsPerSecond: Int32 = 0

        package var totalItems: Int64 = 0

        package var countSinceLastMeasurement: Int64 = 0

        package var observedMeasurements: [EventStore_Client_PersistentSubscriptions_SubscriptionInfo.Measurement] = []

        package var availableSlots: Int32 = 0

        package var inFlightMessages: Int32 = 0

        package var connectionName: String = .init()

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package init() {}
    }

    package struct Measurement: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var key: String = .init()

        package var value: Int64 = 0

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package init() {}
    }

    package init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

package struct EventStore_Client_PersistentSubscriptions_ReplayParkedReq: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var options: EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options {
        get { _options ?? EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    package var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    package mutating func clearOptions() { _options = nil }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package struct Options: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var groupName: String = .init()

        package var streamOption: EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options.OneOf_StreamOption? = nil

        package var streamIdentifier: EventStore_Client_StreamIdentifier {
            get {
                if case let .streamIdentifier(v)? = streamOption { return v }
                return EventStore_Client_StreamIdentifier()
            }
            set { streamOption = .streamIdentifier(newValue) }
        }

        package var all: EventStore_Client_Empty {
            get {
                if case let .all(v)? = streamOption { return v }
                return EventStore_Client_Empty()
            }
            set { streamOption = .all(newValue) }
        }

        package var stopAtOption: EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options.OneOf_StopAtOption? = nil

        package var stopAt: Int64 {
            get {
                if case let .stopAt(v)? = stopAtOption { return v }
                return 0
            }
            set { stopAtOption = .stopAt(newValue) }
        }

        package var noLimit: EventStore_Client_Empty {
            get {
                if case let .noLimit(v)? = stopAtOption { return v }
                return EventStore_Client_Empty()
            }
            set { stopAtOption = .noLimit(newValue) }
        }

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_StreamOption: Equatable, Sendable {
            case streamIdentifier(EventStore_Client_StreamIdentifier)
            case all(EventStore_Client_Empty)
        }

        package enum OneOf_StopAtOption: Equatable, Sendable {
            case stopAt(Int64)
            case noLimit(EventStore_Client_Empty)
        }

        package init() {}
    }

    package init() {}

    fileprivate var _options: EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options? = nil
}

package struct EventStore_Client_PersistentSubscriptions_ReplayParkedResp: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
}

package struct EventStore_Client_PersistentSubscriptions_ListReq: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var options: EventStore_Client_PersistentSubscriptions_ListReq.Options {
        get { _options ?? EventStore_Client_PersistentSubscriptions_ListReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    package var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    package mutating func clearOptions() { _options = nil }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package struct Options: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var listOption: EventStore_Client_PersistentSubscriptions_ListReq.Options.OneOf_ListOption? = nil

        package var listAllSubscriptions: EventStore_Client_Empty {
            get {
                if case let .listAllSubscriptions(v)? = listOption { return v }
                return EventStore_Client_Empty()
            }
            set { listOption = .listAllSubscriptions(newValue) }
        }

        package var listForStream: EventStore_Client_PersistentSubscriptions_ListReq.StreamOption {
            get {
                if case let .listForStream(v)? = listOption { return v }
                return EventStore_Client_PersistentSubscriptions_ListReq.StreamOption()
            }
            set { listOption = .listForStream(newValue) }
        }

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_ListOption: Equatable, Sendable {
            case listAllSubscriptions(EventStore_Client_Empty)
            case listForStream(EventStore_Client_PersistentSubscriptions_ListReq.StreamOption)
        }

        package init() {}
    }

    package struct StreamOption: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var streamOption: EventStore_Client_PersistentSubscriptions_ListReq.StreamOption.OneOf_StreamOption? = nil

        package var stream: EventStore_Client_StreamIdentifier {
            get {
                if case let .stream(v)? = streamOption { return v }
                return EventStore_Client_StreamIdentifier()
            }
            set { streamOption = .stream(newValue) }
        }

        package var all: EventStore_Client_Empty {
            get {
                if case let .all(v)? = streamOption { return v }
                return EventStore_Client_Empty()
            }
            set { streamOption = .all(newValue) }
        }

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_StreamOption: Equatable, Sendable {
            case stream(EventStore_Client_StreamIdentifier)
            case all(EventStore_Client_Empty)
        }

        package init() {}
    }

    package init() {}

    fileprivate var _options: EventStore_Client_PersistentSubscriptions_ListReq.Options? = nil
}

package struct EventStore_Client_PersistentSubscriptions_ListResp: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var subscriptions: [EventStore_Client_PersistentSubscriptions_SubscriptionInfo] = []

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "event_store.client.persistent_subscriptions"

extension EventStore_Client_PersistentSubscriptions_ReadReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".ReadReq"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
        2: .same(proto: "ack"),
        3: .same(proto: "nack"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_PersistentSubscriptions_ReadReq.Options?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .options(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .options(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_PersistentSubscriptions_ReadReq.Ack?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .ack(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .ack(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_PersistentSubscriptions_ReadReq.Nack?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .nack(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .nack(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch content {
        case .options?: try {
                guard case let .options(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .ack?: try {
                guard case let .ack(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .nack?: try {
                guard case let .nack(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadReq, rhs: EventStore_Client_PersistentSubscriptions_ReadReq) -> Bool {
        if lhs.content != rhs.content { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ReadReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReadReq.protoMessageName + ".Options"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        5: .same(proto: "all"),
        2: .standard(proto: "group_name"),
        3: .standard(proto: "buffer_size"),
        4: .standard(proto: "uuid_option"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_StreamIdentifier?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .streamIdentifier(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .streamIdentifier(v)
                    }
                }()
            case 2: try decoder.decodeSingularStringField(value: &groupName)
            case 3: try decoder.decodeSingularInt32Field(value: &bufferSize)
            case 4: try decoder.decodeSingularMessageField(value: &_uuidOption)
            case 5: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .all(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .all(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if case let .streamIdentifier(v)? = streamOption {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !groupName.isEmpty {
            try visitor.visitSingularStringField(value: groupName, fieldNumber: 2)
        }
        if bufferSize != 0 {
            try visitor.visitSingularInt32Field(value: bufferSize, fieldNumber: 3)
        }
        try { if let v = self._uuidOption {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try { if case let .all(v)? = self.streamOption {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadReq.Options, rhs: EventStore_Client_PersistentSubscriptions_ReadReq.Options) -> Bool {
        if lhs.streamOption != rhs.streamOption { return false }
        if lhs.groupName != rhs.groupName { return false }
        if lhs.bufferSize != rhs.bufferSize { return false }
        if lhs._uuidOption != rhs._uuidOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReadReq.Options.protoMessageName + ".UUIDOption"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "structured"),
        2: .same(proto: "string"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .structured(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .structured(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .string(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .string(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch content {
        case .structured?: try {
                guard case let .structured(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .string?: try {
                guard case let .string(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption, rhs: EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption) -> Bool {
        if lhs.content != rhs.content { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ReadReq.Ack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReadReq.protoMessageName + ".Ack"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "ids"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &id)
            case 2: try decoder.decodeRepeatedMessageField(value: &ids)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !id.isEmpty {
            try visitor.visitSingularBytesField(value: id, fieldNumber: 1)
        }
        if !ids.isEmpty {
            try visitor.visitRepeatedMessageField(value: ids, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadReq.Ack, rhs: EventStore_Client_PersistentSubscriptions_ReadReq.Ack) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.ids != rhs.ids { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ReadReq.Nack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReadReq.protoMessageName + ".Nack"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "ids"),
        3: .same(proto: "action"),
        4: .same(proto: "reason"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &id)
            case 2: try decoder.decodeRepeatedMessageField(value: &ids)
            case 3: try decoder.decodeSingularEnumField(value: &action)
            case 4: try decoder.decodeSingularStringField(value: &reason)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !id.isEmpty {
            try visitor.visitSingularBytesField(value: id, fieldNumber: 1)
        }
        if !ids.isEmpty {
            try visitor.visitRepeatedMessageField(value: ids, fieldNumber: 2)
        }
        if action != .unknown {
            try visitor.visitSingularEnumField(value: action, fieldNumber: 3)
        }
        if !reason.isEmpty {
            try visitor.visitSingularStringField(value: reason, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadReq.Nack, rhs: EventStore_Client_PersistentSubscriptions_ReadReq.Nack) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.ids != rhs.ids { return false }
        if lhs.action != rhs.action { return false }
        if lhs.reason != rhs.reason { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ReadReq.Nack.Action: SwiftProtobuf._ProtoNameProviding {
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Unknown"),
        1: .same(proto: "Park"),
        2: .same(proto: "Retry"),
        3: .same(proto: "Skip"),
        4: .same(proto: "Stop"),
    ]
}

extension EventStore_Client_PersistentSubscriptions_ReadResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".ReadResp"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "event"),
        2: .standard(proto: "subscription_confirmation"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .event(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .event(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_PersistentSubscriptions_ReadResp.SubscriptionConfirmation?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .subscriptionConfirmation(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .subscriptionConfirmation(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch content {
        case .event?: try {
                guard case let .event(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .subscriptionConfirmation?: try {
                guard case let .subscriptionConfirmation(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadResp, rhs: EventStore_Client_PersistentSubscriptions_ReadResp) -> Bool {
        if lhs.content != rhs.content { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReadResp.protoMessageName + ".ReadEvent"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "event"),
        2: .same(proto: "link"),
        3: .standard(proto: "commit_position"),
        4: .standard(proto: "no_position"),
        5: .standard(proto: "retry_count"),
        6: .standard(proto: "no_retry_count"),
    ]

    fileprivate class _StorageClass {
        var _event: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent?
        var _link: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent?
        var _position: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.OneOf_Position?
        var _count: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.OneOf_Count?

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _event = source._event
            _link = source._link
            _position = source._position
            _count = source._count
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularMessageField(value: &_storage._event)
                case 2: try decoder.decodeSingularMessageField(value: &_storage._link)
                case 3: try {
                        var v: UInt64?
                        try decoder.decodeSingularUInt64Field(value: &v)
                        if let v {
                            if _storage._position != nil { try decoder.handleConflictingOneOf() }
                            _storage._position = .commitPosition(v)
                        }
                    }()
                case 4: try {
                        var v: EventStore_Client_Empty?
                        var hadOneofValue = false
                        if let current = _storage._position {
                            hadOneofValue = true
                            if case let .noPosition(m) = current { v = m }
                        }
                        try decoder.decodeSingularMessageField(value: &v)
                        if let v {
                            if hadOneofValue { try decoder.handleConflictingOneOf() }
                            _storage._position = .noPosition(v)
                        }
                    }()
                case 5: try {
                        var v: Int32?
                        try decoder.decodeSingularInt32Field(value: &v)
                        if let v {
                            if _storage._count != nil { try decoder.handleConflictingOneOf() }
                            _storage._count = .retryCount(v)
                        }
                    }()
                case 6: try {
                        var v: EventStore_Client_Empty?
                        var hadOneofValue = false
                        if let current = _storage._count {
                            hadOneofValue = true
                            if case let .noRetryCount(m) = current { v = m }
                        }
                        try decoder.decodeSingularMessageField(value: &v)
                        if let v {
                            if hadOneofValue { try decoder.handleConflictingOneOf() }
                            _storage._count = .noRetryCount(v)
                        }
                    }()
                default: break
                }
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._event {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            try { if let v = _storage._link {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            } }()
            switch _storage._position {
            case .commitPosition?: try {
                    guard case let .commitPosition(v)? = _storage._position else { preconditionFailure() }
                    try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
                }()
            case .noPosition?: try {
                    guard case let .noPosition(v)? = _storage._position else { preconditionFailure() }
                    try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
                }()
            case nil: break
            }
            switch _storage._count {
            case .retryCount?: try {
                    guard case let .retryCount(v)? = _storage._count else { preconditionFailure() }
                    try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
                }()
            case .noRetryCount?: try {
                    guard case let .noRetryCount(v)? = _storage._count else { preconditionFailure() }
                    try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
                }()
            case nil: break
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent, rhs: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._event != rhs_storage._event { return false }
                if _storage._link != rhs_storage._link { return false }
                if _storage._position != rhs_storage._position { return false }
                if _storage._count != rhs_storage._count { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.protoMessageName + ".RecordedEvent"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .standard(proto: "stream_identifier"),
        3: .standard(proto: "stream_revision"),
        4: .standard(proto: "prepare_position"),
        5: .standard(proto: "commit_position"),
        6: .same(proto: "metadata"),
        7: .standard(proto: "custom_metadata"),
        8: .same(proto: "data"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_id)
            case 2: try decoder.decodeSingularMessageField(value: &_streamIdentifier)
            case 3: try decoder.decodeSingularUInt64Field(value: &streamRevision)
            case 4: try decoder.decodeSingularUInt64Field(value: &preparePosition)
            case 5: try decoder.decodeSingularUInt64Field(value: &commitPosition)
            case 6: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: &metadata)
            case 7: try decoder.decodeSingularBytesField(value: &customMetadata)
            case 8: try decoder.decodeSingularBytesField(value: &data)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _id {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try { if let v = self._streamIdentifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if streamRevision != 0 {
            try visitor.visitSingularUInt64Field(value: streamRevision, fieldNumber: 3)
        }
        if preparePosition != 0 {
            try visitor.visitSingularUInt64Field(value: preparePosition, fieldNumber: 4)
        }
        if commitPosition != 0 {
            try visitor.visitSingularUInt64Field(value: commitPosition, fieldNumber: 5)
        }
        if !metadata.isEmpty {
            try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: metadata, fieldNumber: 6)
        }
        if !customMetadata.isEmpty {
            try visitor.visitSingularBytesField(value: customMetadata, fieldNumber: 7)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent, rhs: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent) -> Bool {
        if lhs._id != rhs._id { return false }
        if lhs._streamIdentifier != rhs._streamIdentifier { return false }
        if lhs.streamRevision != rhs.streamRevision { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.metadata != rhs.metadata { return false }
        if lhs.customMetadata != rhs.customMetadata { return false }
        if lhs.data != rhs.data { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ReadResp.SubscriptionConfirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReadResp.protoMessageName + ".SubscriptionConfirmation"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "subscription_id"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &subscriptionID)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !subscriptionID.isEmpty {
            try visitor.visitSingularStringField(value: subscriptionID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadResp.SubscriptionConfirmation, rhs: EventStore_Client_PersistentSubscriptions_ReadResp.SubscriptionConfirmation) -> Bool {
        if lhs.subscriptionID != rhs.subscriptionID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".CreateReq"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq, rhs: EventStore_Client_PersistentSubscriptions_CreateReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.ConsumerStrategy: SwiftProtobuf._ProtoNameProviding {
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "DispatchToSingle"),
        1: .same(proto: "RoundRobin"),
        2: .same(proto: "Pinned"),
    ]
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_CreateReq.protoMessageName + ".Options"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        4: .same(proto: "stream"),
        5: .same(proto: "all"),
        1: .standard(proto: "stream_identifier"),
        2: .standard(proto: "group_name"),
        3: .same(proto: "settings"),
    ]

    fileprivate class _StorageClass {
        var _streamOption: EventStore_Client_PersistentSubscriptions_CreateReq.Options.OneOf_StreamOption?
        var _streamIdentifier: EventStore_Client_StreamIdentifier?
        var _groupName: String = .init()
        var _settings: EventStore_Client_PersistentSubscriptions_CreateReq.Settings?

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _streamOption = source._streamOption
            _streamIdentifier = source._streamIdentifier
            _groupName = source._groupName
            _settings = source._settings
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularMessageField(value: &_storage._streamIdentifier)
                case 2: try decoder.decodeSingularStringField(value: &_storage._groupName)
                case 3: try decoder.decodeSingularMessageField(value: &_storage._settings)
                case 4: try {
                        var v: EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions?
                        var hadOneofValue = false
                        if let current = _storage._streamOption {
                            hadOneofValue = true
                            if case let .stream(m) = current { v = m }
                        }
                        try decoder.decodeSingularMessageField(value: &v)
                        if let v {
                            if hadOneofValue { try decoder.handleConflictingOneOf() }
                            _storage._streamOption = .stream(v)
                        }
                    }()
                case 5: try {
                        var v: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions?
                        var hadOneofValue = false
                        if let current = _storage._streamOption {
                            hadOneofValue = true
                            if case let .all(m) = current { v = m }
                        }
                        try decoder.decodeSingularMessageField(value: &v)
                        if let v {
                            if hadOneofValue { try decoder.handleConflictingOneOf() }
                            _storage._streamOption = .all(v)
                        }
                    }()
                default: break
                }
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._streamIdentifier {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            if !_storage._groupName.isEmpty {
                try visitor.visitSingularStringField(value: _storage._groupName, fieldNumber: 2)
            }
            try { if let v = _storage._settings {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            } }()
            switch _storage._streamOption {
            case .stream?: try {
                    guard case let .stream(v)? = _storage._streamOption else { preconditionFailure() }
                    try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
                }()
            case .all?: try {
                    guard case let .all(v)? = _storage._streamOption else { preconditionFailure() }
                    try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
                }()
            case nil: break
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq.Options, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.Options) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._streamOption != rhs_storage._streamOption { return false }
                if _storage._streamIdentifier != rhs_storage._streamIdentifier { return false }
                if _storage._groupName != rhs_storage._groupName { return false }
                if _storage._settings != rhs_storage._settings { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_CreateReq.protoMessageName + ".StreamOptions"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        2: .same(proto: "revision"),
        3: .same(proto: "start"),
        4: .same(proto: "end"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_streamIdentifier)
            case 2: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.revisionOption != nil { try decoder.handleConflictingOneOf() }
                        self.revisionOption = .revision(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.revisionOption {
                        hadOneofValue = true
                        if case let .start(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.revisionOption = .start(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.revisionOption {
                        hadOneofValue = true
                        if case let .end(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.revisionOption = .end(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _streamIdentifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        switch revisionOption {
        case .revision?: try {
                guard case let .revision(v)? = self.revisionOption else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
            }()
        case .start?: try {
                guard case let .start(v)? = self.revisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .end?: try {
                guard case let .end(v)? = self.revisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions) -> Bool {
        if lhs._streamIdentifier != rhs._streamIdentifier { return false }
        if lhs.revisionOption != rhs.revisionOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_CreateReq.protoMessageName + ".AllOptions"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "position"),
        2: .same(proto: "start"),
        3: .same(proto: "end"),
        4: .same(proto: "filter"),
        5: .standard(proto: "no_filter"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_PersistentSubscriptions_CreateReq.Position?
                    var hadOneofValue = false
                    if let current = self.allOption {
                        hadOneofValue = true
                        if case let .position(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.allOption = .position(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.allOption {
                        hadOneofValue = true
                        if case let .start(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.allOption = .start(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.allOption {
                        hadOneofValue = true
                        if case let .end(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.allOption = .end(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions?
                    var hadOneofValue = false
                    if let current = self.filterOption {
                        hadOneofValue = true
                        if case let .filter(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.filterOption = .filter(v)
                    }
                }()
            case 5: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.filterOption {
                        hadOneofValue = true
                        if case let .noFilter(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.filterOption = .noFilter(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch allOption {
        case .position?: try {
                guard case let .position(v)? = self.allOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .start?: try {
                guard case let .start(v)? = self.allOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .end?: try {
                guard case let .end(v)? = self.allOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        switch filterOption {
        case .filter?: try {
                guard case let .filter(v)? = self.filterOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .noFilter?: try {
                guard case let .noFilter(v)? = self.filterOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions) -> Bool {
        if lhs.allOption != rhs.allOption { return false }
        if lhs.filterOption != rhs.filterOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.protoMessageName + ".FilterOptions"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        2: .standard(proto: "event_type"),
        3: .same(proto: "max"),
        4: .same(proto: "count"),
        5: .same(proto: "checkpointIntervalMultiplier"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression?
                    var hadOneofValue = false
                    if let current = self.filter {
                        hadOneofValue = true
                        if case let .streamIdentifier(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.filter = .streamIdentifier(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression?
                    var hadOneofValue = false
                    if let current = self.filter {
                        hadOneofValue = true
                        if case let .eventType(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.filter = .eventType(v)
                    }
                }()
            case 3: try {
                    var v: UInt32?
                    try decoder.decodeSingularUInt32Field(value: &v)
                    if let v {
                        if self.window != nil { try decoder.handleConflictingOneOf() }
                        self.window = .max(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.window {
                        hadOneofValue = true
                        if case let .count(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.window = .count(v)
                    }
                }()
            case 5: try decoder.decodeSingularUInt32Field(value: &checkpointIntervalMultiplier)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch filter {
        case .streamIdentifier?: try {
                guard case let .streamIdentifier(v)? = self.filter else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .eventType?: try {
                guard case let .eventType(v)? = self.filter else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        switch window {
        case .max?: try {
                guard case let .max(v)? = self.window else { preconditionFailure() }
                try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
            }()
        case .count?: try {
                guard case let .count(v)? = self.window else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case nil: break
        }
        if checkpointIntervalMultiplier != 0 {
            try visitor.visitSingularUInt32Field(value: checkpointIntervalMultiplier, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions) -> Bool {
        if lhs.filter != rhs.filter { return false }
        if lhs.window != rhs.window { return false }
        if lhs.checkpointIntervalMultiplier != rhs.checkpointIntervalMultiplier { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.protoMessageName + ".Expression"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "regex"),
        2: .same(proto: "prefix"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &regex)
            case 2: try decoder.decodeRepeatedStringField(value: &prefix)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !regex.isEmpty {
            try visitor.visitSingularStringField(value: regex, fieldNumber: 1)
        }
        if !prefix.isEmpty {
            try visitor.visitRepeatedStringField(value: prefix, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression) -> Bool {
        if lhs.regex != rhs.regex { return false }
        if lhs.prefix != rhs.prefix { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_CreateReq.protoMessageName + ".Position"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "commit_position"),
        2: .standard(proto: "prepare_position"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt64Field(value: &commitPosition)
            case 2: try decoder.decodeSingularUInt64Field(value: &preparePosition)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if commitPosition != 0 {
            try visitor.visitSingularUInt64Field(value: commitPosition, fieldNumber: 1)
        }
        if preparePosition != 0 {
            try visitor.visitSingularUInt64Field(value: preparePosition, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq.Position, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.Position) -> Bool {
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.Settings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_CreateReq.protoMessageName + ".Settings"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "resolve_links"),
        2: .same(proto: "revision"),
        3: .standard(proto: "extra_statistics"),
        5: .standard(proto: "max_retry_count"),
        7: .standard(proto: "min_checkpoint_count"),
        8: .standard(proto: "max_checkpoint_count"),
        9: .standard(proto: "max_subscriber_count"),
        10: .standard(proto: "live_buffer_size"),
        11: .standard(proto: "read_batch_size"),
        12: .standard(proto: "history_buffer_size"),
        13: .standard(proto: "named_consumer_strategy"),
        4: .standard(proto: "message_timeout_ticks"),
        14: .standard(proto: "message_timeout_ms"),
        6: .standard(proto: "checkpoint_after_ticks"),
        15: .standard(proto: "checkpoint_after_ms"),
        16: .standard(proto: "consumer_strategy"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &resolveLinks)
            case 2: try decoder.decodeSingularUInt64Field(value: &revision)
            case 3: try decoder.decodeSingularBoolField(value: &extraStatistics)
            case 4: try {
                    var v: Int64?
                    try decoder.decodeSingularInt64Field(value: &v)
                    if let v {
                        if self.messageTimeout != nil { try decoder.handleConflictingOneOf() }
                        self.messageTimeout = .messageTimeoutTicks(v)
                    }
                }()
            case 5: try decoder.decodeSingularInt32Field(value: &maxRetryCount)
            case 6: try {
                    var v: Int64?
                    try decoder.decodeSingularInt64Field(value: &v)
                    if let v {
                        if self.checkpointAfter != nil { try decoder.handleConflictingOneOf() }
                        self.checkpointAfter = .checkpointAfterTicks(v)
                    }
                }()
            case 7: try decoder.decodeSingularInt32Field(value: &minCheckpointCount)
            case 8: try decoder.decodeSingularInt32Field(value: &maxCheckpointCount)
            case 9: try decoder.decodeSingularInt32Field(value: &maxSubscriberCount)
            case 10: try decoder.decodeSingularInt32Field(value: &liveBufferSize)
            case 11: try decoder.decodeSingularInt32Field(value: &readBatchSize)
            case 12: try decoder.decodeSingularInt32Field(value: &historyBufferSize)
            case 13: try decoder.decodeSingularEnumField(value: &namedConsumerStrategy)
            case 14: try {
                    var v: Int32?
                    try decoder.decodeSingularInt32Field(value: &v)
                    if let v {
                        if self.messageTimeout != nil { try decoder.handleConflictingOneOf() }
                        self.messageTimeout = .messageTimeoutMs(v)
                    }
                }()
            case 15: try {
                    var v: Int32?
                    try decoder.decodeSingularInt32Field(value: &v)
                    if let v {
                        if self.checkpointAfter != nil { try decoder.handleConflictingOneOf() }
                        self.checkpointAfter = .checkpointAfterMs(v)
                    }
                }()
            case 16: try decoder.decodeSingularStringField(value: &consumerStrategy)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if resolveLinks != false {
            try visitor.visitSingularBoolField(value: resolveLinks, fieldNumber: 1)
        }
        if revision != 0 {
            try visitor.visitSingularUInt64Field(value: revision, fieldNumber: 2)
        }
        if extraStatistics != false {
            try visitor.visitSingularBoolField(value: extraStatistics, fieldNumber: 3)
        }
        try { if case let .messageTimeoutTicks(v)? = self.messageTimeout {
            try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
        } }()
        if maxRetryCount != 0 {
            try visitor.visitSingularInt32Field(value: maxRetryCount, fieldNumber: 5)
        }
        try { if case let .checkpointAfterTicks(v)? = self.checkpointAfter {
            try visitor.visitSingularInt64Field(value: v, fieldNumber: 6)
        } }()
        if minCheckpointCount != 0 {
            try visitor.visitSingularInt32Field(value: minCheckpointCount, fieldNumber: 7)
        }
        if maxCheckpointCount != 0 {
            try visitor.visitSingularInt32Field(value: maxCheckpointCount, fieldNumber: 8)
        }
        if maxSubscriberCount != 0 {
            try visitor.visitSingularInt32Field(value: maxSubscriberCount, fieldNumber: 9)
        }
        if liveBufferSize != 0 {
            try visitor.visitSingularInt32Field(value: liveBufferSize, fieldNumber: 10)
        }
        if readBatchSize != 0 {
            try visitor.visitSingularInt32Field(value: readBatchSize, fieldNumber: 11)
        }
        if historyBufferSize != 0 {
            try visitor.visitSingularInt32Field(value: historyBufferSize, fieldNumber: 12)
        }
        if namedConsumerStrategy != .dispatchToSingle {
            try visitor.visitSingularEnumField(value: namedConsumerStrategy, fieldNumber: 13)
        }
        try { if case let .messageTimeoutMs(v)? = self.messageTimeout {
            try visitor.visitSingularInt32Field(value: v, fieldNumber: 14)
        } }()
        try { if case let .checkpointAfterMs(v)? = self.checkpointAfter {
            try visitor.visitSingularInt32Field(value: v, fieldNumber: 15)
        } }()
        if !consumerStrategy.isEmpty {
            try visitor.visitSingularStringField(value: consumerStrategy, fieldNumber: 16)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq.Settings, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.Settings) -> Bool {
        if lhs.resolveLinks != rhs.resolveLinks { return false }
        if lhs.revision != rhs.revision { return false }
        if lhs.extraStatistics != rhs.extraStatistics { return false }
        if lhs.maxRetryCount != rhs.maxRetryCount { return false }
        if lhs.minCheckpointCount != rhs.minCheckpointCount { return false }
        if lhs.maxCheckpointCount != rhs.maxCheckpointCount { return false }
        if lhs.maxSubscriberCount != rhs.maxSubscriberCount { return false }
        if lhs.liveBufferSize != rhs.liveBufferSize { return false }
        if lhs.readBatchSize != rhs.readBatchSize { return false }
        if lhs.historyBufferSize != rhs.historyBufferSize { return false }
        if lhs.namedConsumerStrategy != rhs.namedConsumerStrategy { return false }
        if lhs.messageTimeout != rhs.messageTimeout { return false }
        if lhs.checkpointAfter != rhs.checkpointAfter { return false }
        if lhs.consumerStrategy != rhs.consumerStrategy { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_CreateResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".CreateResp"
    package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateResp, rhs: EventStore_Client_PersistentSubscriptions_CreateResp) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_UpdateReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".UpdateReq"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_UpdateReq, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_UpdateReq.ConsumerStrategy: SwiftProtobuf._ProtoNameProviding {
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "DispatchToSingle"),
        1: .same(proto: "RoundRobin"),
        2: .same(proto: "Pinned"),
    ]
}

extension EventStore_Client_PersistentSubscriptions_UpdateReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_UpdateReq.protoMessageName + ".Options"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        4: .same(proto: "stream"),
        5: .same(proto: "all"),
        1: .standard(proto: "stream_identifier"),
        2: .standard(proto: "group_name"),
        3: .same(proto: "settings"),
    ]

    fileprivate class _StorageClass {
        var _streamOption: EventStore_Client_PersistentSubscriptions_UpdateReq.Options.OneOf_StreamOption?
        var _streamIdentifier: EventStore_Client_StreamIdentifier?
        var _groupName: String = .init()
        var _settings: EventStore_Client_PersistentSubscriptions_UpdateReq.Settings?

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _streamOption = source._streamOption
            _streamIdentifier = source._streamIdentifier
            _groupName = source._groupName
            _settings = source._settings
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularMessageField(value: &_storage._streamIdentifier)
                case 2: try decoder.decodeSingularStringField(value: &_storage._groupName)
                case 3: try decoder.decodeSingularMessageField(value: &_storage._settings)
                case 4: try {
                        var v: EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions?
                        var hadOneofValue = false
                        if let current = _storage._streamOption {
                            hadOneofValue = true
                            if case let .stream(m) = current { v = m }
                        }
                        try decoder.decodeSingularMessageField(value: &v)
                        if let v {
                            if hadOneofValue { try decoder.handleConflictingOneOf() }
                            _storage._streamOption = .stream(v)
                        }
                    }()
                case 5: try {
                        var v: EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions?
                        var hadOneofValue = false
                        if let current = _storage._streamOption {
                            hadOneofValue = true
                            if case let .all(m) = current { v = m }
                        }
                        try decoder.decodeSingularMessageField(value: &v)
                        if let v {
                            if hadOneofValue { try decoder.handleConflictingOneOf() }
                            _storage._streamOption = .all(v)
                        }
                    }()
                default: break
                }
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._streamIdentifier {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            if !_storage._groupName.isEmpty {
                try visitor.visitSingularStringField(value: _storage._groupName, fieldNumber: 2)
            }
            try { if let v = _storage._settings {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            } }()
            switch _storage._streamOption {
            case .stream?: try {
                    guard case let .stream(v)? = _storage._streamOption else { preconditionFailure() }
                    try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
                }()
            case .all?: try {
                    guard case let .all(v)? = _storage._streamOption else { preconditionFailure() }
                    try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
                }()
            case nil: break
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Options, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Options) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._streamOption != rhs_storage._streamOption { return false }
                if _storage._streamIdentifier != rhs_storage._streamIdentifier { return false }
                if _storage._groupName != rhs_storage._groupName { return false }
                if _storage._settings != rhs_storage._settings { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_UpdateReq.protoMessageName + ".StreamOptions"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        2: .same(proto: "revision"),
        3: .same(proto: "start"),
        4: .same(proto: "end"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_streamIdentifier)
            case 2: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.revisionOption != nil { try decoder.handleConflictingOneOf() }
                        self.revisionOption = .revision(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.revisionOption {
                        hadOneofValue = true
                        if case let .start(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.revisionOption = .start(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.revisionOption {
                        hadOneofValue = true
                        if case let .end(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.revisionOption = .end(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _streamIdentifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        switch revisionOption {
        case .revision?: try {
                guard case let .revision(v)? = self.revisionOption else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
            }()
        case .start?: try {
                guard case let .start(v)? = self.revisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .end?: try {
                guard case let .end(v)? = self.revisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions) -> Bool {
        if lhs._streamIdentifier != rhs._streamIdentifier { return false }
        if lhs.revisionOption != rhs.revisionOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_UpdateReq.protoMessageName + ".AllOptions"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "position"),
        2: .same(proto: "start"),
        3: .same(proto: "end"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_PersistentSubscriptions_UpdateReq.Position?
                    var hadOneofValue = false
                    if let current = self.allOption {
                        hadOneofValue = true
                        if case let .position(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.allOption = .position(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.allOption {
                        hadOneofValue = true
                        if case let .start(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.allOption = .start(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.allOption {
                        hadOneofValue = true
                        if case let .end(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.allOption = .end(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch allOption {
        case .position?: try {
                guard case let .position(v)? = self.allOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .start?: try {
                guard case let .start(v)? = self.allOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .end?: try {
                guard case let .end(v)? = self.allOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions) -> Bool {
        if lhs.allOption != rhs.allOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_UpdateReq.Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_UpdateReq.protoMessageName + ".Position"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "commit_position"),
        2: .standard(proto: "prepare_position"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt64Field(value: &commitPosition)
            case 2: try decoder.decodeSingularUInt64Field(value: &preparePosition)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if commitPosition != 0 {
            try visitor.visitSingularUInt64Field(value: commitPosition, fieldNumber: 1)
        }
        if preparePosition != 0 {
            try visitor.visitSingularUInt64Field(value: preparePosition, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Position, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Position) -> Bool {
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_UpdateReq.Settings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_UpdateReq.protoMessageName + ".Settings"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "resolve_links"),
        2: .same(proto: "revision"),
        3: .standard(proto: "extra_statistics"),
        5: .standard(proto: "max_retry_count"),
        7: .standard(proto: "min_checkpoint_count"),
        8: .standard(proto: "max_checkpoint_count"),
        9: .standard(proto: "max_subscriber_count"),
        10: .standard(proto: "live_buffer_size"),
        11: .standard(proto: "read_batch_size"),
        12: .standard(proto: "history_buffer_size"),
        13: .standard(proto: "named_consumer_strategy"),
        4: .standard(proto: "message_timeout_ticks"),
        14: .standard(proto: "message_timeout_ms"),
        6: .standard(proto: "checkpoint_after_ticks"),
        15: .standard(proto: "checkpoint_after_ms"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &resolveLinks)
            case 2: try decoder.decodeSingularUInt64Field(value: &revision)
            case 3: try decoder.decodeSingularBoolField(value: &extraStatistics)
            case 4: try {
                    var v: Int64?
                    try decoder.decodeSingularInt64Field(value: &v)
                    if let v {
                        if self.messageTimeout != nil { try decoder.handleConflictingOneOf() }
                        self.messageTimeout = .messageTimeoutTicks(v)
                    }
                }()
            case 5: try decoder.decodeSingularInt32Field(value: &maxRetryCount)
            case 6: try {
                    var v: Int64?
                    try decoder.decodeSingularInt64Field(value: &v)
                    if let v {
                        if self.checkpointAfter != nil { try decoder.handleConflictingOneOf() }
                        self.checkpointAfter = .checkpointAfterTicks(v)
                    }
                }()
            case 7: try decoder.decodeSingularInt32Field(value: &minCheckpointCount)
            case 8: try decoder.decodeSingularInt32Field(value: &maxCheckpointCount)
            case 9: try decoder.decodeSingularInt32Field(value: &maxSubscriberCount)
            case 10: try decoder.decodeSingularInt32Field(value: &liveBufferSize)
            case 11: try decoder.decodeSingularInt32Field(value: &readBatchSize)
            case 12: try decoder.decodeSingularInt32Field(value: &historyBufferSize)
            case 13: try decoder.decodeSingularEnumField(value: &namedConsumerStrategy)
            case 14: try {
                    var v: Int32?
                    try decoder.decodeSingularInt32Field(value: &v)
                    if let v {
                        if self.messageTimeout != nil { try decoder.handleConflictingOneOf() }
                        self.messageTimeout = .messageTimeoutMs(v)
                    }
                }()
            case 15: try {
                    var v: Int32?
                    try decoder.decodeSingularInt32Field(value: &v)
                    if let v {
                        if self.checkpointAfter != nil { try decoder.handleConflictingOneOf() }
                        self.checkpointAfter = .checkpointAfterMs(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if resolveLinks != false {
            try visitor.visitSingularBoolField(value: resolveLinks, fieldNumber: 1)
        }
        if revision != 0 {
            try visitor.visitSingularUInt64Field(value: revision, fieldNumber: 2)
        }
        if extraStatistics != false {
            try visitor.visitSingularBoolField(value: extraStatistics, fieldNumber: 3)
        }
        try { if case let .messageTimeoutTicks(v)? = self.messageTimeout {
            try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
        } }()
        if maxRetryCount != 0 {
            try visitor.visitSingularInt32Field(value: maxRetryCount, fieldNumber: 5)
        }
        try { if case let .checkpointAfterTicks(v)? = self.checkpointAfter {
            try visitor.visitSingularInt64Field(value: v, fieldNumber: 6)
        } }()
        if minCheckpointCount != 0 {
            try visitor.visitSingularInt32Field(value: minCheckpointCount, fieldNumber: 7)
        }
        if maxCheckpointCount != 0 {
            try visitor.visitSingularInt32Field(value: maxCheckpointCount, fieldNumber: 8)
        }
        if maxSubscriberCount != 0 {
            try visitor.visitSingularInt32Field(value: maxSubscriberCount, fieldNumber: 9)
        }
        if liveBufferSize != 0 {
            try visitor.visitSingularInt32Field(value: liveBufferSize, fieldNumber: 10)
        }
        if readBatchSize != 0 {
            try visitor.visitSingularInt32Field(value: readBatchSize, fieldNumber: 11)
        }
        if historyBufferSize != 0 {
            try visitor.visitSingularInt32Field(value: historyBufferSize, fieldNumber: 12)
        }
        if namedConsumerStrategy != .dispatchToSingle {
            try visitor.visitSingularEnumField(value: namedConsumerStrategy, fieldNumber: 13)
        }
        try { if case let .messageTimeoutMs(v)? = self.messageTimeout {
            try visitor.visitSingularInt32Field(value: v, fieldNumber: 14)
        } }()
        try { if case let .checkpointAfterMs(v)? = self.checkpointAfter {
            try visitor.visitSingularInt32Field(value: v, fieldNumber: 15)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Settings, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Settings) -> Bool {
        if lhs.resolveLinks != rhs.resolveLinks { return false }
        if lhs.revision != rhs.revision { return false }
        if lhs.extraStatistics != rhs.extraStatistics { return false }
        if lhs.maxRetryCount != rhs.maxRetryCount { return false }
        if lhs.minCheckpointCount != rhs.minCheckpointCount { return false }
        if lhs.maxCheckpointCount != rhs.maxCheckpointCount { return false }
        if lhs.maxSubscriberCount != rhs.maxSubscriberCount { return false }
        if lhs.liveBufferSize != rhs.liveBufferSize { return false }
        if lhs.readBatchSize != rhs.readBatchSize { return false }
        if lhs.historyBufferSize != rhs.historyBufferSize { return false }
        if lhs.namedConsumerStrategy != rhs.namedConsumerStrategy { return false }
        if lhs.messageTimeout != rhs.messageTimeout { return false }
        if lhs.checkpointAfter != rhs.checkpointAfter { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_UpdateResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".UpdateResp"
    package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_UpdateResp, rhs: EventStore_Client_PersistentSubscriptions_UpdateResp) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_DeleteReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".DeleteReq"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_DeleteReq, rhs: EventStore_Client_PersistentSubscriptions_DeleteReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_DeleteReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_DeleteReq.protoMessageName + ".Options"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        3: .same(proto: "all"),
        2: .standard(proto: "group_name"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_StreamIdentifier?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .streamIdentifier(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .streamIdentifier(v)
                    }
                }()
            case 2: try decoder.decodeSingularStringField(value: &groupName)
            case 3: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .all(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .all(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if case let .streamIdentifier(v)? = streamOption {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !groupName.isEmpty {
            try visitor.visitSingularStringField(value: groupName, fieldNumber: 2)
        }
        try { if case let .all(v)? = self.streamOption {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_DeleteReq.Options, rhs: EventStore_Client_PersistentSubscriptions_DeleteReq.Options) -> Bool {
        if lhs.streamOption != rhs.streamOption { return false }
        if lhs.groupName != rhs.groupName { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_DeleteResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".DeleteResp"
    package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_DeleteResp, rhs: EventStore_Client_PersistentSubscriptions_DeleteResp) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_GetInfoReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".GetInfoReq"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_GetInfoReq, rhs: EventStore_Client_PersistentSubscriptions_GetInfoReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_GetInfoReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_GetInfoReq.protoMessageName + ".Options"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        2: .same(proto: "all"),
        3: .standard(proto: "group_name"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_StreamIdentifier?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .streamIdentifier(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .streamIdentifier(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .all(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .all(v)
                    }
                }()
            case 3: try decoder.decodeSingularStringField(value: &groupName)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch streamOption {
        case .streamIdentifier?: try {
                guard case let .streamIdentifier(v)? = self.streamOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .all?: try {
                guard case let .all(v)? = self.streamOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        if !groupName.isEmpty {
            try visitor.visitSingularStringField(value: groupName, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_GetInfoReq.Options, rhs: EventStore_Client_PersistentSubscriptions_GetInfoReq.Options) -> Bool {
        if lhs.streamOption != rhs.streamOption { return false }
        if lhs.groupName != rhs.groupName { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_GetInfoResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".GetInfoResp"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "subscription_info"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_subscriptionInfo)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _subscriptionInfo {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_GetInfoResp, rhs: EventStore_Client_PersistentSubscriptions_GetInfoResp) -> Bool {
        if lhs._subscriptionInfo != rhs._subscriptionInfo { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_SubscriptionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".SubscriptionInfo"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "event_source"),
        2: .standard(proto: "group_name"),
        3: .same(proto: "status"),
        4: .same(proto: "connections"),
        5: .standard(proto: "average_per_second"),
        6: .standard(proto: "total_items"),
        7: .standard(proto: "count_since_last_measurement"),
        8: .standard(proto: "last_checkpointed_event_position"),
        9: .standard(proto: "last_known_event_position"),
        10: .standard(proto: "resolve_link_tos"),
        11: .standard(proto: "start_from"),
        12: .standard(proto: "message_timeout_milliseconds"),
        13: .standard(proto: "extra_statistics"),
        14: .standard(proto: "max_retry_count"),
        15: .standard(proto: "live_buffer_size"),
        16: .standard(proto: "buffer_size"),
        17: .standard(proto: "read_batch_size"),
        18: .standard(proto: "check_point_after_milliseconds"),
        19: .standard(proto: "min_check_point_count"),
        20: .standard(proto: "max_check_point_count"),
        21: .standard(proto: "read_buffer_count"),
        22: .standard(proto: "live_buffer_count"),
        23: .standard(proto: "retry_buffer_count"),
        24: .standard(proto: "total_in_flight_messages"),
        25: .standard(proto: "outstanding_messages_count"),
        26: .standard(proto: "named_consumer_strategy"),
        27: .standard(proto: "max_subscriber_count"),
        28: .standard(proto: "parked_message_count"),
    ]

    fileprivate class _StorageClass {
        var _eventSource: String = .init()
        var _groupName: String = .init()
        var _status: String = .init()
        var _connections: [EventStore_Client_PersistentSubscriptions_SubscriptionInfo.ConnectionInfo] = []
        var _averagePerSecond: Int32 = 0
        var _totalItems: Int64 = 0
        var _countSinceLastMeasurement: Int64 = 0
        var _lastCheckpointedEventPosition: String = .init()
        var _lastKnownEventPosition: String = .init()
        var _resolveLinkTos: Bool = false
        var _startFrom: String = .init()
        var _messageTimeoutMilliseconds: Int32 = 0
        var _extraStatistics: Bool = false
        var _maxRetryCount: Int32 = 0
        var _liveBufferSize: Int32 = 0
        var _bufferSize: Int32 = 0
        var _readBatchSize: Int32 = 0
        var _checkPointAfterMilliseconds: Int32 = 0
        var _minCheckPointCount: Int32 = 0
        var _maxCheckPointCount: Int32 = 0
        var _readBufferCount: Int32 = 0
        var _liveBufferCount: Int64 = 0
        var _retryBufferCount: Int32 = 0
        var _totalInFlightMessages: Int32 = 0
        var _outstandingMessagesCount: Int32 = 0
        var _namedConsumerStrategy: String = .init()
        var _maxSubscriberCount: Int32 = 0
        var _parkedMessageCount: Int64 = 0

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _eventSource = source._eventSource
            _groupName = source._groupName
            _status = source._status
            _connections = source._connections
            _averagePerSecond = source._averagePerSecond
            _totalItems = source._totalItems
            _countSinceLastMeasurement = source._countSinceLastMeasurement
            _lastCheckpointedEventPosition = source._lastCheckpointedEventPosition
            _lastKnownEventPosition = source._lastKnownEventPosition
            _resolveLinkTos = source._resolveLinkTos
            _startFrom = source._startFrom
            _messageTimeoutMilliseconds = source._messageTimeoutMilliseconds
            _extraStatistics = source._extraStatistics
            _maxRetryCount = source._maxRetryCount
            _liveBufferSize = source._liveBufferSize
            _bufferSize = source._bufferSize
            _readBatchSize = source._readBatchSize
            _checkPointAfterMilliseconds = source._checkPointAfterMilliseconds
            _minCheckPointCount = source._minCheckPointCount
            _maxCheckPointCount = source._maxCheckPointCount
            _readBufferCount = source._readBufferCount
            _liveBufferCount = source._liveBufferCount
            _retryBufferCount = source._retryBufferCount
            _totalInFlightMessages = source._totalInFlightMessages
            _outstandingMessagesCount = source._outstandingMessagesCount
            _namedConsumerStrategy = source._namedConsumerStrategy
            _maxSubscriberCount = source._maxSubscriberCount
            _parkedMessageCount = source._parkedMessageCount
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularStringField(value: &_storage._eventSource)
                case 2: try decoder.decodeSingularStringField(value: &_storage._groupName)
                case 3: try decoder.decodeSingularStringField(value: &_storage._status)
                case 4: try decoder.decodeRepeatedMessageField(value: &_storage._connections)
                case 5: try decoder.decodeSingularInt32Field(value: &_storage._averagePerSecond)
                case 6: try decoder.decodeSingularInt64Field(value: &_storage._totalItems)
                case 7: try decoder.decodeSingularInt64Field(value: &_storage._countSinceLastMeasurement)
                case 8: try decoder.decodeSingularStringField(value: &_storage._lastCheckpointedEventPosition)
                case 9: try decoder.decodeSingularStringField(value: &_storage._lastKnownEventPosition)
                case 10: try decoder.decodeSingularBoolField(value: &_storage._resolveLinkTos)
                case 11: try decoder.decodeSingularStringField(value: &_storage._startFrom)
                case 12: try decoder.decodeSingularInt32Field(value: &_storage._messageTimeoutMilliseconds)
                case 13: try decoder.decodeSingularBoolField(value: &_storage._extraStatistics)
                case 14: try decoder.decodeSingularInt32Field(value: &_storage._maxRetryCount)
                case 15: try decoder.decodeSingularInt32Field(value: &_storage._liveBufferSize)
                case 16: try decoder.decodeSingularInt32Field(value: &_storage._bufferSize)
                case 17: try decoder.decodeSingularInt32Field(value: &_storage._readBatchSize)
                case 18: try decoder.decodeSingularInt32Field(value: &_storage._checkPointAfterMilliseconds)
                case 19: try decoder.decodeSingularInt32Field(value: &_storage._minCheckPointCount)
                case 20: try decoder.decodeSingularInt32Field(value: &_storage._maxCheckPointCount)
                case 21: try decoder.decodeSingularInt32Field(value: &_storage._readBufferCount)
                case 22: try decoder.decodeSingularInt64Field(value: &_storage._liveBufferCount)
                case 23: try decoder.decodeSingularInt32Field(value: &_storage._retryBufferCount)
                case 24: try decoder.decodeSingularInt32Field(value: &_storage._totalInFlightMessages)
                case 25: try decoder.decodeSingularInt32Field(value: &_storage._outstandingMessagesCount)
                case 26: try decoder.decodeSingularStringField(value: &_storage._namedConsumerStrategy)
                case 27: try decoder.decodeSingularInt32Field(value: &_storage._maxSubscriberCount)
                case 28: try decoder.decodeSingularInt64Field(value: &_storage._parkedMessageCount)
                default: break
                }
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if !_storage._eventSource.isEmpty {
                try visitor.visitSingularStringField(value: _storage._eventSource, fieldNumber: 1)
            }
            if !_storage._groupName.isEmpty {
                try visitor.visitSingularStringField(value: _storage._groupName, fieldNumber: 2)
            }
            if !_storage._status.isEmpty {
                try visitor.visitSingularStringField(value: _storage._status, fieldNumber: 3)
            }
            if !_storage._connections.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._connections, fieldNumber: 4)
            }
            if _storage._averagePerSecond != 0 {
                try visitor.visitSingularInt32Field(value: _storage._averagePerSecond, fieldNumber: 5)
            }
            if _storage._totalItems != 0 {
                try visitor.visitSingularInt64Field(value: _storage._totalItems, fieldNumber: 6)
            }
            if _storage._countSinceLastMeasurement != 0 {
                try visitor.visitSingularInt64Field(value: _storage._countSinceLastMeasurement, fieldNumber: 7)
            }
            if !_storage._lastCheckpointedEventPosition.isEmpty {
                try visitor.visitSingularStringField(value: _storage._lastCheckpointedEventPosition, fieldNumber: 8)
            }
            if !_storage._lastKnownEventPosition.isEmpty {
                try visitor.visitSingularStringField(value: _storage._lastKnownEventPosition, fieldNumber: 9)
            }
            if _storage._resolveLinkTos != false {
                try visitor.visitSingularBoolField(value: _storage._resolveLinkTos, fieldNumber: 10)
            }
            if !_storage._startFrom.isEmpty {
                try visitor.visitSingularStringField(value: _storage._startFrom, fieldNumber: 11)
            }
            if _storage._messageTimeoutMilliseconds != 0 {
                try visitor.visitSingularInt32Field(value: _storage._messageTimeoutMilliseconds, fieldNumber: 12)
            }
            if _storage._extraStatistics != false {
                try visitor.visitSingularBoolField(value: _storage._extraStatistics, fieldNumber: 13)
            }
            if _storage._maxRetryCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._maxRetryCount, fieldNumber: 14)
            }
            if _storage._liveBufferSize != 0 {
                try visitor.visitSingularInt32Field(value: _storage._liveBufferSize, fieldNumber: 15)
            }
            if _storage._bufferSize != 0 {
                try visitor.visitSingularInt32Field(value: _storage._bufferSize, fieldNumber: 16)
            }
            if _storage._readBatchSize != 0 {
                try visitor.visitSingularInt32Field(value: _storage._readBatchSize, fieldNumber: 17)
            }
            if _storage._checkPointAfterMilliseconds != 0 {
                try visitor.visitSingularInt32Field(value: _storage._checkPointAfterMilliseconds, fieldNumber: 18)
            }
            if _storage._minCheckPointCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._minCheckPointCount, fieldNumber: 19)
            }
            if _storage._maxCheckPointCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._maxCheckPointCount, fieldNumber: 20)
            }
            if _storage._readBufferCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._readBufferCount, fieldNumber: 21)
            }
            if _storage._liveBufferCount != 0 {
                try visitor.visitSingularInt64Field(value: _storage._liveBufferCount, fieldNumber: 22)
            }
            if _storage._retryBufferCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._retryBufferCount, fieldNumber: 23)
            }
            if _storage._totalInFlightMessages != 0 {
                try visitor.visitSingularInt32Field(value: _storage._totalInFlightMessages, fieldNumber: 24)
            }
            if _storage._outstandingMessagesCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._outstandingMessagesCount, fieldNumber: 25)
            }
            if !_storage._namedConsumerStrategy.isEmpty {
                try visitor.visitSingularStringField(value: _storage._namedConsumerStrategy, fieldNumber: 26)
            }
            if _storage._maxSubscriberCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._maxSubscriberCount, fieldNumber: 27)
            }
            if _storage._parkedMessageCount != 0 {
                try visitor.visitSingularInt64Field(value: _storage._parkedMessageCount, fieldNumber: 28)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_SubscriptionInfo, rhs: EventStore_Client_PersistentSubscriptions_SubscriptionInfo) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._eventSource != rhs_storage._eventSource { return false }
                if _storage._groupName != rhs_storage._groupName { return false }
                if _storage._status != rhs_storage._status { return false }
                if _storage._connections != rhs_storage._connections { return false }
                if _storage._averagePerSecond != rhs_storage._averagePerSecond { return false }
                if _storage._totalItems != rhs_storage._totalItems { return false }
                if _storage._countSinceLastMeasurement != rhs_storage._countSinceLastMeasurement { return false }
                if _storage._lastCheckpointedEventPosition != rhs_storage._lastCheckpointedEventPosition { return false }
                if _storage._lastKnownEventPosition != rhs_storage._lastKnownEventPosition { return false }
                if _storage._resolveLinkTos != rhs_storage._resolveLinkTos { return false }
                if _storage._startFrom != rhs_storage._startFrom { return false }
                if _storage._messageTimeoutMilliseconds != rhs_storage._messageTimeoutMilliseconds { return false }
                if _storage._extraStatistics != rhs_storage._extraStatistics { return false }
                if _storage._maxRetryCount != rhs_storage._maxRetryCount { return false }
                if _storage._liveBufferSize != rhs_storage._liveBufferSize { return false }
                if _storage._bufferSize != rhs_storage._bufferSize { return false }
                if _storage._readBatchSize != rhs_storage._readBatchSize { return false }
                if _storage._checkPointAfterMilliseconds != rhs_storage._checkPointAfterMilliseconds { return false }
                if _storage._minCheckPointCount != rhs_storage._minCheckPointCount { return false }
                if _storage._maxCheckPointCount != rhs_storage._maxCheckPointCount { return false }
                if _storage._readBufferCount != rhs_storage._readBufferCount { return false }
                if _storage._liveBufferCount != rhs_storage._liveBufferCount { return false }
                if _storage._retryBufferCount != rhs_storage._retryBufferCount { return false }
                if _storage._totalInFlightMessages != rhs_storage._totalInFlightMessages { return false }
                if _storage._outstandingMessagesCount != rhs_storage._outstandingMessagesCount { return false }
                if _storage._namedConsumerStrategy != rhs_storage._namedConsumerStrategy { return false }
                if _storage._maxSubscriberCount != rhs_storage._maxSubscriberCount { return false }
                if _storage._parkedMessageCount != rhs_storage._parkedMessageCount { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_SubscriptionInfo.ConnectionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_SubscriptionInfo.protoMessageName + ".ConnectionInfo"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "from"),
        2: .same(proto: "username"),
        3: .standard(proto: "average_items_per_second"),
        4: .standard(proto: "total_items"),
        5: .standard(proto: "count_since_last_measurement"),
        6: .standard(proto: "observed_measurements"),
        7: .standard(proto: "available_slots"),
        8: .standard(proto: "in_flight_messages"),
        9: .standard(proto: "connection_name"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &from)
            case 2: try decoder.decodeSingularStringField(value: &username)
            case 3: try decoder.decodeSingularInt32Field(value: &averageItemsPerSecond)
            case 4: try decoder.decodeSingularInt64Field(value: &totalItems)
            case 5: try decoder.decodeSingularInt64Field(value: &countSinceLastMeasurement)
            case 6: try decoder.decodeRepeatedMessageField(value: &observedMeasurements)
            case 7: try decoder.decodeSingularInt32Field(value: &availableSlots)
            case 8: try decoder.decodeSingularInt32Field(value: &inFlightMessages)
            case 9: try decoder.decodeSingularStringField(value: &connectionName)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !from.isEmpty {
            try visitor.visitSingularStringField(value: from, fieldNumber: 1)
        }
        if !username.isEmpty {
            try visitor.visitSingularStringField(value: username, fieldNumber: 2)
        }
        if averageItemsPerSecond != 0 {
            try visitor.visitSingularInt32Field(value: averageItemsPerSecond, fieldNumber: 3)
        }
        if totalItems != 0 {
            try visitor.visitSingularInt64Field(value: totalItems, fieldNumber: 4)
        }
        if countSinceLastMeasurement != 0 {
            try visitor.visitSingularInt64Field(value: countSinceLastMeasurement, fieldNumber: 5)
        }
        if !observedMeasurements.isEmpty {
            try visitor.visitRepeatedMessageField(value: observedMeasurements, fieldNumber: 6)
        }
        if availableSlots != 0 {
            try visitor.visitSingularInt32Field(value: availableSlots, fieldNumber: 7)
        }
        if inFlightMessages != 0 {
            try visitor.visitSingularInt32Field(value: inFlightMessages, fieldNumber: 8)
        }
        if !connectionName.isEmpty {
            try visitor.visitSingularStringField(value: connectionName, fieldNumber: 9)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_SubscriptionInfo.ConnectionInfo, rhs: EventStore_Client_PersistentSubscriptions_SubscriptionInfo.ConnectionInfo) -> Bool {
        if lhs.from != rhs.from { return false }
        if lhs.username != rhs.username { return false }
        if lhs.averageItemsPerSecond != rhs.averageItemsPerSecond { return false }
        if lhs.totalItems != rhs.totalItems { return false }
        if lhs.countSinceLastMeasurement != rhs.countSinceLastMeasurement { return false }
        if lhs.observedMeasurements != rhs.observedMeasurements { return false }
        if lhs.availableSlots != rhs.availableSlots { return false }
        if lhs.inFlightMessages != rhs.inFlightMessages { return false }
        if lhs.connectionName != rhs.connectionName { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_SubscriptionInfo.Measurement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_SubscriptionInfo.protoMessageName + ".Measurement"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "key"),
        2: .same(proto: "value"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &key)
            case 2: try decoder.decodeSingularInt64Field(value: &value)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !key.isEmpty {
            try visitor.visitSingularStringField(value: key, fieldNumber: 1)
        }
        if value != 0 {
            try visitor.visitSingularInt64Field(value: value, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_SubscriptionInfo.Measurement, rhs: EventStore_Client_PersistentSubscriptions_SubscriptionInfo.Measurement) -> Bool {
        if lhs.key != rhs.key { return false }
        if lhs.value != rhs.value { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ReplayParkedReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".ReplayParkedReq"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_ReplayParkedReq, rhs: EventStore_Client_PersistentSubscriptions_ReplayParkedReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReplayParkedReq.protoMessageName + ".Options"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "group_name"),
        2: .standard(proto: "stream_identifier"),
        3: .same(proto: "all"),
        4: .standard(proto: "stop_at"),
        5: .standard(proto: "no_limit"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &groupName)
            case 2: try {
                    var v: EventStore_Client_StreamIdentifier?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .streamIdentifier(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .streamIdentifier(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .all(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .all(v)
                    }
                }()
            case 4: try {
                    var v: Int64?
                    try decoder.decodeSingularInt64Field(value: &v)
                    if let v {
                        if self.stopAtOption != nil { try decoder.handleConflictingOneOf() }
                        self.stopAtOption = .stopAt(v)
                    }
                }()
            case 5: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.stopAtOption {
                        hadOneofValue = true
                        if case let .noLimit(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.stopAtOption = .noLimit(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !groupName.isEmpty {
            try visitor.visitSingularStringField(value: groupName, fieldNumber: 1)
        }
        switch streamOption {
        case .streamIdentifier?: try {
                guard case let .streamIdentifier(v)? = self.streamOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .all?: try {
                guard case let .all(v)? = self.streamOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        switch stopAtOption {
        case .stopAt?: try {
                guard case let .stopAt(v)? = self.stopAtOption else { preconditionFailure() }
                try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
            }()
        case .noLimit?: try {
                guard case let .noLimit(v)? = self.stopAtOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options, rhs: EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options) -> Bool {
        if lhs.groupName != rhs.groupName { return false }
        if lhs.streamOption != rhs.streamOption { return false }
        if lhs.stopAtOption != rhs.stopAtOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ReplayParkedResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".ReplayParkedResp"
    package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_ReplayParkedResp, rhs: EventStore_Client_PersistentSubscriptions_ReplayParkedResp) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ListReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".ListReq"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_ListReq, rhs: EventStore_Client_PersistentSubscriptions_ListReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ListReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ListReq.protoMessageName + ".Options"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "list_all_subscriptions"),
        2: .standard(proto: "list_for_stream"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.listOption {
                        hadOneofValue = true
                        if case let .listAllSubscriptions(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.listOption = .listAllSubscriptions(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_PersistentSubscriptions_ListReq.StreamOption?
                    var hadOneofValue = false
                    if let current = self.listOption {
                        hadOneofValue = true
                        if case let .listForStream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.listOption = .listForStream(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch listOption {
        case .listAllSubscriptions?: try {
                guard case let .listAllSubscriptions(v)? = self.listOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .listForStream?: try {
                guard case let .listForStream(v)? = self.listOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_ListReq.Options, rhs: EventStore_Client_PersistentSubscriptions_ListReq.Options) -> Bool {
        if lhs.listOption != rhs.listOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ListReq.StreamOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ListReq.protoMessageName + ".StreamOption"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "stream"),
        2: .same(proto: "all"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_StreamIdentifier?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .stream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .stream(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .all(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .all(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch streamOption {
        case .stream?: try {
                guard case let .stream(v)? = self.streamOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .all?: try {
                guard case let .all(v)? = self.streamOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_ListReq.StreamOption, rhs: EventStore_Client_PersistentSubscriptions_ListReq.StreamOption) -> Bool {
        if lhs.streamOption != rhs.streamOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ListResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".ListResp"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "subscriptions"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &subscriptions)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !subscriptions.isEmpty {
            try visitor.visitRepeatedMessageField(value: subscriptions, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_PersistentSubscriptions_ListResp, rhs: EventStore_Client_PersistentSubscriptions_ListResp) -> Bool {
        if lhs.subscriptions != rhs.subscriptions { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
