// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: streams.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

package struct EventStore_Client_Streams_ReadReq: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var options: EventStore_Client_Streams_ReadReq.Options {
        get { _options ?? EventStore_Client_Streams_ReadReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    package var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    package mutating func clearOptions() { _options = nil }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package struct Options: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var streamOption: EventStore_Client_Streams_ReadReq.Options.OneOf_StreamOption? = nil

        package var stream: EventStore_Client_Streams_ReadReq.Options.StreamOptions {
            get {
                if case let .stream(v)? = streamOption { return v }
                return EventStore_Client_Streams_ReadReq.Options.StreamOptions()
            }
            set { streamOption = .stream(newValue) }
        }

        package var all: EventStore_Client_Streams_ReadReq.Options.AllOptions {
            get {
                if case let .all(v)? = streamOption { return v }
                return EventStore_Client_Streams_ReadReq.Options.AllOptions()
            }
            set { streamOption = .all(newValue) }
        }

        package var readDirection: EventStore_Client_Streams_ReadReq.Options.ReadDirection = .forwards

        package var resolveLinks: Bool = false

        package var countOption: EventStore_Client_Streams_ReadReq.Options.OneOf_CountOption? = nil

        package var count: UInt64 {
            get {
                if case let .count(v)? = countOption { return v }
                return 0
            }
            set { countOption = .count(newValue) }
        }

        package var subscription: EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions {
            get {
                if case let .subscription(v)? = countOption { return v }
                return EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions()
            }
            set { countOption = .subscription(newValue) }
        }

        package var filterOption: EventStore_Client_Streams_ReadReq.Options.OneOf_FilterOption? = nil

        package var filter: EventStore_Client_Streams_ReadReq.Options.FilterOptions {
            get {
                if case let .filter(v)? = filterOption { return v }
                return EventStore_Client_Streams_ReadReq.Options.FilterOptions()
            }
            set { filterOption = .filter(newValue) }
        }

        package var noFilter: EventStore_Client_Empty {
            get {
                if case let .noFilter(v)? = filterOption { return v }
                return EventStore_Client_Empty()
            }
            set { filterOption = .noFilter(newValue) }
        }

        package var uuidOption: EventStore_Client_Streams_ReadReq.Options.UUIDOption {
            get { _uuidOption ?? EventStore_Client_Streams_ReadReq.Options.UUIDOption() }
            set { _uuidOption = newValue }
        }

        /// Returns true if `uuidOption` has been explicitly set.
        package var hasUuidOption: Bool { _uuidOption != nil }
        /// Clears the value of `uuidOption`. Subsequent reads from it will return its default value.
        package mutating func clearUuidOption() { _uuidOption = nil }

        package var controlOption: EventStore_Client_Streams_ReadReq.Options.ControlOption {
            get { _controlOption ?? EventStore_Client_Streams_ReadReq.Options.ControlOption() }
            set { _controlOption = newValue }
        }

        /// Returns true if `controlOption` has been explicitly set.
        package var hasControlOption: Bool { _controlOption != nil }
        /// Clears the value of `controlOption`. Subsequent reads from it will return its default value.
        package mutating func clearControlOption() { _controlOption = nil }

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_StreamOption: Equatable, Sendable {
            case stream(EventStore_Client_Streams_ReadReq.Options.StreamOptions)
            case all(EventStore_Client_Streams_ReadReq.Options.AllOptions)
        }

        package enum OneOf_CountOption: Equatable, Sendable {
            case count(UInt64)
            case subscription(EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions)
        }

        package enum OneOf_FilterOption: Equatable, Sendable {
            case filter(EventStore_Client_Streams_ReadReq.Options.FilterOptions)
            case noFilter(EventStore_Client_Empty)
        }

        package enum ReadDirection: SwiftProtobuf.Enum, Swift.CaseIterable {
            package typealias RawValue = Int
            case forwards // = 0
            case backwards // = 1
            case UNRECOGNIZED(Int)

            package init() {
                self = .forwards
            }

            package init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .forwards
                case 1: self = .backwards
                default: self = .UNRECOGNIZED(rawValue)
                }
            }

            package var rawValue: Int {
                switch self {
                case .forwards: 0
                case .backwards: 1
                case let .UNRECOGNIZED(i): i
                }
            }

            // The compiler won't synthesize support with the UNRECOGNIZED case.
            package static let allCases: [EventStore_Client_Streams_ReadReq.Options.ReadDirection] = [
                .forwards,
                .backwards,
            ]
        }

        package struct StreamOptions: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            package var streamIdentifier: EventStore_Client_StreamIdentifier {
                get { _streamIdentifier ?? EventStore_Client_StreamIdentifier() }
                set { _streamIdentifier = newValue }
            }

            /// Returns true if `streamIdentifier` has been explicitly set.
            package var hasStreamIdentifier: Bool { _streamIdentifier != nil }
            /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
            package mutating func clearStreamIdentifier() { _streamIdentifier = nil }

            package var revisionOption: EventStore_Client_Streams_ReadReq.Options.StreamOptions.OneOf_RevisionOption? = nil

            package var revision: UInt64 {
                get {
                    if case let .revision(v)? = revisionOption { return v }
                    return 0
                }
                set { revisionOption = .revision(newValue) }
            }

            package var start: EventStore_Client_Empty {
                get {
                    if case let .start(v)? = revisionOption { return v }
                    return EventStore_Client_Empty()
                }
                set { revisionOption = .start(newValue) }
            }

            package var end: EventStore_Client_Empty {
                get {
                    if case let .end(v)? = revisionOption { return v }
                    return EventStore_Client_Empty()
                }
                set { revisionOption = .end(newValue) }
            }

            package var unknownFields = SwiftProtobuf.UnknownStorage()

            package enum OneOf_RevisionOption: Equatable, Sendable {
                case revision(UInt64)
                case start(EventStore_Client_Empty)
                case end(EventStore_Client_Empty)
            }

            package init() {}

            fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
        }

        package struct AllOptions: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            package var allOption: EventStore_Client_Streams_ReadReq.Options.AllOptions.OneOf_AllOption? = nil

            package var position: EventStore_Client_Streams_ReadReq.Options.Position {
                get {
                    if case let .position(v)? = allOption { return v }
                    return EventStore_Client_Streams_ReadReq.Options.Position()
                }
                set { allOption = .position(newValue) }
            }

            package var start: EventStore_Client_Empty {
                get {
                    if case let .start(v)? = allOption { return v }
                    return EventStore_Client_Empty()
                }
                set { allOption = .start(newValue) }
            }

            package var end: EventStore_Client_Empty {
                get {
                    if case let .end(v)? = allOption { return v }
                    return EventStore_Client_Empty()
                }
                set { allOption = .end(newValue) }
            }

            package var unknownFields = SwiftProtobuf.UnknownStorage()

            package enum OneOf_AllOption: Equatable, Sendable {
                case position(EventStore_Client_Streams_ReadReq.Options.Position)
                case start(EventStore_Client_Empty)
                case end(EventStore_Client_Empty)
            }

            package init() {}
        }

        package struct SubscriptionOptions: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            package var unknownFields = SwiftProtobuf.UnknownStorage()

            package init() {}
        }

        package struct Position: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            package var commitPosition: UInt64 = 0

            package var preparePosition: UInt64 = 0

            package var unknownFields = SwiftProtobuf.UnknownStorage()

            package init() {}
        }

        package struct FilterOptions: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            package var filter: EventStore_Client_Streams_ReadReq.Options.FilterOptions.OneOf_Filter? = nil

            package var streamIdentifier: EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression {
                get {
                    if case let .streamIdentifier(v)? = filter { return v }
                    return EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression()
                }
                set { filter = .streamIdentifier(newValue) }
            }

            package var eventType: EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression {
                get {
                    if case let .eventType(v)? = filter { return v }
                    return EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression()
                }
                set { filter = .eventType(newValue) }
            }

            package var window: EventStore_Client_Streams_ReadReq.Options.FilterOptions.OneOf_Window? = nil

            package var max: UInt32 {
                get {
                    if case let .max(v)? = window { return v }
                    return 0
                }
                set { window = .max(newValue) }
            }

            package var count: EventStore_Client_Empty {
                get {
                    if case let .count(v)? = window { return v }
                    return EventStore_Client_Empty()
                }
                set { window = .count(newValue) }
            }

            package var checkpointIntervalMultiplier: UInt32 = 0

            package var unknownFields = SwiftProtobuf.UnknownStorage()

            package enum OneOf_Filter: Equatable, Sendable {
                case streamIdentifier(EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression)
                case eventType(EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression)
            }

            package enum OneOf_Window: Equatable, Sendable {
                case max(UInt32)
                case count(EventStore_Client_Empty)
            }

            package struct Expression: Sendable {
                // SwiftProtobuf.Message conformance is added in an extension below. See the
                // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
                // methods supported on all messages.

                package var regex: String = .init()

                package var prefix: [String] = []

                package var unknownFields = SwiftProtobuf.UnknownStorage()

                package init() {}
            }

            package init() {}
        }

        package struct UUIDOption: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            package var content: EventStore_Client_Streams_ReadReq.Options.UUIDOption.OneOf_Content? = nil

            package var structured: EventStore_Client_Empty {
                get {
                    if case let .structured(v)? = content { return v }
                    return EventStore_Client_Empty()
                }
                set { content = .structured(newValue) }
            }

            package var string: EventStore_Client_Empty {
                get {
                    if case let .string(v)? = content { return v }
                    return EventStore_Client_Empty()
                }
                set { content = .string(newValue) }
            }

            package var unknownFields = SwiftProtobuf.UnknownStorage()

            package enum OneOf_Content: Equatable, Sendable {
                case structured(EventStore_Client_Empty)
                case string(EventStore_Client_Empty)
            }

            package init() {}
        }

        package struct ControlOption: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            package var compatibility: UInt32 = 0

            package var unknownFields = SwiftProtobuf.UnknownStorage()

            package init() {}
        }

        package init() {}

        fileprivate var _uuidOption: EventStore_Client_Streams_ReadReq.Options.UUIDOption? = nil
        fileprivate var _controlOption: EventStore_Client_Streams_ReadReq.Options.ControlOption? = nil
    }

    package init() {}

    fileprivate var _options: EventStore_Client_Streams_ReadReq.Options? = nil
}

package struct EventStore_Client_Streams_ReadResp: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var content: EventStore_Client_Streams_ReadResp.OneOf_Content? = nil

    package var event: EventStore_Client_Streams_ReadResp.ReadEvent {
        get {
            if case let .event(v)? = content { return v }
            return EventStore_Client_Streams_ReadResp.ReadEvent()
        }
        set { content = .event(newValue) }
    }

    package var confirmation: EventStore_Client_Streams_ReadResp.SubscriptionConfirmation {
        get {
            if case let .confirmation(v)? = content { return v }
            return EventStore_Client_Streams_ReadResp.SubscriptionConfirmation()
        }
        set { content = .confirmation(newValue) }
    }

    package var checkpoint: EventStore_Client_Streams_ReadResp.Checkpoint {
        get {
            if case let .checkpoint(v)? = content { return v }
            return EventStore_Client_Streams_ReadResp.Checkpoint()
        }
        set { content = .checkpoint(newValue) }
    }

    package var streamNotFound: EventStore_Client_Streams_ReadResp.StreamNotFound {
        get {
            if case let .streamNotFound(v)? = content { return v }
            return EventStore_Client_Streams_ReadResp.StreamNotFound()
        }
        set { content = .streamNotFound(newValue) }
    }

    package var firstStreamPosition: UInt64 {
        get {
            if case let .firstStreamPosition(v)? = content { return v }
            return 0
        }
        set { content = .firstStreamPosition(newValue) }
    }

    package var lastStreamPosition: UInt64 {
        get {
            if case let .lastStreamPosition(v)? = content { return v }
            return 0
        }
        set { content = .lastStreamPosition(newValue) }
    }

    package var lastAllStreamPosition: EventStore_Client_AllStreamPosition {
        get {
            if case let .lastAllStreamPosition(v)? = content { return v }
            return EventStore_Client_AllStreamPosition()
        }
        set { content = .lastAllStreamPosition(newValue) }
    }

    package var caughtUp: EventStore_Client_Streams_ReadResp.CaughtUp {
        get {
            if case let .caughtUp(v)? = content { return v }
            return EventStore_Client_Streams_ReadResp.CaughtUp()
        }
        set { content = .caughtUp(newValue) }
    }

    package var fellBehind: EventStore_Client_Streams_ReadResp.FellBehind {
        get {
            if case let .fellBehind(v)? = content { return v }
            return EventStore_Client_Streams_ReadResp.FellBehind()
        }
        set { content = .fellBehind(newValue) }
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_Content: Equatable, Sendable {
        case event(EventStore_Client_Streams_ReadResp.ReadEvent)
        case confirmation(EventStore_Client_Streams_ReadResp.SubscriptionConfirmation)
        case checkpoint(EventStore_Client_Streams_ReadResp.Checkpoint)
        case streamNotFound(EventStore_Client_Streams_ReadResp.StreamNotFound)
        case firstStreamPosition(UInt64)
        case lastStreamPosition(UInt64)
        case lastAllStreamPosition(EventStore_Client_AllStreamPosition)
        case caughtUp(EventStore_Client_Streams_ReadResp.CaughtUp)
        case fellBehind(EventStore_Client_Streams_ReadResp.FellBehind)
    }

    package struct CaughtUp: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package init() {}
    }

    package struct FellBehind: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package init() {}
    }

    package struct ReadEvent: @unchecked Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var event: EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent {
            get { _storage._event ?? EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent() }
            set { _uniqueStorage()._event = newValue }
        }

        /// Returns true if `event` has been explicitly set.
        package var hasEvent: Bool { _storage._event != nil }
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        package mutating func clearEvent() { _uniqueStorage()._event = nil }

        package var link: EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent {
            get { _storage._link ?? EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent() }
            set { _uniqueStorage()._link = newValue }
        }

        /// Returns true if `link` has been explicitly set.
        package var hasLink: Bool { _storage._link != nil }
        /// Clears the value of `link`. Subsequent reads from it will return its default value.
        package mutating func clearLink() { _uniqueStorage()._link = nil }

        package var position: OneOf_Position? {
            get { _storage._position }
            set { _uniqueStorage()._position = newValue }
        }

        package var commitPosition: UInt64 {
            get {
                if case let .commitPosition(v)? = _storage._position { return v }
                return 0
            }
            set { _uniqueStorage()._position = .commitPosition(newValue) }
        }

        package var noPosition: EventStore_Client_Empty {
            get {
                if case let .noPosition(v)? = _storage._position { return v }
                return EventStore_Client_Empty()
            }
            set { _uniqueStorage()._position = .noPosition(newValue) }
        }

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_Position: Equatable, Sendable {
            case commitPosition(UInt64)
            case noPosition(EventStore_Client_Empty)
        }

        package struct RecordedEvent: @unchecked Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            package var id: EventStore_Client_UUID {
                get { _id ?? EventStore_Client_UUID() }
                set { _id = newValue }
            }

            /// Returns true if `id` has been explicitly set.
            package var hasID: Bool { _id != nil }
            /// Clears the value of `id`. Subsequent reads from it will return its default value.
            package mutating func clearID() { _id = nil }

            package var streamIdentifier: EventStore_Client_StreamIdentifier {
                get { _streamIdentifier ?? EventStore_Client_StreamIdentifier() }
                set { _streamIdentifier = newValue }
            }

            /// Returns true if `streamIdentifier` has been explicitly set.
            package var hasStreamIdentifier: Bool { _streamIdentifier != nil }
            /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
            package mutating func clearStreamIdentifier() { _streamIdentifier = nil }

            package var streamRevision: UInt64 = 0

            package var preparePosition: UInt64 = 0

            package var commitPosition: UInt64 = 0

            package var metadata: [String: String] = [:]

            package var customMetadata: Data = .init()

            package var data: Data = .init()

            package var unknownFields = SwiftProtobuf.UnknownStorage()

            package init() {}

            fileprivate var _id: EventStore_Client_UUID? = nil
            fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
        }

        package init() {}

        fileprivate var _storage = _StorageClass.defaultInstance
    }

    package struct SubscriptionConfirmation: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var subscriptionID: String = .init()

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package init() {}
    }

    package struct Checkpoint: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var commitPosition: UInt64 = 0

        package var preparePosition: UInt64 = 0

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package init() {}
    }

    package struct StreamNotFound: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var streamIdentifier: EventStore_Client_StreamIdentifier {
            get { _streamIdentifier ?? EventStore_Client_StreamIdentifier() }
            set { _streamIdentifier = newValue }
        }

        /// Returns true if `streamIdentifier` has been explicitly set.
        package var hasStreamIdentifier: Bool { _streamIdentifier != nil }
        /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
        package mutating func clearStreamIdentifier() { _streamIdentifier = nil }

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package init() {}

        fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
    }

    package init() {}
}

package struct EventStore_Client_Streams_AppendReq: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var content: EventStore_Client_Streams_AppendReq.OneOf_Content? = nil

    package var options: EventStore_Client_Streams_AppendReq.Options {
        get {
            if case let .options(v)? = content { return v }
            return EventStore_Client_Streams_AppendReq.Options()
        }
        set { content = .options(newValue) }
    }

    package var proposedMessage: EventStore_Client_Streams_AppendReq.ProposedMessage {
        get {
            if case let .proposedMessage(v)? = content { return v }
            return EventStore_Client_Streams_AppendReq.ProposedMessage()
        }
        set { content = .proposedMessage(newValue) }
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_Content: Equatable, Sendable {
        case options(EventStore_Client_Streams_AppendReq.Options)
        case proposedMessage(EventStore_Client_Streams_AppendReq.ProposedMessage)
    }

    package struct Options: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var streamIdentifier: EventStore_Client_StreamIdentifier {
            get { _streamIdentifier ?? EventStore_Client_StreamIdentifier() }
            set { _streamIdentifier = newValue }
        }

        /// Returns true if `streamIdentifier` has been explicitly set.
        package var hasStreamIdentifier: Bool { _streamIdentifier != nil }
        /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
        package mutating func clearStreamIdentifier() { _streamIdentifier = nil }

        package var expectedStreamRevision: EventStore_Client_Streams_AppendReq.Options.OneOf_ExpectedStreamRevision? = nil

        package var revision: UInt64 {
            get {
                if case let .revision(v)? = expectedStreamRevision { return v }
                return 0
            }
            set { expectedStreamRevision = .revision(newValue) }
        }

        package var noStream: EventStore_Client_Empty {
            get {
                if case let .noStream(v)? = expectedStreamRevision { return v }
                return EventStore_Client_Empty()
            }
            set { expectedStreamRevision = .noStream(newValue) }
        }

        package var any: EventStore_Client_Empty {
            get {
                if case let .any(v)? = expectedStreamRevision { return v }
                return EventStore_Client_Empty()
            }
            set { expectedStreamRevision = .any(newValue) }
        }

        package var streamExists: EventStore_Client_Empty {
            get {
                if case let .streamExists(v)? = expectedStreamRevision { return v }
                return EventStore_Client_Empty()
            }
            set { expectedStreamRevision = .streamExists(newValue) }
        }

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_ExpectedStreamRevision: Equatable, Sendable {
            case revision(UInt64)
            case noStream(EventStore_Client_Empty)
            case any(EventStore_Client_Empty)
            case streamExists(EventStore_Client_Empty)
        }

        package init() {}

        fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
    }

    package struct ProposedMessage: @unchecked Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var id: EventStore_Client_UUID {
            get { _id ?? EventStore_Client_UUID() }
            set { _id = newValue }
        }

        /// Returns true if `id` has been explicitly set.
        package var hasID: Bool { _id != nil }
        /// Clears the value of `id`. Subsequent reads from it will return its default value.
        package mutating func clearID() { _id = nil }

        package var metadata: [String: String] = [:]

        package var customMetadata: Data = .init()

        package var data: Data = .init()

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package init() {}

        fileprivate var _id: EventStore_Client_UUID? = nil
    }

    package init() {}
}

package struct EventStore_Client_Streams_AppendResp: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var result: EventStore_Client_Streams_AppendResp.OneOf_Result? = nil

    package var success: EventStore_Client_Streams_AppendResp.Success {
        get {
            if case let .success(v)? = result { return v }
            return EventStore_Client_Streams_AppendResp.Success()
        }
        set { result = .success(newValue) }
    }

    package var wrongExpectedVersion: EventStore_Client_Streams_AppendResp.WrongExpectedVersion {
        get {
            if case let .wrongExpectedVersion(v)? = result { return v }
            return EventStore_Client_Streams_AppendResp.WrongExpectedVersion()
        }
        set { result = .wrongExpectedVersion(newValue) }
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_Result: Equatable, Sendable {
        case success(EventStore_Client_Streams_AppendResp.Success)
        case wrongExpectedVersion(EventStore_Client_Streams_AppendResp.WrongExpectedVersion)
    }

    package struct Position: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var commitPosition: UInt64 = 0

        package var preparePosition: UInt64 = 0

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package init() {}
    }

    package struct Success: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var currentRevisionOption: EventStore_Client_Streams_AppendResp.Success.OneOf_CurrentRevisionOption? = nil

        package var currentRevision: UInt64 {
            get {
                if case let .currentRevision(v)? = currentRevisionOption { return v }
                return 0
            }
            set { currentRevisionOption = .currentRevision(newValue) }
        }

        package var noStream: EventStore_Client_Empty {
            get {
                if case let .noStream(v)? = currentRevisionOption { return v }
                return EventStore_Client_Empty()
            }
            set { currentRevisionOption = .noStream(newValue) }
        }

        package var positionOption: EventStore_Client_Streams_AppendResp.Success.OneOf_PositionOption? = nil

        package var position: EventStore_Client_Streams_AppendResp.Position {
            get {
                if case let .position(v)? = positionOption { return v }
                return EventStore_Client_Streams_AppendResp.Position()
            }
            set { positionOption = .position(newValue) }
        }

        package var noPosition: EventStore_Client_Empty {
            get {
                if case let .noPosition(v)? = positionOption { return v }
                return EventStore_Client_Empty()
            }
            set { positionOption = .noPosition(newValue) }
        }

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_CurrentRevisionOption: Equatable, Sendable {
            case currentRevision(UInt64)
            case noStream(EventStore_Client_Empty)
        }

        package enum OneOf_PositionOption: Equatable, Sendable {
            case position(EventStore_Client_Streams_AppendResp.Position)
            case noPosition(EventStore_Client_Empty)
        }

        package init() {}
    }

    package struct WrongExpectedVersion: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var currentRevisionOption2060: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_CurrentRevisionOption2060? = nil

        package var currentRevision2060: UInt64 {
            get {
                if case let .currentRevision2060(v)? = currentRevisionOption2060 { return v }
                return 0
            }
            set { currentRevisionOption2060 = .currentRevision2060(newValue) }
        }

        package var noStream2060: EventStore_Client_Empty {
            get {
                if case let .noStream2060(v)? = currentRevisionOption2060 { return v }
                return EventStore_Client_Empty()
            }
            set { currentRevisionOption2060 = .noStream2060(newValue) }
        }

        package var expectedRevisionOption2060: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_ExpectedRevisionOption2060? = nil

        package var expectedRevision2060: UInt64 {
            get {
                if case let .expectedRevision2060(v)? = expectedRevisionOption2060 { return v }
                return 0
            }
            set { expectedRevisionOption2060 = .expectedRevision2060(newValue) }
        }

        package var any2060: EventStore_Client_Empty {
            get {
                if case let .any2060(v)? = expectedRevisionOption2060 { return v }
                return EventStore_Client_Empty()
            }
            set { expectedRevisionOption2060 = .any2060(newValue) }
        }

        package var streamExists2060: EventStore_Client_Empty {
            get {
                if case let .streamExists2060(v)? = expectedRevisionOption2060 { return v }
                return EventStore_Client_Empty()
            }
            set { expectedRevisionOption2060 = .streamExists2060(newValue) }
        }

        package var currentRevisionOption: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_CurrentRevisionOption? = nil

        package var currentRevision: UInt64 {
            get {
                if case let .currentRevision(v)? = currentRevisionOption { return v }
                return 0
            }
            set { currentRevisionOption = .currentRevision(newValue) }
        }

        package var currentNoStream: EventStore_Client_Empty {
            get {
                if case let .currentNoStream(v)? = currentRevisionOption { return v }
                return EventStore_Client_Empty()
            }
            set { currentRevisionOption = .currentNoStream(newValue) }
        }

        package var expectedRevisionOption: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_ExpectedRevisionOption? = nil

        package var expectedRevision: UInt64 {
            get {
                if case let .expectedRevision(v)? = expectedRevisionOption { return v }
                return 0
            }
            set { expectedRevisionOption = .expectedRevision(newValue) }
        }

        package var expectedAny: EventStore_Client_Empty {
            get {
                if case let .expectedAny(v)? = expectedRevisionOption { return v }
                return EventStore_Client_Empty()
            }
            set { expectedRevisionOption = .expectedAny(newValue) }
        }

        package var expectedStreamExists: EventStore_Client_Empty {
            get {
                if case let .expectedStreamExists(v)? = expectedRevisionOption { return v }
                return EventStore_Client_Empty()
            }
            set { expectedRevisionOption = .expectedStreamExists(newValue) }
        }

        package var expectedNoStream: EventStore_Client_Empty {
            get {
                if case let .expectedNoStream(v)? = expectedRevisionOption { return v }
                return EventStore_Client_Empty()
            }
            set { expectedRevisionOption = .expectedNoStream(newValue) }
        }

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_CurrentRevisionOption2060: Equatable, Sendable {
            case currentRevision2060(UInt64)
            case noStream2060(EventStore_Client_Empty)
        }

        package enum OneOf_ExpectedRevisionOption2060: Equatable, Sendable {
            case expectedRevision2060(UInt64)
            case any2060(EventStore_Client_Empty)
            case streamExists2060(EventStore_Client_Empty)
        }

        package enum OneOf_CurrentRevisionOption: Equatable, Sendable {
            case currentRevision(UInt64)
            case currentNoStream(EventStore_Client_Empty)
        }

        package enum OneOf_ExpectedRevisionOption: Equatable, Sendable {
            case expectedRevision(UInt64)
            case expectedAny(EventStore_Client_Empty)
            case expectedStreamExists(EventStore_Client_Empty)
            case expectedNoStream(EventStore_Client_Empty)
        }

        package init() {}
    }

    package init() {}
}

package struct EventStore_Client_Streams_BatchAppendReq: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var correlationID: EventStore_Client_UUID {
        get { _correlationID ?? EventStore_Client_UUID() }
        set { _correlationID = newValue }
    }

    /// Returns true if `correlationID` has been explicitly set.
    package var hasCorrelationID: Bool { _correlationID != nil }
    /// Clears the value of `correlationID`. Subsequent reads from it will return its default value.
    package mutating func clearCorrelationID() { _correlationID = nil }

    package var options: EventStore_Client_Streams_BatchAppendReq.Options {
        get { _options ?? EventStore_Client_Streams_BatchAppendReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    package var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    package mutating func clearOptions() { _options = nil }

    package var proposedMessages: [EventStore_Client_Streams_BatchAppendReq.ProposedMessage] = []

    package var isFinal: Bool = false

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package struct Options: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var streamIdentifier: EventStore_Client_StreamIdentifier {
            get { _streamIdentifier ?? EventStore_Client_StreamIdentifier() }
            set { _streamIdentifier = newValue }
        }

        /// Returns true if `streamIdentifier` has been explicitly set.
        package var hasStreamIdentifier: Bool { _streamIdentifier != nil }
        /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
        package mutating func clearStreamIdentifier() { _streamIdentifier = nil }

        package var expectedStreamPosition: EventStore_Client_Streams_BatchAppendReq.Options.OneOf_ExpectedStreamPosition? = nil

        package var streamPosition: UInt64 {
            get {
                if case let .streamPosition(v)? = expectedStreamPosition { return v }
                return 0
            }
            set { expectedStreamPosition = .streamPosition(newValue) }
        }

        package var noStream: SwiftProtobuf.Google_Protobuf_Empty {
            get {
                if case let .noStream(v)? = expectedStreamPosition { return v }
                return SwiftProtobuf.Google_Protobuf_Empty()
            }
            set { expectedStreamPosition = .noStream(newValue) }
        }

        package var any: SwiftProtobuf.Google_Protobuf_Empty {
            get {
                if case let .any(v)? = expectedStreamPosition { return v }
                return SwiftProtobuf.Google_Protobuf_Empty()
            }
            set { expectedStreamPosition = .any(newValue) }
        }

        package var streamExists: SwiftProtobuf.Google_Protobuf_Empty {
            get {
                if case let .streamExists(v)? = expectedStreamPosition { return v }
                return SwiftProtobuf.Google_Protobuf_Empty()
            }
            set { expectedStreamPosition = .streamExists(newValue) }
        }

        package var deadlineOption: EventStore_Client_Streams_BatchAppendReq.Options.OneOf_DeadlineOption? = nil

        package var deadline21100: SwiftProtobuf.Google_Protobuf_Timestamp {
            get {
                if case let .deadline21100(v)? = deadlineOption { return v }
                return SwiftProtobuf.Google_Protobuf_Timestamp()
            }
            set { deadlineOption = .deadline21100(newValue) }
        }

        package var deadline: SwiftProtobuf.Google_Protobuf_Duration {
            get {
                if case let .deadline(v)? = deadlineOption { return v }
                return SwiftProtobuf.Google_Protobuf_Duration()
            }
            set { deadlineOption = .deadline(newValue) }
        }

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_ExpectedStreamPosition: Equatable, Sendable {
            case streamPosition(UInt64)
            case noStream(SwiftProtobuf.Google_Protobuf_Empty)
            case any(SwiftProtobuf.Google_Protobuf_Empty)
            case streamExists(SwiftProtobuf.Google_Protobuf_Empty)
        }

        package enum OneOf_DeadlineOption: Equatable, Sendable {
            case deadline21100(SwiftProtobuf.Google_Protobuf_Timestamp)
            case deadline(SwiftProtobuf.Google_Protobuf_Duration)
        }

        package init() {}

        fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
    }

    package struct ProposedMessage: @unchecked Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var id: EventStore_Client_UUID {
            get { _id ?? EventStore_Client_UUID() }
            set { _id = newValue }
        }

        /// Returns true if `id` has been explicitly set.
        package var hasID: Bool { _id != nil }
        /// Clears the value of `id`. Subsequent reads from it will return its default value.
        package mutating func clearID() { _id = nil }

        package var metadata: [String: String] = [:]

        package var customMetadata: Data = .init()

        package var data: Data = .init()

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package init() {}

        fileprivate var _id: EventStore_Client_UUID? = nil
    }

    package init() {}

    fileprivate var _correlationID: EventStore_Client_UUID? = nil
    fileprivate var _options: EventStore_Client_Streams_BatchAppendReq.Options? = nil
}

package struct EventStore_Client_Streams_BatchAppendResp: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var correlationID: EventStore_Client_UUID {
        get { _correlationID ?? EventStore_Client_UUID() }
        set { _correlationID = newValue }
    }

    /// Returns true if `correlationID` has been explicitly set.
    package var hasCorrelationID: Bool { _correlationID != nil }
    /// Clears the value of `correlationID`. Subsequent reads from it will return its default value.
    package mutating func clearCorrelationID() { _correlationID = nil }

    package var result: EventStore_Client_Streams_BatchAppendResp.OneOf_Result? = nil

    package var error: Google_Rpc_Status {
        get {
            if case let .error(v)? = result { return v }
            return Google_Rpc_Status()
        }
        set { result = .error(newValue) }
    }

    package var success: EventStore_Client_Streams_BatchAppendResp.Success {
        get {
            if case let .success(v)? = result { return v }
            return EventStore_Client_Streams_BatchAppendResp.Success()
        }
        set { result = .success(newValue) }
    }

    package var streamIdentifier: EventStore_Client_StreamIdentifier {
        get { _streamIdentifier ?? EventStore_Client_StreamIdentifier() }
        set { _streamIdentifier = newValue }
    }

    /// Returns true if `streamIdentifier` has been explicitly set.
    package var hasStreamIdentifier: Bool { _streamIdentifier != nil }
    /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
    package mutating func clearStreamIdentifier() { _streamIdentifier = nil }

    package var expectedStreamPosition: EventStore_Client_Streams_BatchAppendResp.OneOf_ExpectedStreamPosition? = nil

    package var streamPosition: UInt64 {
        get {
            if case let .streamPosition(v)? = expectedStreamPosition { return v }
            return 0
        }
        set { expectedStreamPosition = .streamPosition(newValue) }
    }

    package var noStream: SwiftProtobuf.Google_Protobuf_Empty {
        get {
            if case let .noStream(v)? = expectedStreamPosition { return v }
            return SwiftProtobuf.Google_Protobuf_Empty()
        }
        set { expectedStreamPosition = .noStream(newValue) }
    }

    package var any: SwiftProtobuf.Google_Protobuf_Empty {
        get {
            if case let .any(v)? = expectedStreamPosition { return v }
            return SwiftProtobuf.Google_Protobuf_Empty()
        }
        set { expectedStreamPosition = .any(newValue) }
    }

    package var streamExists: SwiftProtobuf.Google_Protobuf_Empty {
        get {
            if case let .streamExists(v)? = expectedStreamPosition { return v }
            return SwiftProtobuf.Google_Protobuf_Empty()
        }
        set { expectedStreamPosition = .streamExists(newValue) }
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_Result: Equatable, Sendable {
        case error(Google_Rpc_Status)
        case success(EventStore_Client_Streams_BatchAppendResp.Success)
    }

    package enum OneOf_ExpectedStreamPosition: Equatable, Sendable {
        case streamPosition(UInt64)
        case noStream(SwiftProtobuf.Google_Protobuf_Empty)
        case any(SwiftProtobuf.Google_Protobuf_Empty)
        case streamExists(SwiftProtobuf.Google_Protobuf_Empty)
    }

    package struct Success: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var currentRevisionOption: EventStore_Client_Streams_BatchAppendResp.Success.OneOf_CurrentRevisionOption? = nil

        package var currentRevision: UInt64 {
            get {
                if case let .currentRevision(v)? = currentRevisionOption { return v }
                return 0
            }
            set { currentRevisionOption = .currentRevision(newValue) }
        }

        package var noStream: SwiftProtobuf.Google_Protobuf_Empty {
            get {
                if case let .noStream(v)? = currentRevisionOption { return v }
                return SwiftProtobuf.Google_Protobuf_Empty()
            }
            set { currentRevisionOption = .noStream(newValue) }
        }

        package var positionOption: EventStore_Client_Streams_BatchAppendResp.Success.OneOf_PositionOption? = nil

        package var position: EventStore_Client_AllStreamPosition {
            get {
                if case let .position(v)? = positionOption { return v }
                return EventStore_Client_AllStreamPosition()
            }
            set { positionOption = .position(newValue) }
        }

        package var noPosition: SwiftProtobuf.Google_Protobuf_Empty {
            get {
                if case let .noPosition(v)? = positionOption { return v }
                return SwiftProtobuf.Google_Protobuf_Empty()
            }
            set { positionOption = .noPosition(newValue) }
        }

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_CurrentRevisionOption: Equatable, Sendable {
            case currentRevision(UInt64)
            case noStream(SwiftProtobuf.Google_Protobuf_Empty)
        }

        package enum OneOf_PositionOption: Equatable, Sendable {
            case position(EventStore_Client_AllStreamPosition)
            case noPosition(SwiftProtobuf.Google_Protobuf_Empty)
        }

        package init() {}
    }

    package init() {}

    fileprivate var _correlationID: EventStore_Client_UUID? = nil
    fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
}

package struct EventStore_Client_Streams_DeleteReq: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var options: EventStore_Client_Streams_DeleteReq.Options {
        get { _options ?? EventStore_Client_Streams_DeleteReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    package var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    package mutating func clearOptions() { _options = nil }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package struct Options: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var streamIdentifier: EventStore_Client_StreamIdentifier {
            get { _streamIdentifier ?? EventStore_Client_StreamIdentifier() }
            set { _streamIdentifier = newValue }
        }

        /// Returns true if `streamIdentifier` has been explicitly set.
        package var hasStreamIdentifier: Bool { _streamIdentifier != nil }
        /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
        package mutating func clearStreamIdentifier() { _streamIdentifier = nil }

        package var expectedStreamRevision: EventStore_Client_Streams_DeleteReq.Options.OneOf_ExpectedStreamRevision? = nil

        package var revision: UInt64 {
            get {
                if case let .revision(v)? = expectedStreamRevision { return v }
                return 0
            }
            set { expectedStreamRevision = .revision(newValue) }
        }

        package var noStream: EventStore_Client_Empty {
            get {
                if case let .noStream(v)? = expectedStreamRevision { return v }
                return EventStore_Client_Empty()
            }
            set { expectedStreamRevision = .noStream(newValue) }
        }

        package var any: EventStore_Client_Empty {
            get {
                if case let .any(v)? = expectedStreamRevision { return v }
                return EventStore_Client_Empty()
            }
            set { expectedStreamRevision = .any(newValue) }
        }

        package var streamExists: EventStore_Client_Empty {
            get {
                if case let .streamExists(v)? = expectedStreamRevision { return v }
                return EventStore_Client_Empty()
            }
            set { expectedStreamRevision = .streamExists(newValue) }
        }

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_ExpectedStreamRevision: Equatable, Sendable {
            case revision(UInt64)
            case noStream(EventStore_Client_Empty)
            case any(EventStore_Client_Empty)
            case streamExists(EventStore_Client_Empty)
        }

        package init() {}

        fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
    }

    package init() {}

    fileprivate var _options: EventStore_Client_Streams_DeleteReq.Options? = nil
}

package struct EventStore_Client_Streams_DeleteResp: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var positionOption: EventStore_Client_Streams_DeleteResp.OneOf_PositionOption? = nil

    package var position: EventStore_Client_Streams_DeleteResp.Position {
        get {
            if case let .position(v)? = positionOption { return v }
            return EventStore_Client_Streams_DeleteResp.Position()
        }
        set { positionOption = .position(newValue) }
    }

    package var noPosition: EventStore_Client_Empty {
        get {
            if case let .noPosition(v)? = positionOption { return v }
            return EventStore_Client_Empty()
        }
        set { positionOption = .noPosition(newValue) }
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_PositionOption: Equatable, Sendable {
        case position(EventStore_Client_Streams_DeleteResp.Position)
        case noPosition(EventStore_Client_Empty)
    }

    package struct Position: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var commitPosition: UInt64 = 0

        package var preparePosition: UInt64 = 0

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package init() {}
    }

    package init() {}
}

package struct EventStore_Client_Streams_TombstoneReq: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var options: EventStore_Client_Streams_TombstoneReq.Options {
        get { _options ?? EventStore_Client_Streams_TombstoneReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    package var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    package mutating func clearOptions() { _options = nil }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package struct Options: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var streamIdentifier: EventStore_Client_StreamIdentifier {
            get { _streamIdentifier ?? EventStore_Client_StreamIdentifier() }
            set { _streamIdentifier = newValue }
        }

        /// Returns true if `streamIdentifier` has been explicitly set.
        package var hasStreamIdentifier: Bool { _streamIdentifier != nil }
        /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
        package mutating func clearStreamIdentifier() { _streamIdentifier = nil }

        package var expectedStreamRevision: EventStore_Client_Streams_TombstoneReq.Options.OneOf_ExpectedStreamRevision? = nil

        package var revision: UInt64 {
            get {
                if case let .revision(v)? = expectedStreamRevision { return v }
                return 0
            }
            set { expectedStreamRevision = .revision(newValue) }
        }

        package var noStream: EventStore_Client_Empty {
            get {
                if case let .noStream(v)? = expectedStreamRevision { return v }
                return EventStore_Client_Empty()
            }
            set { expectedStreamRevision = .noStream(newValue) }
        }

        package var any: EventStore_Client_Empty {
            get {
                if case let .any(v)? = expectedStreamRevision { return v }
                return EventStore_Client_Empty()
            }
            set { expectedStreamRevision = .any(newValue) }
        }

        package var streamExists: EventStore_Client_Empty {
            get {
                if case let .streamExists(v)? = expectedStreamRevision { return v }
                return EventStore_Client_Empty()
            }
            set { expectedStreamRevision = .streamExists(newValue) }
        }

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package enum OneOf_ExpectedStreamRevision: Equatable, Sendable {
            case revision(UInt64)
            case noStream(EventStore_Client_Empty)
            case any(EventStore_Client_Empty)
            case streamExists(EventStore_Client_Empty)
        }

        package init() {}

        fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
    }

    package init() {}

    fileprivate var _options: EventStore_Client_Streams_TombstoneReq.Options? = nil
}

package struct EventStore_Client_Streams_TombstoneResp: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var positionOption: EventStore_Client_Streams_TombstoneResp.OneOf_PositionOption? = nil

    package var position: EventStore_Client_Streams_TombstoneResp.Position {
        get {
            if case let .position(v)? = positionOption { return v }
            return EventStore_Client_Streams_TombstoneResp.Position()
        }
        set { positionOption = .position(newValue) }
    }

    package var noPosition: EventStore_Client_Empty {
        get {
            if case let .noPosition(v)? = positionOption { return v }
            return EventStore_Client_Empty()
        }
        set { positionOption = .noPosition(newValue) }
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_PositionOption: Equatable, Sendable {
        case position(EventStore_Client_Streams_TombstoneResp.Position)
        case noPosition(EventStore_Client_Empty)
    }

    package struct Position: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        package var commitPosition: UInt64 = 0

        package var preparePosition: UInt64 = 0

        package var unknownFields = SwiftProtobuf.UnknownStorage()

        package init() {}
    }

    package init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "event_store.client.streams"

extension EventStore_Client_Streams_ReadReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".ReadReq"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_ReadReq, rhs: EventStore_Client_Streams_ReadReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_ReadReq.protoMessageName + ".Options"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "stream"),
        2: .same(proto: "all"),
        3: .standard(proto: "read_direction"),
        4: .standard(proto: "resolve_links"),
        5: .same(proto: "count"),
        6: .same(proto: "subscription"),
        7: .same(proto: "filter"),
        8: .standard(proto: "no_filter"),
        9: .standard(proto: "uuid_option"),
        10: .standard(proto: "control_option"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_Streams_ReadReq.Options.StreamOptions?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .stream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .stream(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Streams_ReadReq.Options.AllOptions?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .all(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .all(v)
                    }
                }()
            case 3: try decoder.decodeSingularEnumField(value: &readDirection)
            case 4: try decoder.decodeSingularBoolField(value: &resolveLinks)
            case 5: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.countOption != nil { try decoder.handleConflictingOneOf() }
                        self.countOption = .count(v)
                    }
                }()
            case 6: try {
                    var v: EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions?
                    var hadOneofValue = false
                    if let current = self.countOption {
                        hadOneofValue = true
                        if case let .subscription(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.countOption = .subscription(v)
                    }
                }()
            case 7: try {
                    var v: EventStore_Client_Streams_ReadReq.Options.FilterOptions?
                    var hadOneofValue = false
                    if let current = self.filterOption {
                        hadOneofValue = true
                        if case let .filter(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.filterOption = .filter(v)
                    }
                }()
            case 8: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.filterOption {
                        hadOneofValue = true
                        if case let .noFilter(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.filterOption = .noFilter(v)
                    }
                }()
            case 9: try decoder.decodeSingularMessageField(value: &_uuidOption)
            case 10: try decoder.decodeSingularMessageField(value: &_controlOption)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch streamOption {
        case .stream?: try {
                guard case let .stream(v)? = self.streamOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .all?: try {
                guard case let .all(v)? = self.streamOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        if readDirection != .forwards {
            try visitor.visitSingularEnumField(value: readDirection, fieldNumber: 3)
        }
        if resolveLinks != false {
            try visitor.visitSingularBoolField(value: resolveLinks, fieldNumber: 4)
        }
        switch countOption {
        case .count?: try {
                guard case let .count(v)? = self.countOption else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
            }()
        case .subscription?: try {
                guard case let .subscription(v)? = self.countOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
            }()
        case nil: break
        }
        switch filterOption {
        case .filter?: try {
                guard case let .filter(v)? = self.filterOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
            }()
        case .noFilter?: try {
                guard case let .noFilter(v)? = self.filterOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
            }()
        case nil: break
        }
        try { if let v = self._uuidOption {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
        } }()
        try { if let v = self._controlOption {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_ReadReq.Options, rhs: EventStore_Client_Streams_ReadReq.Options) -> Bool {
        if lhs.streamOption != rhs.streamOption { return false }
        if lhs.readDirection != rhs.readDirection { return false }
        if lhs.resolveLinks != rhs.resolveLinks { return false }
        if lhs.countOption != rhs.countOption { return false }
        if lhs.filterOption != rhs.filterOption { return false }
        if lhs._uuidOption != rhs._uuidOption { return false }
        if lhs._controlOption != rhs._controlOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadReq.Options.ReadDirection: SwiftProtobuf._ProtoNameProviding {
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Forwards"),
        1: .same(proto: "Backwards"),
    ]
}

extension EventStore_Client_Streams_ReadReq.Options.StreamOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.protoMessageName + ".StreamOptions"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        2: .same(proto: "revision"),
        3: .same(proto: "start"),
        4: .same(proto: "end"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_streamIdentifier)
            case 2: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.revisionOption != nil { try decoder.handleConflictingOneOf() }
                        self.revisionOption = .revision(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.revisionOption {
                        hadOneofValue = true
                        if case let .start(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.revisionOption = .start(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.revisionOption {
                        hadOneofValue = true
                        if case let .end(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.revisionOption = .end(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _streamIdentifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        switch revisionOption {
        case .revision?: try {
                guard case let .revision(v)? = self.revisionOption else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
            }()
        case .start?: try {
                guard case let .start(v)? = self.revisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .end?: try {
                guard case let .end(v)? = self.revisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_ReadReq.Options.StreamOptions, rhs: EventStore_Client_Streams_ReadReq.Options.StreamOptions) -> Bool {
        if lhs._streamIdentifier != rhs._streamIdentifier { return false }
        if lhs.revisionOption != rhs.revisionOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadReq.Options.AllOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.protoMessageName + ".AllOptions"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "position"),
        2: .same(proto: "start"),
        3: .same(proto: "end"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_Streams_ReadReq.Options.Position?
                    var hadOneofValue = false
                    if let current = self.allOption {
                        hadOneofValue = true
                        if case let .position(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.allOption = .position(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.allOption {
                        hadOneofValue = true
                        if case let .start(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.allOption = .start(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.allOption {
                        hadOneofValue = true
                        if case let .end(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.allOption = .end(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch allOption {
        case .position?: try {
                guard case let .position(v)? = self.allOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .start?: try {
                guard case let .start(v)? = self.allOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .end?: try {
                guard case let .end(v)? = self.allOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_ReadReq.Options.AllOptions, rhs: EventStore_Client_Streams_ReadReq.Options.AllOptions) -> Bool {
        if lhs.allOption != rhs.allOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.protoMessageName + ".SubscriptionOptions"
    package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions, rhs: EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadReq.Options.Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.protoMessageName + ".Position"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "commit_position"),
        2: .standard(proto: "prepare_position"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt64Field(value: &commitPosition)
            case 2: try decoder.decodeSingularUInt64Field(value: &preparePosition)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if commitPosition != 0 {
            try visitor.visitSingularUInt64Field(value: commitPosition, fieldNumber: 1)
        }
        if preparePosition != 0 {
            try visitor.visitSingularUInt64Field(value: preparePosition, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_ReadReq.Options.Position, rhs: EventStore_Client_Streams_ReadReq.Options.Position) -> Bool {
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadReq.Options.FilterOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.protoMessageName + ".FilterOptions"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        2: .standard(proto: "event_type"),
        3: .same(proto: "max"),
        4: .same(proto: "count"),
        5: .same(proto: "checkpointIntervalMultiplier"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression?
                    var hadOneofValue = false
                    if let current = self.filter {
                        hadOneofValue = true
                        if case let .streamIdentifier(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.filter = .streamIdentifier(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression?
                    var hadOneofValue = false
                    if let current = self.filter {
                        hadOneofValue = true
                        if case let .eventType(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.filter = .eventType(v)
                    }
                }()
            case 3: try {
                    var v: UInt32?
                    try decoder.decodeSingularUInt32Field(value: &v)
                    if let v {
                        if self.window != nil { try decoder.handleConflictingOneOf() }
                        self.window = .max(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.window {
                        hadOneofValue = true
                        if case let .count(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.window = .count(v)
                    }
                }()
            case 5: try decoder.decodeSingularUInt32Field(value: &checkpointIntervalMultiplier)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch filter {
        case .streamIdentifier?: try {
                guard case let .streamIdentifier(v)? = self.filter else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .eventType?: try {
                guard case let .eventType(v)? = self.filter else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        switch window {
        case .max?: try {
                guard case let .max(v)? = self.window else { preconditionFailure() }
                try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
            }()
        case .count?: try {
                guard case let .count(v)? = self.window else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case nil: break
        }
        if checkpointIntervalMultiplier != 0 {
            try visitor.visitSingularUInt32Field(value: checkpointIntervalMultiplier, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_ReadReq.Options.FilterOptions, rhs: EventStore_Client_Streams_ReadReq.Options.FilterOptions) -> Bool {
        if lhs.filter != rhs.filter { return false }
        if lhs.window != rhs.window { return false }
        if lhs.checkpointIntervalMultiplier != rhs.checkpointIntervalMultiplier { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.FilterOptions.protoMessageName + ".Expression"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "regex"),
        2: .same(proto: "prefix"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &regex)
            case 2: try decoder.decodeRepeatedStringField(value: &prefix)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !regex.isEmpty {
            try visitor.visitSingularStringField(value: regex, fieldNumber: 1)
        }
        if !prefix.isEmpty {
            try visitor.visitRepeatedStringField(value: prefix, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression, rhs: EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression) -> Bool {
        if lhs.regex != rhs.regex { return false }
        if lhs.prefix != rhs.prefix { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadReq.Options.UUIDOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.protoMessageName + ".UUIDOption"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "structured"),
        2: .same(proto: "string"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .structured(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .structured(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .string(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .string(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch content {
        case .structured?: try {
                guard case let .structured(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .string?: try {
                guard case let .string(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_ReadReq.Options.UUIDOption, rhs: EventStore_Client_Streams_ReadReq.Options.UUIDOption) -> Bool {
        if lhs.content != rhs.content { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadReq.Options.ControlOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.protoMessageName + ".ControlOption"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "compatibility"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt32Field(value: &compatibility)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if compatibility != 0 {
            try visitor.visitSingularUInt32Field(value: compatibility, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_ReadReq.Options.ControlOption, rhs: EventStore_Client_Streams_ReadReq.Options.ControlOption) -> Bool {
        if lhs.compatibility != rhs.compatibility { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".ReadResp"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "event"),
        2: .same(proto: "confirmation"),
        3: .same(proto: "checkpoint"),
        4: .standard(proto: "stream_not_found"),
        5: .standard(proto: "first_stream_position"),
        6: .standard(proto: "last_stream_position"),
        7: .standard(proto: "last_all_stream_position"),
        8: .standard(proto: "caught_up"),
        9: .standard(proto: "fell_behind"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_Streams_ReadResp.ReadEvent?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .event(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .event(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Streams_ReadResp.SubscriptionConfirmation?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .confirmation(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .confirmation(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Streams_ReadResp.Checkpoint?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .checkpoint(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .checkpoint(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_Streams_ReadResp.StreamNotFound?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .streamNotFound(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .streamNotFound(v)
                    }
                }()
            case 5: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.content != nil { try decoder.handleConflictingOneOf() }
                        self.content = .firstStreamPosition(v)
                    }
                }()
            case 6: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.content != nil { try decoder.handleConflictingOneOf() }
                        self.content = .lastStreamPosition(v)
                    }
                }()
            case 7: try {
                    var v: EventStore_Client_AllStreamPosition?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .lastAllStreamPosition(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .lastAllStreamPosition(v)
                    }
                }()
            case 8: try {
                    var v: EventStore_Client_Streams_ReadResp.CaughtUp?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .caughtUp(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .caughtUp(v)
                    }
                }()
            case 9: try {
                    var v: EventStore_Client_Streams_ReadResp.FellBehind?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .fellBehind(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .fellBehind(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch content {
        case .event?: try {
                guard case let .event(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .confirmation?: try {
                guard case let .confirmation(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .checkpoint?: try {
                guard case let .checkpoint(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .streamNotFound?: try {
                guard case let .streamNotFound(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .firstStreamPosition?: try {
                guard case let .firstStreamPosition(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
            }()
        case .lastStreamPosition?: try {
                guard case let .lastStreamPosition(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
            }()
        case .lastAllStreamPosition?: try {
                guard case let .lastAllStreamPosition(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
            }()
        case .caughtUp?: try {
                guard case let .caughtUp(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
            }()
        case .fellBehind?: try {
                guard case let .fellBehind(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_ReadResp, rhs: EventStore_Client_Streams_ReadResp) -> Bool {
        if lhs.content != rhs.content { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadResp.CaughtUp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_ReadResp.protoMessageName + ".CaughtUp"
    package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_ReadResp.CaughtUp, rhs: EventStore_Client_Streams_ReadResp.CaughtUp) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadResp.FellBehind: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_ReadResp.protoMessageName + ".FellBehind"
    package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_ReadResp.FellBehind, rhs: EventStore_Client_Streams_ReadResp.FellBehind) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadResp.ReadEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_ReadResp.protoMessageName + ".ReadEvent"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "event"),
        2: .same(proto: "link"),
        3: .standard(proto: "commit_position"),
        4: .standard(proto: "no_position"),
    ]

    fileprivate class _StorageClass {
        var _event: EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent?
        var _link: EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent?
        var _position: EventStore_Client_Streams_ReadResp.ReadEvent.OneOf_Position?

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _event = source._event
            _link = source._link
            _position = source._position
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularMessageField(value: &_storage._event)
                case 2: try decoder.decodeSingularMessageField(value: &_storage._link)
                case 3: try {
                        var v: UInt64?
                        try decoder.decodeSingularUInt64Field(value: &v)
                        if let v {
                            if _storage._position != nil { try decoder.handleConflictingOneOf() }
                            _storage._position = .commitPosition(v)
                        }
                    }()
                case 4: try {
                        var v: EventStore_Client_Empty?
                        var hadOneofValue = false
                        if let current = _storage._position {
                            hadOneofValue = true
                            if case let .noPosition(m) = current { v = m }
                        }
                        try decoder.decodeSingularMessageField(value: &v)
                        if let v {
                            if hadOneofValue { try decoder.handleConflictingOneOf() }
                            _storage._position = .noPosition(v)
                        }
                    }()
                default: break
                }
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._event {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            try { if let v = _storage._link {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            } }()
            switch _storage._position {
            case .commitPosition?: try {
                    guard case let .commitPosition(v)? = _storage._position else { preconditionFailure() }
                    try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
                }()
            case .noPosition?: try {
                    guard case let .noPosition(v)? = _storage._position else { preconditionFailure() }
                    try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
                }()
            case nil: break
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_ReadResp.ReadEvent, rhs: EventStore_Client_Streams_ReadResp.ReadEvent) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._event != rhs_storage._event { return false }
                if _storage._link != rhs_storage._link { return false }
                if _storage._position != rhs_storage._position { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_ReadResp.ReadEvent.protoMessageName + ".RecordedEvent"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .standard(proto: "stream_identifier"),
        3: .standard(proto: "stream_revision"),
        4: .standard(proto: "prepare_position"),
        5: .standard(proto: "commit_position"),
        6: .same(proto: "metadata"),
        7: .standard(proto: "custom_metadata"),
        8: .same(proto: "data"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_id)
            case 2: try decoder.decodeSingularMessageField(value: &_streamIdentifier)
            case 3: try decoder.decodeSingularUInt64Field(value: &streamRevision)
            case 4: try decoder.decodeSingularUInt64Field(value: &preparePosition)
            case 5: try decoder.decodeSingularUInt64Field(value: &commitPosition)
            case 6: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: &metadata)
            case 7: try decoder.decodeSingularBytesField(value: &customMetadata)
            case 8: try decoder.decodeSingularBytesField(value: &data)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _id {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try { if let v = self._streamIdentifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if streamRevision != 0 {
            try visitor.visitSingularUInt64Field(value: streamRevision, fieldNumber: 3)
        }
        if preparePosition != 0 {
            try visitor.visitSingularUInt64Field(value: preparePosition, fieldNumber: 4)
        }
        if commitPosition != 0 {
            try visitor.visitSingularUInt64Field(value: commitPosition, fieldNumber: 5)
        }
        if !metadata.isEmpty {
            try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: metadata, fieldNumber: 6)
        }
        if !customMetadata.isEmpty {
            try visitor.visitSingularBytesField(value: customMetadata, fieldNumber: 7)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent, rhs: EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent) -> Bool {
        if lhs._id != rhs._id { return false }
        if lhs._streamIdentifier != rhs._streamIdentifier { return false }
        if lhs.streamRevision != rhs.streamRevision { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.metadata != rhs.metadata { return false }
        if lhs.customMetadata != rhs.customMetadata { return false }
        if lhs.data != rhs.data { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadResp.SubscriptionConfirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_ReadResp.protoMessageName + ".SubscriptionConfirmation"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "subscription_id"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &subscriptionID)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !subscriptionID.isEmpty {
            try visitor.visitSingularStringField(value: subscriptionID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_ReadResp.SubscriptionConfirmation, rhs: EventStore_Client_Streams_ReadResp.SubscriptionConfirmation) -> Bool {
        if lhs.subscriptionID != rhs.subscriptionID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadResp.Checkpoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_ReadResp.protoMessageName + ".Checkpoint"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "commit_position"),
        2: .standard(proto: "prepare_position"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt64Field(value: &commitPosition)
            case 2: try decoder.decodeSingularUInt64Field(value: &preparePosition)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if commitPosition != 0 {
            try visitor.visitSingularUInt64Field(value: commitPosition, fieldNumber: 1)
        }
        if preparePosition != 0 {
            try visitor.visitSingularUInt64Field(value: preparePosition, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_ReadResp.Checkpoint, rhs: EventStore_Client_Streams_ReadResp.Checkpoint) -> Bool {
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadResp.StreamNotFound: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_ReadResp.protoMessageName + ".StreamNotFound"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_streamIdentifier)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _streamIdentifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_ReadResp.StreamNotFound, rhs: EventStore_Client_Streams_ReadResp.StreamNotFound) -> Bool {
        if lhs._streamIdentifier != rhs._streamIdentifier { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_AppendReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".AppendReq"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
        2: .standard(proto: "proposed_message"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_Streams_AppendReq.Options?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .options(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .options(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Streams_AppendReq.ProposedMessage?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .proposedMessage(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .proposedMessage(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch content {
        case .options?: try {
                guard case let .options(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .proposedMessage?: try {
                guard case let .proposedMessage(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_AppendReq, rhs: EventStore_Client_Streams_AppendReq) -> Bool {
        if lhs.content != rhs.content { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_AppendReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_AppendReq.protoMessageName + ".Options"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        2: .same(proto: "revision"),
        3: .standard(proto: "no_stream"),
        4: .same(proto: "any"),
        5: .standard(proto: "stream_exists"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_streamIdentifier)
            case 2: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.expectedStreamRevision != nil { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .revision(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamRevision {
                        hadOneofValue = true
                        if case let .noStream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .noStream(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamRevision {
                        hadOneofValue = true
                        if case let .any(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .any(v)
                    }
                }()
            case 5: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamRevision {
                        hadOneofValue = true
                        if case let .streamExists(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .streamExists(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _streamIdentifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        switch expectedStreamRevision {
        case .revision?: try {
                guard case let .revision(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
            }()
        case .noStream?: try {
                guard case let .noStream(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .any?: try {
                guard case let .any(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .streamExists?: try {
                guard case let .streamExists(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_AppendReq.Options, rhs: EventStore_Client_Streams_AppendReq.Options) -> Bool {
        if lhs._streamIdentifier != rhs._streamIdentifier { return false }
        if lhs.expectedStreamRevision != rhs.expectedStreamRevision { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_AppendReq.ProposedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_AppendReq.protoMessageName + ".ProposedMessage"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "metadata"),
        3: .standard(proto: "custom_metadata"),
        4: .same(proto: "data"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_id)
            case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: &metadata)
            case 3: try decoder.decodeSingularBytesField(value: &customMetadata)
            case 4: try decoder.decodeSingularBytesField(value: &data)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _id {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !metadata.isEmpty {
            try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: metadata, fieldNumber: 2)
        }
        if !customMetadata.isEmpty {
            try visitor.visitSingularBytesField(value: customMetadata, fieldNumber: 3)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_AppendReq.ProposedMessage, rhs: EventStore_Client_Streams_AppendReq.ProposedMessage) -> Bool {
        if lhs._id != rhs._id { return false }
        if lhs.metadata != rhs.metadata { return false }
        if lhs.customMetadata != rhs.customMetadata { return false }
        if lhs.data != rhs.data { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_AppendResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".AppendResp"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "success"),
        2: .standard(proto: "wrong_expected_version"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_Streams_AppendResp.Success?
                    var hadOneofValue = false
                    if let current = self.result {
                        hadOneofValue = true
                        if case let .success(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.result = .success(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Streams_AppendResp.WrongExpectedVersion?
                    var hadOneofValue = false
                    if let current = self.result {
                        hadOneofValue = true
                        if case let .wrongExpectedVersion(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.result = .wrongExpectedVersion(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch result {
        case .success?: try {
                guard case let .success(v)? = self.result else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .wrongExpectedVersion?: try {
                guard case let .wrongExpectedVersion(v)? = self.result else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_AppendResp, rhs: EventStore_Client_Streams_AppendResp) -> Bool {
        if lhs.result != rhs.result { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_AppendResp.Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_AppendResp.protoMessageName + ".Position"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "commit_position"),
        2: .standard(proto: "prepare_position"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt64Field(value: &commitPosition)
            case 2: try decoder.decodeSingularUInt64Field(value: &preparePosition)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if commitPosition != 0 {
            try visitor.visitSingularUInt64Field(value: commitPosition, fieldNumber: 1)
        }
        if preparePosition != 0 {
            try visitor.visitSingularUInt64Field(value: preparePosition, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_AppendResp.Position, rhs: EventStore_Client_Streams_AppendResp.Position) -> Bool {
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_AppendResp.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_AppendResp.protoMessageName + ".Success"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "current_revision"),
        2: .standard(proto: "no_stream"),
        3: .same(proto: "position"),
        4: .standard(proto: "no_position"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.currentRevisionOption != nil { try decoder.handleConflictingOneOf() }
                        self.currentRevisionOption = .currentRevision(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.currentRevisionOption {
                        hadOneofValue = true
                        if case let .noStream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.currentRevisionOption = .noStream(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Streams_AppendResp.Position?
                    var hadOneofValue = false
                    if let current = self.positionOption {
                        hadOneofValue = true
                        if case let .position(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.positionOption = .position(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.positionOption {
                        hadOneofValue = true
                        if case let .noPosition(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.positionOption = .noPosition(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch currentRevisionOption {
        case .currentRevision?: try {
                guard case let .currentRevision(v)? = self.currentRevisionOption else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
            }()
        case .noStream?: try {
                guard case let .noStream(v)? = self.currentRevisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        switch positionOption {
        case .position?: try {
                guard case let .position(v)? = self.positionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .noPosition?: try {
                guard case let .noPosition(v)? = self.positionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_AppendResp.Success, rhs: EventStore_Client_Streams_AppendResp.Success) -> Bool {
        if lhs.currentRevisionOption != rhs.currentRevisionOption { return false }
        if lhs.positionOption != rhs.positionOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_AppendResp.WrongExpectedVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_AppendResp.protoMessageName + ".WrongExpectedVersion"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "current_revision_20_6_0"),
        2: .standard(proto: "no_stream_20_6_0"),
        3: .standard(proto: "expected_revision_20_6_0"),
        4: .standard(proto: "any_20_6_0"),
        5: .standard(proto: "stream_exists_20_6_0"),
        6: .standard(proto: "current_revision"),
        7: .standard(proto: "current_no_stream"),
        8: .standard(proto: "expected_revision"),
        9: .standard(proto: "expected_any"),
        10: .standard(proto: "expected_stream_exists"),
        11: .standard(proto: "expected_no_stream"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.currentRevisionOption2060 != nil { try decoder.handleConflictingOneOf() }
                        self.currentRevisionOption2060 = .currentRevision2060(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.currentRevisionOption2060 {
                        hadOneofValue = true
                        if case let .noStream2060(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.currentRevisionOption2060 = .noStream2060(v)
                    }
                }()
            case 3: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.expectedRevisionOption2060 != nil { try decoder.handleConflictingOneOf() }
                        self.expectedRevisionOption2060 = .expectedRevision2060(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedRevisionOption2060 {
                        hadOneofValue = true
                        if case let .any2060(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedRevisionOption2060 = .any2060(v)
                    }
                }()
            case 5: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedRevisionOption2060 {
                        hadOneofValue = true
                        if case let .streamExists2060(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedRevisionOption2060 = .streamExists2060(v)
                    }
                }()
            case 6: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.currentRevisionOption != nil { try decoder.handleConflictingOneOf() }
                        self.currentRevisionOption = .currentRevision(v)
                    }
                }()
            case 7: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.currentRevisionOption {
                        hadOneofValue = true
                        if case let .currentNoStream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.currentRevisionOption = .currentNoStream(v)
                    }
                }()
            case 8: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.expectedRevisionOption != nil { try decoder.handleConflictingOneOf() }
                        self.expectedRevisionOption = .expectedRevision(v)
                    }
                }()
            case 9: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedRevisionOption {
                        hadOneofValue = true
                        if case let .expectedAny(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedRevisionOption = .expectedAny(v)
                    }
                }()
            case 10: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedRevisionOption {
                        hadOneofValue = true
                        if case let .expectedStreamExists(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedRevisionOption = .expectedStreamExists(v)
                    }
                }()
            case 11: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedRevisionOption {
                        hadOneofValue = true
                        if case let .expectedNoStream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedRevisionOption = .expectedNoStream(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch currentRevisionOption2060 {
        case .currentRevision2060?: try {
                guard case let .currentRevision2060(v)? = self.currentRevisionOption2060 else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
            }()
        case .noStream2060?: try {
                guard case let .noStream2060(v)? = self.currentRevisionOption2060 else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        switch expectedRevisionOption2060 {
        case .expectedRevision2060?: try {
                guard case let .expectedRevision2060(v)? = self.expectedRevisionOption2060 else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
            }()
        case .any2060?: try {
                guard case let .any2060(v)? = self.expectedRevisionOption2060 else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .streamExists2060?: try {
                guard case let .streamExists2060(v)? = self.expectedRevisionOption2060 else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case nil: break
        }
        switch currentRevisionOption {
        case .currentRevision?: try {
                guard case let .currentRevision(v)? = self.currentRevisionOption else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
            }()
        case .currentNoStream?: try {
                guard case let .currentNoStream(v)? = self.currentRevisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
            }()
        case nil: break
        }
        switch expectedRevisionOption {
        case .expectedRevision?: try {
                guard case let .expectedRevision(v)? = self.expectedRevisionOption else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
            }()
        case .expectedAny?: try {
                guard case let .expectedAny(v)? = self.expectedRevisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
            }()
        case .expectedStreamExists?: try {
                guard case let .expectedStreamExists(v)? = self.expectedRevisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
            }()
        case .expectedNoStream?: try {
                guard case let .expectedNoStream(v)? = self.expectedRevisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_AppendResp.WrongExpectedVersion, rhs: EventStore_Client_Streams_AppendResp.WrongExpectedVersion) -> Bool {
        if lhs.currentRevisionOption2060 != rhs.currentRevisionOption2060 { return false }
        if lhs.expectedRevisionOption2060 != rhs.expectedRevisionOption2060 { return false }
        if lhs.currentRevisionOption != rhs.currentRevisionOption { return false }
        if lhs.expectedRevisionOption != rhs.expectedRevisionOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_BatchAppendReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".BatchAppendReq"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "correlation_id"),
        2: .same(proto: "options"),
        3: .standard(proto: "proposed_messages"),
        4: .standard(proto: "is_final"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_correlationID)
            case 2: try decoder.decodeSingularMessageField(value: &_options)
            case 3: try decoder.decodeRepeatedMessageField(value: &proposedMessages)
            case 4: try decoder.decodeSingularBoolField(value: &isFinal)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _correlationID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try { if let v = self._options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if !proposedMessages.isEmpty {
            try visitor.visitRepeatedMessageField(value: proposedMessages, fieldNumber: 3)
        }
        if isFinal != false {
            try visitor.visitSingularBoolField(value: isFinal, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_BatchAppendReq, rhs: EventStore_Client_Streams_BatchAppendReq) -> Bool {
        if lhs._correlationID != rhs._correlationID { return false }
        if lhs._options != rhs._options { return false }
        if lhs.proposedMessages != rhs.proposedMessages { return false }
        if lhs.isFinal != rhs.isFinal { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_BatchAppendReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_BatchAppendReq.protoMessageName + ".Options"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        2: .standard(proto: "stream_position"),
        3: .standard(proto: "no_stream"),
        4: .same(proto: "any"),
        5: .standard(proto: "stream_exists"),
        6: .standard(proto: "deadline_21_10_0"),
        7: .same(proto: "deadline"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_streamIdentifier)
            case 2: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.expectedStreamPosition != nil { try decoder.handleConflictingOneOf() }
                        self.expectedStreamPosition = .streamPosition(v)
                    }
                }()
            case 3: try {
                    var v: SwiftProtobuf.Google_Protobuf_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamPosition {
                        hadOneofValue = true
                        if case let .noStream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamPosition = .noStream(v)
                    }
                }()
            case 4: try {
                    var v: SwiftProtobuf.Google_Protobuf_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamPosition {
                        hadOneofValue = true
                        if case let .any(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamPosition = .any(v)
                    }
                }()
            case 5: try {
                    var v: SwiftProtobuf.Google_Protobuf_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamPosition {
                        hadOneofValue = true
                        if case let .streamExists(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamPosition = .streamExists(v)
                    }
                }()
            case 6: try {
                    var v: SwiftProtobuf.Google_Protobuf_Timestamp?
                    var hadOneofValue = false
                    if let current = self.deadlineOption {
                        hadOneofValue = true
                        if case let .deadline21100(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.deadlineOption = .deadline21100(v)
                    }
                }()
            case 7: try {
                    var v: SwiftProtobuf.Google_Protobuf_Duration?
                    var hadOneofValue = false
                    if let current = self.deadlineOption {
                        hadOneofValue = true
                        if case let .deadline(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.deadlineOption = .deadline(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _streamIdentifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        switch expectedStreamPosition {
        case .streamPosition?: try {
                guard case let .streamPosition(v)? = self.expectedStreamPosition else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
            }()
        case .noStream?: try {
                guard case let .noStream(v)? = self.expectedStreamPosition else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .any?: try {
                guard case let .any(v)? = self.expectedStreamPosition else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .streamExists?: try {
                guard case let .streamExists(v)? = self.expectedStreamPosition else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case nil: break
        }
        switch deadlineOption {
        case .deadline21100?: try {
                guard case let .deadline21100(v)? = self.deadlineOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
            }()
        case .deadline?: try {
                guard case let .deadline(v)? = self.deadlineOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_BatchAppendReq.Options, rhs: EventStore_Client_Streams_BatchAppendReq.Options) -> Bool {
        if lhs._streamIdentifier != rhs._streamIdentifier { return false }
        if lhs.expectedStreamPosition != rhs.expectedStreamPosition { return false }
        if lhs.deadlineOption != rhs.deadlineOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_BatchAppendReq.ProposedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_BatchAppendReq.protoMessageName + ".ProposedMessage"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "metadata"),
        3: .standard(proto: "custom_metadata"),
        4: .same(proto: "data"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_id)
            case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: &metadata)
            case 3: try decoder.decodeSingularBytesField(value: &customMetadata)
            case 4: try decoder.decodeSingularBytesField(value: &data)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _id {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !metadata.isEmpty {
            try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: metadata, fieldNumber: 2)
        }
        if !customMetadata.isEmpty {
            try visitor.visitSingularBytesField(value: customMetadata, fieldNumber: 3)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_BatchAppendReq.ProposedMessage, rhs: EventStore_Client_Streams_BatchAppendReq.ProposedMessage) -> Bool {
        if lhs._id != rhs._id { return false }
        if lhs.metadata != rhs.metadata { return false }
        if lhs.customMetadata != rhs.customMetadata { return false }
        if lhs.data != rhs.data { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_BatchAppendResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".BatchAppendResp"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "correlation_id"),
        2: .same(proto: "error"),
        3: .same(proto: "success"),
        4: .standard(proto: "stream_identifier"),
        5: .standard(proto: "stream_position"),
        6: .standard(proto: "no_stream"),
        7: .same(proto: "any"),
        8: .standard(proto: "stream_exists"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_correlationID)
            case 2: try {
                    var v: Google_Rpc_Status?
                    var hadOneofValue = false
                    if let current = self.result {
                        hadOneofValue = true
                        if case let .error(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.result = .error(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Streams_BatchAppendResp.Success?
                    var hadOneofValue = false
                    if let current = self.result {
                        hadOneofValue = true
                        if case let .success(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.result = .success(v)
                    }
                }()
            case 4: try decoder.decodeSingularMessageField(value: &_streamIdentifier)
            case 5: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.expectedStreamPosition != nil { try decoder.handleConflictingOneOf() }
                        self.expectedStreamPosition = .streamPosition(v)
                    }
                }()
            case 6: try {
                    var v: SwiftProtobuf.Google_Protobuf_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamPosition {
                        hadOneofValue = true
                        if case let .noStream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamPosition = .noStream(v)
                    }
                }()
            case 7: try {
                    var v: SwiftProtobuf.Google_Protobuf_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamPosition {
                        hadOneofValue = true
                        if case let .any(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamPosition = .any(v)
                    }
                }()
            case 8: try {
                    var v: SwiftProtobuf.Google_Protobuf_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamPosition {
                        hadOneofValue = true
                        if case let .streamExists(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamPosition = .streamExists(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _correlationID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        switch result {
        case .error?: try {
                guard case let .error(v)? = self.result else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .success?: try {
                guard case let .success(v)? = self.result else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        try { if let v = self._streamIdentifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        switch expectedStreamPosition {
        case .streamPosition?: try {
                guard case let .streamPosition(v)? = self.expectedStreamPosition else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
            }()
        case .noStream?: try {
                guard case let .noStream(v)? = self.expectedStreamPosition else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
            }()
        case .any?: try {
                guard case let .any(v)? = self.expectedStreamPosition else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
            }()
        case .streamExists?: try {
                guard case let .streamExists(v)? = self.expectedStreamPosition else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_BatchAppendResp, rhs: EventStore_Client_Streams_BatchAppendResp) -> Bool {
        if lhs._correlationID != rhs._correlationID { return false }
        if lhs.result != rhs.result { return false }
        if lhs._streamIdentifier != rhs._streamIdentifier { return false }
        if lhs.expectedStreamPosition != rhs.expectedStreamPosition { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_BatchAppendResp.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_BatchAppendResp.protoMessageName + ".Success"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "current_revision"),
        2: .standard(proto: "no_stream"),
        3: .same(proto: "position"),
        4: .standard(proto: "no_position"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.currentRevisionOption != nil { try decoder.handleConflictingOneOf() }
                        self.currentRevisionOption = .currentRevision(v)
                    }
                }()
            case 2: try {
                    var v: SwiftProtobuf.Google_Protobuf_Empty?
                    var hadOneofValue = false
                    if let current = self.currentRevisionOption {
                        hadOneofValue = true
                        if case let .noStream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.currentRevisionOption = .noStream(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_AllStreamPosition?
                    var hadOneofValue = false
                    if let current = self.positionOption {
                        hadOneofValue = true
                        if case let .position(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.positionOption = .position(v)
                    }
                }()
            case 4: try {
                    var v: SwiftProtobuf.Google_Protobuf_Empty?
                    var hadOneofValue = false
                    if let current = self.positionOption {
                        hadOneofValue = true
                        if case let .noPosition(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.positionOption = .noPosition(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch currentRevisionOption {
        case .currentRevision?: try {
                guard case let .currentRevision(v)? = self.currentRevisionOption else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
            }()
        case .noStream?: try {
                guard case let .noStream(v)? = self.currentRevisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        switch positionOption {
        case .position?: try {
                guard case let .position(v)? = self.positionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .noPosition?: try {
                guard case let .noPosition(v)? = self.positionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_BatchAppendResp.Success, rhs: EventStore_Client_Streams_BatchAppendResp.Success) -> Bool {
        if lhs.currentRevisionOption != rhs.currentRevisionOption { return false }
        if lhs.positionOption != rhs.positionOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_DeleteReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".DeleteReq"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_DeleteReq, rhs: EventStore_Client_Streams_DeleteReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_DeleteReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_DeleteReq.protoMessageName + ".Options"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        2: .same(proto: "revision"),
        3: .standard(proto: "no_stream"),
        4: .same(proto: "any"),
        5: .standard(proto: "stream_exists"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_streamIdentifier)
            case 2: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.expectedStreamRevision != nil { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .revision(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamRevision {
                        hadOneofValue = true
                        if case let .noStream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .noStream(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamRevision {
                        hadOneofValue = true
                        if case let .any(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .any(v)
                    }
                }()
            case 5: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamRevision {
                        hadOneofValue = true
                        if case let .streamExists(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .streamExists(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _streamIdentifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        switch expectedStreamRevision {
        case .revision?: try {
                guard case let .revision(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
            }()
        case .noStream?: try {
                guard case let .noStream(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .any?: try {
                guard case let .any(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .streamExists?: try {
                guard case let .streamExists(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_DeleteReq.Options, rhs: EventStore_Client_Streams_DeleteReq.Options) -> Bool {
        if lhs._streamIdentifier != rhs._streamIdentifier { return false }
        if lhs.expectedStreamRevision != rhs.expectedStreamRevision { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_DeleteResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".DeleteResp"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "position"),
        2: .standard(proto: "no_position"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_Streams_DeleteResp.Position?
                    var hadOneofValue = false
                    if let current = self.positionOption {
                        hadOneofValue = true
                        if case let .position(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.positionOption = .position(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.positionOption {
                        hadOneofValue = true
                        if case let .noPosition(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.positionOption = .noPosition(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch positionOption {
        case .position?: try {
                guard case let .position(v)? = self.positionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .noPosition?: try {
                guard case let .noPosition(v)? = self.positionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_DeleteResp, rhs: EventStore_Client_Streams_DeleteResp) -> Bool {
        if lhs.positionOption != rhs.positionOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_DeleteResp.Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_DeleteResp.protoMessageName + ".Position"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "commit_position"),
        2: .standard(proto: "prepare_position"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt64Field(value: &commitPosition)
            case 2: try decoder.decodeSingularUInt64Field(value: &preparePosition)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if commitPosition != 0 {
            try visitor.visitSingularUInt64Field(value: commitPosition, fieldNumber: 1)
        }
        if preparePosition != 0 {
            try visitor.visitSingularUInt64Field(value: preparePosition, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_DeleteResp.Position, rhs: EventStore_Client_Streams_DeleteResp.Position) -> Bool {
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_TombstoneReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".TombstoneReq"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_TombstoneReq, rhs: EventStore_Client_Streams_TombstoneReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_TombstoneReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_TombstoneReq.protoMessageName + ".Options"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        2: .same(proto: "revision"),
        3: .standard(proto: "no_stream"),
        4: .same(proto: "any"),
        5: .standard(proto: "stream_exists"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_streamIdentifier)
            case 2: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.expectedStreamRevision != nil { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .revision(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamRevision {
                        hadOneofValue = true
                        if case let .noStream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .noStream(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamRevision {
                        hadOneofValue = true
                        if case let .any(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .any(v)
                    }
                }()
            case 5: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamRevision {
                        hadOneofValue = true
                        if case let .streamExists(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .streamExists(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _streamIdentifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        switch expectedStreamRevision {
        case .revision?: try {
                guard case let .revision(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
            }()
        case .noStream?: try {
                guard case let .noStream(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .any?: try {
                guard case let .any(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .streamExists?: try {
                guard case let .streamExists(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_TombstoneReq.Options, rhs: EventStore_Client_Streams_TombstoneReq.Options) -> Bool {
        if lhs._streamIdentifier != rhs._streamIdentifier { return false }
        if lhs.expectedStreamRevision != rhs.expectedStreamRevision { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_TombstoneResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = _protobuf_package + ".TombstoneResp"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "position"),
        2: .standard(proto: "no_position"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_Streams_TombstoneResp.Position?
                    var hadOneofValue = false
                    if let current = self.positionOption {
                        hadOneofValue = true
                        if case let .position(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.positionOption = .position(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.positionOption {
                        hadOneofValue = true
                        if case let .noPosition(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.positionOption = .noPosition(v)
                    }
                }()
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch positionOption {
        case .position?: try {
                guard case let .position(v)? = self.positionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .noPosition?: try {
                guard case let .noPosition(v)? = self.positionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_TombstoneResp, rhs: EventStore_Client_Streams_TombstoneResp) -> Bool {
        if lhs.positionOption != rhs.positionOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_TombstoneResp.Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    package static let protoMessageName: String = EventStore_Client_Streams_TombstoneResp.protoMessageName + ".Position"
    package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "commit_position"),
        2: .standard(proto: "prepare_position"),
    ]

    package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt64Field(value: &commitPosition)
            case 2: try decoder.decodeSingularUInt64Field(value: &preparePosition)
            default: break
            }
        }
    }

    package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if commitPosition != 0 {
            try visitor.visitSingularUInt64Field(value: commitPosition, fieldNumber: 1)
        }
        if preparePosition != 0 {
            try visitor.visitSingularUInt64Field(value: preparePosition, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    package static func == (lhs: EventStore_Client_Streams_TombstoneResp.Position, rhs: EventStore_Client_Streams_TombstoneResp.Position) -> Bool {
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
