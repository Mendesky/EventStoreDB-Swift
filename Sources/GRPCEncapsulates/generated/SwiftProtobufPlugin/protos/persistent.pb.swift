// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protos/persistent.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

public struct EventStore_Client_PersistentSubscriptions_ReadReq {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var content: EventStore_Client_PersistentSubscriptions_ReadReq.OneOf_Content?

    public var options: EventStore_Client_PersistentSubscriptions_ReadReq.Options {
        get {
            if case let .options(v)? = content { return v }
            return EventStore_Client_PersistentSubscriptions_ReadReq.Options()
        }
        set { content = .options(newValue) }
    }

    public var ack: EventStore_Client_PersistentSubscriptions_ReadReq.Ack {
        get {
            if case let .ack(v)? = content { return v }
            return EventStore_Client_PersistentSubscriptions_ReadReq.Ack()
        }
        set { content = .ack(newValue) }
    }

    public var nack: EventStore_Client_PersistentSubscriptions_ReadReq.Nack {
        get {
            if case let .nack(v)? = content { return v }
            return EventStore_Client_PersistentSubscriptions_ReadReq.Nack()
        }
        set { content = .nack(newValue) }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Content: Equatable {
        case options(EventStore_Client_PersistentSubscriptions_ReadReq.Options)
        case ack(EventStore_Client_PersistentSubscriptions_ReadReq.Ack)
        case nack(EventStore_Client_PersistentSubscriptions_ReadReq.Nack)

        #if !swift(>=4.1)
            public static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadReq.OneOf_Content, rhs: EventStore_Client_PersistentSubscriptions_ReadReq.OneOf_Content) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.options, .options): {
                        guard case let .options(l) = lhs, case let .options(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.ack, .ack): {
                        guard case let .ack(l) = lhs, case let .ack(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.nack, .nack): {
                        guard case let .nack(l) = lhs, case let .nack(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: false
                }
            }
        #endif
    }

    public struct Options {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var streamOption: EventStore_Client_PersistentSubscriptions_ReadReq.Options.OneOf_StreamOption?

        public var streamIdentifier: EventStore_Client_StreamIdentifier {
            get {
                if case let .streamIdentifier(v)? = streamOption { return v }
                return EventStore_Client_StreamIdentifier()
            }
            set { streamOption = .streamIdentifier(newValue) }
        }

        public var all: EventStore_Client_Empty {
            get {
                if case let .all(v)? = streamOption { return v }
                return EventStore_Client_Empty()
            }
            set { streamOption = .all(newValue) }
        }

        public var groupName: String = .init()

        public var bufferSize: Int32 = 0

        public var uuidOption: EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption {
            get { _uuidOption ?? EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption() }
            set { _uuidOption = newValue }
        }

        /// Returns true if `uuidOption` has been explicitly set.
        public var hasUuidOption: Bool { _uuidOption != nil }
        /// Clears the value of `uuidOption`. Subsequent reads from it will return its default value.
        public mutating func clearUuidOption() { _uuidOption = nil }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_StreamOption: Equatable {
            case streamIdentifier(EventStore_Client_StreamIdentifier)
            case all(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadReq.Options.OneOf_StreamOption, rhs: EventStore_Client_PersistentSubscriptions_ReadReq.Options.OneOf_StreamOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.streamIdentifier, .streamIdentifier): {
                            guard case let .streamIdentifier(l) = lhs, case let .streamIdentifier(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.all, .all): {
                            guard case let .all(l) = lhs, case let .all(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public struct UUIDOption {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var content: EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption.OneOf_Content?

            public var structured: EventStore_Client_Empty {
                get {
                    if case let .structured(v)? = content { return v }
                    return EventStore_Client_Empty()
                }
                set { content = .structured(newValue) }
            }

            public var string: EventStore_Client_Empty {
                get {
                    if case let .string(v)? = content { return v }
                    return EventStore_Client_Empty()
                }
                set { content = .string(newValue) }
            }

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum OneOf_Content: Equatable {
                case structured(EventStore_Client_Empty)
                case string(EventStore_Client_Empty)

                #if !swift(>=4.1)
                    public static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption.OneOf_Content, rhs: EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption.OneOf_Content) -> Bool {
                        // The use of inline closures is to circumvent an issue where the compiler
                        // allocates stack space for every case branch when no optimizations are
                        // enabled. https://github.com/apple/swift-protobuf/issues/1034
                        switch (lhs, rhs) {
                        case (.structured, .structured): {
                                guard case let .structured(l) = lhs, case let .structured(r) = rhs else { preconditionFailure() }
                                return l == r
                            }()
                        case (.string, .string): {
                                guard case let .string(l) = lhs, case let .string(r) = rhs else { preconditionFailure() }
                                return l == r
                            }()
                        default: false
                        }
                    }
                #endif
            }

            public init() {}
        }

        public init() {}

        fileprivate var _uuidOption: EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption?
    }

    public struct Ack {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: Data = .init()

        public var ids: [EventStore_Client_UUID] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public struct Nack {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: Data = .init()

        public var ids: [EventStore_Client_UUID] = []

        public var action: EventStore_Client_PersistentSubscriptions_ReadReq.Nack.Action = .unknown

        public var reason: String = .init()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum Action: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case unknown // = 0
            case park // = 1
            case retry // = 2
            case skip // = 3
            case stop // = 4
            case UNRECOGNIZED(Int)

            public init() {
                self = .unknown
            }

            public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .unknown
                case 1: self = .park
                case 2: self = .retry
                case 3: self = .skip
                case 4: self = .stop
                default: self = .UNRECOGNIZED(rawValue)
                }
            }

            public var rawValue: Int {
                switch self {
                case .unknown: 0
                case .park: 1
                case .retry: 2
                case .skip: 3
                case .stop: 4
                case let .UNRECOGNIZED(i): i
                }
            }
        }

        public init() {}
    }

    public init() {}
}

#if swift(>=4.2)

    extension EventStore_Client_PersistentSubscriptions_ReadReq.Nack.Action: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [EventStore_Client_PersistentSubscriptions_ReadReq.Nack.Action] = [
            .unknown,
            .park,
            .retry,
            .skip,
            .stop,
        ]
    }

#endif // swift(>=4.2)

public struct EventStore_Client_PersistentSubscriptions_ReadResp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var content: EventStore_Client_PersistentSubscriptions_ReadResp.OneOf_Content?

    public var event: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent {
        get {
            if case let .event(v)? = content { return v }
            return EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent()
        }
        set { content = .event(newValue) }
    }

    public var subscriptionConfirmation: EventStore_Client_PersistentSubscriptions_ReadResp.SubscriptionConfirmation {
        get {
            if case let .subscriptionConfirmation(v)? = content { return v }
            return EventStore_Client_PersistentSubscriptions_ReadResp.SubscriptionConfirmation()
        }
        set { content = .subscriptionConfirmation(newValue) }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Content: Equatable {
        case event(EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent)
        case subscriptionConfirmation(EventStore_Client_PersistentSubscriptions_ReadResp.SubscriptionConfirmation)

        #if !swift(>=4.1)
            public static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadResp.OneOf_Content, rhs: EventStore_Client_PersistentSubscriptions_ReadResp.OneOf_Content) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.event, .event): {
                        guard case let .event(l) = lhs, case let .event(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.subscriptionConfirmation, .subscriptionConfirmation): {
                        guard case let .subscriptionConfirmation(l) = lhs, case let .subscriptionConfirmation(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: false
                }
            }
        #endif
    }

    public struct ReadEvent {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var event: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent {
            get { _storage._event ?? EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent() }
            set { _uniqueStorage()._event = newValue }
        }

        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool { _storage._event != nil }
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() { _uniqueStorage()._event = nil }

        public var link: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent {
            get { _storage._link ?? EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent() }
            set { _uniqueStorage()._link = newValue }
        }

        /// Returns true if `link` has been explicitly set.
        public var hasLink: Bool { _storage._link != nil }
        /// Clears the value of `link`. Subsequent reads from it will return its default value.
        public mutating func clearLink() { _uniqueStorage()._link = nil }

        public var position: OneOf_Position? {
            get { _storage._position }
            set { _uniqueStorage()._position = newValue }
        }

        public var commitPosition: UInt64 {
            get {
                if case let .commitPosition(v)? = _storage._position { return v }
                return 0
            }
            set { _uniqueStorage()._position = .commitPosition(newValue) }
        }

        public var noPosition: EventStore_Client_Empty {
            get {
                if case let .noPosition(v)? = _storage._position { return v }
                return EventStore_Client_Empty()
            }
            set { _uniqueStorage()._position = .noPosition(newValue) }
        }

        public var count: OneOf_Count? {
            get { _storage._count }
            set { _uniqueStorage()._count = newValue }
        }

        public var retryCount: Int32 {
            get {
                if case let .retryCount(v)? = _storage._count { return v }
                return 0
            }
            set { _uniqueStorage()._count = .retryCount(newValue) }
        }

        public var noRetryCount: EventStore_Client_Empty {
            get {
                if case let .noRetryCount(v)? = _storage._count { return v }
                return EventStore_Client_Empty()
            }
            set { _uniqueStorage()._count = .noRetryCount(newValue) }
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_Position: Equatable {
            case commitPosition(UInt64)
            case noPosition(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.OneOf_Position, rhs: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.OneOf_Position) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.commitPosition, .commitPosition): {
                            guard case let .commitPosition(l) = lhs, case let .commitPosition(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.noPosition, .noPosition): {
                            guard case let .noPosition(l) = lhs, case let .noPosition(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public enum OneOf_Count: Equatable {
            case retryCount(Int32)
            case noRetryCount(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.OneOf_Count, rhs: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.OneOf_Count) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.retryCount, .retryCount): {
                            guard case let .retryCount(l) = lhs, case let .retryCount(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.noRetryCount, .noRetryCount): {
                            guard case let .noRetryCount(l) = lhs, case let .noRetryCount(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public struct RecordedEvent {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var id: EventStore_Client_UUID {
                get { _id ?? EventStore_Client_UUID() }
                set { _id = newValue }
            }

            /// Returns true if `id` has been explicitly set.
            public var hasID: Bool { _id != nil }
            /// Clears the value of `id`. Subsequent reads from it will return its default value.
            public mutating func clearID() { _id = nil }

            public var streamIdentifier: EventStore_Client_StreamIdentifier {
                get { _streamIdentifier ?? EventStore_Client_StreamIdentifier() }
                set { _streamIdentifier = newValue }
            }

            /// Returns true if `streamIdentifier` has been explicitly set.
            public var hasStreamIdentifier: Bool { _streamIdentifier != nil }
            /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
            public mutating func clearStreamIdentifier() { _streamIdentifier = nil }

            public var streamRevision: UInt64 = 0

            public var preparePosition: UInt64 = 0

            public var commitPosition: UInt64 = 0

            public var metadata: [String: String] = [:]

            public var customMetadata: Data = .init()

            public var data: Data = .init()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}

            fileprivate var _id: EventStore_Client_UUID?
            fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier?
        }

        public init() {}

        fileprivate var _storage = _StorageClass.defaultInstance
    }

    public struct SubscriptionConfirmation {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var subscriptionID: String = .init()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public init() {}
}

public struct EventStore_Client_PersistentSubscriptions_CreateReq {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var options: EventStore_Client_PersistentSubscriptions_CreateReq.Options {
        get { _options ?? EventStore_Client_PersistentSubscriptions_CreateReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    public var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    public mutating func clearOptions() { _options = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum ConsumerStrategy: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case dispatchToSingle // = 0
        case roundRobin // = 1
        case pinned // = 2
        case UNRECOGNIZED(Int)

        public init() {
            self = .dispatchToSingle
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .dispatchToSingle
            case 1: self = .roundRobin
            case 2: self = .pinned
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .dispatchToSingle: 0
            case .roundRobin: 1
            case .pinned: 2
            case let .UNRECOGNIZED(i): i
            }
        }
    }

    public struct Options {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var streamOption: OneOf_StreamOption? {
            get { _storage._streamOption }
            set { _uniqueStorage()._streamOption = newValue }
        }

        public var stream: EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions {
            get {
                if case let .stream(v)? = _storage._streamOption { return v }
                return EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions()
            }
            set { _uniqueStorage()._streamOption = .stream(newValue) }
        }

        public var all: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions {
            get {
                if case let .all(v)? = _storage._streamOption { return v }
                return EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions()
            }
            set { _uniqueStorage()._streamOption = .all(newValue) }
        }

        public var streamIdentifier: EventStore_Client_StreamIdentifier {
            get { _storage._streamIdentifier ?? EventStore_Client_StreamIdentifier() }
            set { _uniqueStorage()._streamIdentifier = newValue }
        }

        /// Returns true if `streamIdentifier` has been explicitly set.
        public var hasStreamIdentifier: Bool { _storage._streamIdentifier != nil }
        /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
        public mutating func clearStreamIdentifier() { _uniqueStorage()._streamIdentifier = nil }

        public var groupName: String {
            get { _storage._groupName }
            set { _uniqueStorage()._groupName = newValue }
        }

        public var settings: EventStore_Client_PersistentSubscriptions_CreateReq.Settings {
            get { _storage._settings ?? EventStore_Client_PersistentSubscriptions_CreateReq.Settings() }
            set { _uniqueStorage()._settings = newValue }
        }

        /// Returns true if `settings` has been explicitly set.
        public var hasSettings: Bool { _storage._settings != nil }
        /// Clears the value of `settings`. Subsequent reads from it will return its default value.
        public mutating func clearSettings() { _uniqueStorage()._settings = nil }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_StreamOption: Equatable {
            case stream(EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions)
            case all(EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq.Options.OneOf_StreamOption, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.Options.OneOf_StreamOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.stream, .stream): {
                            guard case let .stream(l) = lhs, case let .stream(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.all, .all): {
                            guard case let .all(l) = lhs, case let .all(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public init() {}

        fileprivate var _storage = _StorageClass.defaultInstance
    }

    public struct StreamOptions {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var streamIdentifier: EventStore_Client_StreamIdentifier {
            get { _streamIdentifier ?? EventStore_Client_StreamIdentifier() }
            set { _streamIdentifier = newValue }
        }

        /// Returns true if `streamIdentifier` has been explicitly set.
        public var hasStreamIdentifier: Bool { _streamIdentifier != nil }
        /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
        public mutating func clearStreamIdentifier() { _streamIdentifier = nil }

        public var revisionOption: EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions.OneOf_RevisionOption?

        public var revision: UInt64 {
            get {
                if case let .revision(v)? = revisionOption { return v }
                return 0
            }
            set { revisionOption = .revision(newValue) }
        }

        public var start: EventStore_Client_Empty {
            get {
                if case let .start(v)? = revisionOption { return v }
                return EventStore_Client_Empty()
            }
            set { revisionOption = .start(newValue) }
        }

        public var end: EventStore_Client_Empty {
            get {
                if case let .end(v)? = revisionOption { return v }
                return EventStore_Client_Empty()
            }
            set { revisionOption = .end(newValue) }
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_RevisionOption: Equatable {
            case revision(UInt64)
            case start(EventStore_Client_Empty)
            case end(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions.OneOf_RevisionOption, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions.OneOf_RevisionOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.revision, .revision): {
                            guard case let .revision(l) = lhs, case let .revision(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.start, .start): {
                            guard case let .start(l) = lhs, case let .start(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.end, .end): {
                            guard case let .end(l) = lhs, case let .end(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public init() {}

        fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier?
    }

    public struct AllOptions {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var allOption: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.OneOf_AllOption?

        public var position: EventStore_Client_PersistentSubscriptions_CreateReq.Position {
            get {
                if case let .position(v)? = allOption { return v }
                return EventStore_Client_PersistentSubscriptions_CreateReq.Position()
            }
            set { allOption = .position(newValue) }
        }

        public var start: EventStore_Client_Empty {
            get {
                if case let .start(v)? = allOption { return v }
                return EventStore_Client_Empty()
            }
            set { allOption = .start(newValue) }
        }

        public var end: EventStore_Client_Empty {
            get {
                if case let .end(v)? = allOption { return v }
                return EventStore_Client_Empty()
            }
            set { allOption = .end(newValue) }
        }

        public var filterOption: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.OneOf_FilterOption?

        public var filter: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions {
            get {
                if case let .filter(v)? = filterOption { return v }
                return EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions()
            }
            set { filterOption = .filter(newValue) }
        }

        public var noFilter: EventStore_Client_Empty {
            get {
                if case let .noFilter(v)? = filterOption { return v }
                return EventStore_Client_Empty()
            }
            set { filterOption = .noFilter(newValue) }
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_AllOption: Equatable {
            case position(EventStore_Client_PersistentSubscriptions_CreateReq.Position)
            case start(EventStore_Client_Empty)
            case end(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.OneOf_AllOption, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.OneOf_AllOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.position, .position): {
                            guard case let .position(l) = lhs, case let .position(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.start, .start): {
                            guard case let .start(l) = lhs, case let .start(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.end, .end): {
                            guard case let .end(l) = lhs, case let .end(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public enum OneOf_FilterOption: Equatable {
            case filter(EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions)
            case noFilter(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.OneOf_FilterOption, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.OneOf_FilterOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.filter, .filter): {
                            guard case let .filter(l) = lhs, case let .filter(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.noFilter, .noFilter): {
                            guard case let .noFilter(l) = lhs, case let .noFilter(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public struct FilterOptions {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var filter: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.OneOf_Filter?

            public var streamIdentifier: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression {
                get {
                    if case let .streamIdentifier(v)? = filter { return v }
                    return EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression()
                }
                set { filter = .streamIdentifier(newValue) }
            }

            public var eventType: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression {
                get {
                    if case let .eventType(v)? = filter { return v }
                    return EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression()
                }
                set { filter = .eventType(newValue) }
            }

            public var window: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.OneOf_Window?

            public var max: UInt32 {
                get {
                    if case let .max(v)? = window { return v }
                    return 0
                }
                set { window = .max(newValue) }
            }

            public var count: EventStore_Client_Empty {
                get {
                    if case let .count(v)? = window { return v }
                    return EventStore_Client_Empty()
                }
                set { window = .count(newValue) }
            }

            public var checkpointIntervalMultiplier: UInt32 = 0

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum OneOf_Filter: Equatable {
                case streamIdentifier(EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression)
                case eventType(EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression)

                #if !swift(>=4.1)
                    public static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.OneOf_Filter, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.OneOf_Filter) -> Bool {
                        // The use of inline closures is to circumvent an issue where the compiler
                        // allocates stack space for every case branch when no optimizations are
                        // enabled. https://github.com/apple/swift-protobuf/issues/1034
                        switch (lhs, rhs) {
                        case (.streamIdentifier, .streamIdentifier): {
                                guard case let .streamIdentifier(l) = lhs, case let .streamIdentifier(r) = rhs else { preconditionFailure() }
                                return l == r
                            }()
                        case (.eventType, .eventType): {
                                guard case let .eventType(l) = lhs, case let .eventType(r) = rhs else { preconditionFailure() }
                                return l == r
                            }()
                        default: false
                        }
                    }
                #endif
            }

            public enum OneOf_Window: Equatable {
                case max(UInt32)
                case count(EventStore_Client_Empty)

                #if !swift(>=4.1)
                    public static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.OneOf_Window, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.OneOf_Window) -> Bool {
                        // The use of inline closures is to circumvent an issue where the compiler
                        // allocates stack space for every case branch when no optimizations are
                        // enabled. https://github.com/apple/swift-protobuf/issues/1034
                        switch (lhs, rhs) {
                        case (.max, .max): {
                                guard case let .max(l) = lhs, case let .max(r) = rhs else { preconditionFailure() }
                                return l == r
                            }()
                        case (.count, .count): {
                                guard case let .count(l) = lhs, case let .count(r) = rhs else { preconditionFailure() }
                                return l == r
                            }()
                        default: false
                        }
                    }
                #endif
            }

            public struct Expression {
                // SwiftProtobuf.Message conformance is added in an extension below. See the
                // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
                // methods supported on all messages.

                public var regex: String = .init()

                public var prefix: [String] = []

                public var unknownFields = SwiftProtobuf.UnknownStorage()

                public init() {}
            }

            public init() {}
        }

        public init() {}
    }

    public struct Position {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var commitPosition: UInt64 = 0

        public var preparePosition: UInt64 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public struct Settings {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var resolveLinks: Bool = false

        public var revision: UInt64 = 0

        public var extraStatistics: Bool = false

        public var maxRetryCount: Int32 = 0

        public var minCheckpointCount: Int32 = 0

        public var maxCheckpointCount: Int32 = 0

        public var maxSubscriberCount: Int32 = 0

        public var liveBufferSize: Int32 = 0

        public var readBatchSize: Int32 = 0

        public var historyBufferSize: Int32 = 0

        public var namedConsumerStrategy: EventStore_Client_PersistentSubscriptions_CreateReq.ConsumerStrategy = .dispatchToSingle

        public var messageTimeout: EventStore_Client_PersistentSubscriptions_CreateReq.Settings.OneOf_MessageTimeout?

        public var messageTimeoutTicks: Int64 {
            get {
                if case let .messageTimeoutTicks(v)? = messageTimeout { return v }
                return 0
            }
            set { messageTimeout = .messageTimeoutTicks(newValue) }
        }

        public var messageTimeoutMs: Int32 {
            get {
                if case let .messageTimeoutMs(v)? = messageTimeout { return v }
                return 0
            }
            set { messageTimeout = .messageTimeoutMs(newValue) }
        }

        public var checkpointAfter: EventStore_Client_PersistentSubscriptions_CreateReq.Settings.OneOf_CheckpointAfter?

        public var checkpointAfterTicks: Int64 {
            get {
                if case let .checkpointAfterTicks(v)? = checkpointAfter { return v }
                return 0
            }
            set { checkpointAfter = .checkpointAfterTicks(newValue) }
        }

        public var checkpointAfterMs: Int32 {
            get {
                if case let .checkpointAfterMs(v)? = checkpointAfter { return v }
                return 0
            }
            set { checkpointAfter = .checkpointAfterMs(newValue) }
        }

        public var consumerStrategy: String = .init()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_MessageTimeout: Equatable {
            case messageTimeoutTicks(Int64)
            case messageTimeoutMs(Int32)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq.Settings.OneOf_MessageTimeout, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.Settings.OneOf_MessageTimeout) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.messageTimeoutTicks, .messageTimeoutTicks): {
                            guard case let .messageTimeoutTicks(l) = lhs, case let .messageTimeoutTicks(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.messageTimeoutMs, .messageTimeoutMs): {
                            guard case let .messageTimeoutMs(l) = lhs, case let .messageTimeoutMs(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public enum OneOf_CheckpointAfter: Equatable {
            case checkpointAfterTicks(Int64)
            case checkpointAfterMs(Int32)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq.Settings.OneOf_CheckpointAfter, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.Settings.OneOf_CheckpointAfter) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.checkpointAfterTicks, .checkpointAfterTicks): {
                            guard case let .checkpointAfterTicks(l) = lhs, case let .checkpointAfterTicks(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.checkpointAfterMs, .checkpointAfterMs): {
                            guard case let .checkpointAfterMs(l) = lhs, case let .checkpointAfterMs(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public init() {}
    }

    public init() {}

    fileprivate var _options: EventStore_Client_PersistentSubscriptions_CreateReq.Options?
}

#if swift(>=4.2)

    extension EventStore_Client_PersistentSubscriptions_CreateReq.ConsumerStrategy: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [EventStore_Client_PersistentSubscriptions_CreateReq.ConsumerStrategy] = [
            .dispatchToSingle,
            .roundRobin,
            .pinned,
        ]
    }

#endif // swift(>=4.2)

public struct EventStore_Client_PersistentSubscriptions_CreateResp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStore_Client_PersistentSubscriptions_UpdateReq {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var options: EventStore_Client_PersistentSubscriptions_UpdateReq.Options {
        get { _options ?? EventStore_Client_PersistentSubscriptions_UpdateReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    public var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    public mutating func clearOptions() { _options = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum ConsumerStrategy: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case dispatchToSingle // = 0
        case roundRobin // = 1
        case pinned // = 2
        case UNRECOGNIZED(Int)

        public init() {
            self = .dispatchToSingle
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .dispatchToSingle
            case 1: self = .roundRobin
            case 2: self = .pinned
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .dispatchToSingle: 0
            case .roundRobin: 1
            case .pinned: 2
            case let .UNRECOGNIZED(i): i
            }
        }
    }

    public struct Options {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var streamOption: OneOf_StreamOption? {
            get { _storage._streamOption }
            set { _uniqueStorage()._streamOption = newValue }
        }

        public var stream: EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions {
            get {
                if case let .stream(v)? = _storage._streamOption { return v }
                return EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions()
            }
            set { _uniqueStorage()._streamOption = .stream(newValue) }
        }

        public var all: EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions {
            get {
                if case let .all(v)? = _storage._streamOption { return v }
                return EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions()
            }
            set { _uniqueStorage()._streamOption = .all(newValue) }
        }

        public var streamIdentifier: EventStore_Client_StreamIdentifier {
            get { _storage._streamIdentifier ?? EventStore_Client_StreamIdentifier() }
            set { _uniqueStorage()._streamIdentifier = newValue }
        }

        /// Returns true if `streamIdentifier` has been explicitly set.
        public var hasStreamIdentifier: Bool { _storage._streamIdentifier != nil }
        /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
        public mutating func clearStreamIdentifier() { _uniqueStorage()._streamIdentifier = nil }

        public var groupName: String {
            get { _storage._groupName }
            set { _uniqueStorage()._groupName = newValue }
        }

        public var settings: EventStore_Client_PersistentSubscriptions_UpdateReq.Settings {
            get { _storage._settings ?? EventStore_Client_PersistentSubscriptions_UpdateReq.Settings() }
            set { _uniqueStorage()._settings = newValue }
        }

        /// Returns true if `settings` has been explicitly set.
        public var hasSettings: Bool { _storage._settings != nil }
        /// Clears the value of `settings`. Subsequent reads from it will return its default value.
        public mutating func clearSettings() { _uniqueStorage()._settings = nil }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_StreamOption: Equatable {
            case stream(EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions)
            case all(EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Options.OneOf_StreamOption, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Options.OneOf_StreamOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.stream, .stream): {
                            guard case let .stream(l) = lhs, case let .stream(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.all, .all): {
                            guard case let .all(l) = lhs, case let .all(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public init() {}

        fileprivate var _storage = _StorageClass.defaultInstance
    }

    public struct StreamOptions {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var streamIdentifier: EventStore_Client_StreamIdentifier {
            get { _streamIdentifier ?? EventStore_Client_StreamIdentifier() }
            set { _streamIdentifier = newValue }
        }

        /// Returns true if `streamIdentifier` has been explicitly set.
        public var hasStreamIdentifier: Bool { _streamIdentifier != nil }
        /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
        public mutating func clearStreamIdentifier() { _streamIdentifier = nil }

        public var revisionOption: EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions.OneOf_RevisionOption?

        public var revision: UInt64 {
            get {
                if case let .revision(v)? = revisionOption { return v }
                return 0
            }
            set { revisionOption = .revision(newValue) }
        }

        public var start: EventStore_Client_Empty {
            get {
                if case let .start(v)? = revisionOption { return v }
                return EventStore_Client_Empty()
            }
            set { revisionOption = .start(newValue) }
        }

        public var end: EventStore_Client_Empty {
            get {
                if case let .end(v)? = revisionOption { return v }
                return EventStore_Client_Empty()
            }
            set { revisionOption = .end(newValue) }
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_RevisionOption: Equatable {
            case revision(UInt64)
            case start(EventStore_Client_Empty)
            case end(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions.OneOf_RevisionOption, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions.OneOf_RevisionOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.revision, .revision): {
                            guard case let .revision(l) = lhs, case let .revision(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.start, .start): {
                            guard case let .start(l) = lhs, case let .start(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.end, .end): {
                            guard case let .end(l) = lhs, case let .end(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public init() {}

        fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier?
    }

    public struct AllOptions {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var allOption: EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions.OneOf_AllOption?

        public var position: EventStore_Client_PersistentSubscriptions_UpdateReq.Position {
            get {
                if case let .position(v)? = allOption { return v }
                return EventStore_Client_PersistentSubscriptions_UpdateReq.Position()
            }
            set { allOption = .position(newValue) }
        }

        public var start: EventStore_Client_Empty {
            get {
                if case let .start(v)? = allOption { return v }
                return EventStore_Client_Empty()
            }
            set { allOption = .start(newValue) }
        }

        public var end: EventStore_Client_Empty {
            get {
                if case let .end(v)? = allOption { return v }
                return EventStore_Client_Empty()
            }
            set { allOption = .end(newValue) }
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_AllOption: Equatable {
            case position(EventStore_Client_PersistentSubscriptions_UpdateReq.Position)
            case start(EventStore_Client_Empty)
            case end(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions.OneOf_AllOption, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions.OneOf_AllOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.position, .position): {
                            guard case let .position(l) = lhs, case let .position(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.start, .start): {
                            guard case let .start(l) = lhs, case let .start(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.end, .end): {
                            guard case let .end(l) = lhs, case let .end(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public init() {}
    }

    public struct Position {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var commitPosition: UInt64 = 0

        public var preparePosition: UInt64 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public struct Settings {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var resolveLinks: Bool = false

        public var revision: UInt64 = 0

        public var extraStatistics: Bool = false

        public var maxRetryCount: Int32 = 0

        public var minCheckpointCount: Int32 = 0

        public var maxCheckpointCount: Int32 = 0

        public var maxSubscriberCount: Int32 = 0

        public var liveBufferSize: Int32 = 0

        public var readBatchSize: Int32 = 0

        public var historyBufferSize: Int32 = 0

        public var namedConsumerStrategy: EventStore_Client_PersistentSubscriptions_UpdateReq.ConsumerStrategy = .dispatchToSingle

        public var messageTimeout: EventStore_Client_PersistentSubscriptions_UpdateReq.Settings.OneOf_MessageTimeout?

        public var messageTimeoutTicks: Int64 {
            get {
                if case let .messageTimeoutTicks(v)? = messageTimeout { return v }
                return 0
            }
            set { messageTimeout = .messageTimeoutTicks(newValue) }
        }

        public var messageTimeoutMs: Int32 {
            get {
                if case let .messageTimeoutMs(v)? = messageTimeout { return v }
                return 0
            }
            set { messageTimeout = .messageTimeoutMs(newValue) }
        }

        public var checkpointAfter: EventStore_Client_PersistentSubscriptions_UpdateReq.Settings.OneOf_CheckpointAfter?

        public var checkpointAfterTicks: Int64 {
            get {
                if case let .checkpointAfterTicks(v)? = checkpointAfter { return v }
                return 0
            }
            set { checkpointAfter = .checkpointAfterTicks(newValue) }
        }

        public var checkpointAfterMs: Int32 {
            get {
                if case let .checkpointAfterMs(v)? = checkpointAfter { return v }
                return 0
            }
            set { checkpointAfter = .checkpointAfterMs(newValue) }
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_MessageTimeout: Equatable {
            case messageTimeoutTicks(Int64)
            case messageTimeoutMs(Int32)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Settings.OneOf_MessageTimeout, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Settings.OneOf_MessageTimeout) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.messageTimeoutTicks, .messageTimeoutTicks): {
                            guard case let .messageTimeoutTicks(l) = lhs, case let .messageTimeoutTicks(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.messageTimeoutMs, .messageTimeoutMs): {
                            guard case let .messageTimeoutMs(l) = lhs, case let .messageTimeoutMs(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public enum OneOf_CheckpointAfter: Equatable {
            case checkpointAfterTicks(Int64)
            case checkpointAfterMs(Int32)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Settings.OneOf_CheckpointAfter, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Settings.OneOf_CheckpointAfter) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.checkpointAfterTicks, .checkpointAfterTicks): {
                            guard case let .checkpointAfterTicks(l) = lhs, case let .checkpointAfterTicks(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.checkpointAfterMs, .checkpointAfterMs): {
                            guard case let .checkpointAfterMs(l) = lhs, case let .checkpointAfterMs(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public init() {}
    }

    public init() {}

    fileprivate var _options: EventStore_Client_PersistentSubscriptions_UpdateReq.Options?
}

#if swift(>=4.2)

    extension EventStore_Client_PersistentSubscriptions_UpdateReq.ConsumerStrategy: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [EventStore_Client_PersistentSubscriptions_UpdateReq.ConsumerStrategy] = [
            .dispatchToSingle,
            .roundRobin,
            .pinned,
        ]
    }

#endif // swift(>=4.2)

public struct EventStore_Client_PersistentSubscriptions_UpdateResp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStore_Client_PersistentSubscriptions_DeleteReq {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var options: EventStore_Client_PersistentSubscriptions_DeleteReq.Options {
        get { _options ?? EventStore_Client_PersistentSubscriptions_DeleteReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    public var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    public mutating func clearOptions() { _options = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Options {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var streamOption: EventStore_Client_PersistentSubscriptions_DeleteReq.Options.OneOf_StreamOption?

        public var streamIdentifier: EventStore_Client_StreamIdentifier {
            get {
                if case let .streamIdentifier(v)? = streamOption { return v }
                return EventStore_Client_StreamIdentifier()
            }
            set { streamOption = .streamIdentifier(newValue) }
        }

        public var all: EventStore_Client_Empty {
            get {
                if case let .all(v)? = streamOption { return v }
                return EventStore_Client_Empty()
            }
            set { streamOption = .all(newValue) }
        }

        public var groupName: String = .init()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_StreamOption: Equatable {
            case streamIdentifier(EventStore_Client_StreamIdentifier)
            case all(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_PersistentSubscriptions_DeleteReq.Options.OneOf_StreamOption, rhs: EventStore_Client_PersistentSubscriptions_DeleteReq.Options.OneOf_StreamOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.streamIdentifier, .streamIdentifier): {
                            guard case let .streamIdentifier(l) = lhs, case let .streamIdentifier(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.all, .all): {
                            guard case let .all(l) = lhs, case let .all(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public init() {}
    }

    public init() {}

    fileprivate var _options: EventStore_Client_PersistentSubscriptions_DeleteReq.Options?
}

public struct EventStore_Client_PersistentSubscriptions_DeleteResp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStore_Client_PersistentSubscriptions_GetInfoReq {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var options: EventStore_Client_PersistentSubscriptions_GetInfoReq.Options {
        get { _options ?? EventStore_Client_PersistentSubscriptions_GetInfoReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    public var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    public mutating func clearOptions() { _options = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Options {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var streamOption: EventStore_Client_PersistentSubscriptions_GetInfoReq.Options.OneOf_StreamOption?

        public var streamIdentifier: EventStore_Client_StreamIdentifier {
            get {
                if case let .streamIdentifier(v)? = streamOption { return v }
                return EventStore_Client_StreamIdentifier()
            }
            set { streamOption = .streamIdentifier(newValue) }
        }

        public var all: EventStore_Client_Empty {
            get {
                if case let .all(v)? = streamOption { return v }
                return EventStore_Client_Empty()
            }
            set { streamOption = .all(newValue) }
        }

        public var groupName: String = .init()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_StreamOption: Equatable {
            case streamIdentifier(EventStore_Client_StreamIdentifier)
            case all(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_PersistentSubscriptions_GetInfoReq.Options.OneOf_StreamOption, rhs: EventStore_Client_PersistentSubscriptions_GetInfoReq.Options.OneOf_StreamOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.streamIdentifier, .streamIdentifier): {
                            guard case let .streamIdentifier(l) = lhs, case let .streamIdentifier(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.all, .all): {
                            guard case let .all(l) = lhs, case let .all(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public init() {}
    }

    public init() {}

    fileprivate var _options: EventStore_Client_PersistentSubscriptions_GetInfoReq.Options?
}

public struct EventStore_Client_PersistentSubscriptions_GetInfoResp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var subscriptionInfo: EventStore_Client_PersistentSubscriptions_SubscriptionInfo {
        get { _subscriptionInfo ?? EventStore_Client_PersistentSubscriptions_SubscriptionInfo() }
        set { _subscriptionInfo = newValue }
    }

    /// Returns true if `subscriptionInfo` has been explicitly set.
    public var hasSubscriptionInfo: Bool { _subscriptionInfo != nil }
    /// Clears the value of `subscriptionInfo`. Subsequent reads from it will return its default value.
    public mutating func clearSubscriptionInfo() { _subscriptionInfo = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    private var _subscriptionInfo: EventStore_Client_PersistentSubscriptions_SubscriptionInfo?
}

public struct EventStore_Client_PersistentSubscriptions_SubscriptionInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var eventSource: String {
        get { _storage._eventSource }
        set { _uniqueStorage()._eventSource = newValue }
    }

    public var groupName: String {
        get { _storage._groupName }
        set { _uniqueStorage()._groupName = newValue }
    }

    public var status: String {
        get { _storage._status }
        set { _uniqueStorage()._status = newValue }
    }

    public var connections: [EventStore_Client_PersistentSubscriptions_SubscriptionInfo.ConnectionInfo] {
        get { _storage._connections }
        set { _uniqueStorage()._connections = newValue }
    }

    public var averagePerSecond: Int32 {
        get { _storage._averagePerSecond }
        set { _uniqueStorage()._averagePerSecond = newValue }
    }

    public var totalItems: Int64 {
        get { _storage._totalItems }
        set { _uniqueStorage()._totalItems = newValue }
    }

    public var countSinceLastMeasurement: Int64 {
        get { _storage._countSinceLastMeasurement }
        set { _uniqueStorage()._countSinceLastMeasurement = newValue }
    }

    public var lastCheckpointedEventPosition: String {
        get { _storage._lastCheckpointedEventPosition }
        set { _uniqueStorage()._lastCheckpointedEventPosition = newValue }
    }

    public var lastKnownEventPosition: String {
        get { _storage._lastKnownEventPosition }
        set { _uniqueStorage()._lastKnownEventPosition = newValue }
    }

    public var resolveLinkTos: Bool {
        get { _storage._resolveLinkTos }
        set { _uniqueStorage()._resolveLinkTos = newValue }
    }

    public var startFrom: String {
        get { _storage._startFrom }
        set { _uniqueStorage()._startFrom = newValue }
    }

    public var messageTimeoutMilliseconds: Int32 {
        get { _storage._messageTimeoutMilliseconds }
        set { _uniqueStorage()._messageTimeoutMilliseconds = newValue }
    }

    public var extraStatistics: Bool {
        get { _storage._extraStatistics }
        set { _uniqueStorage()._extraStatistics = newValue }
    }

    public var maxRetryCount: Int32 {
        get { _storage._maxRetryCount }
        set { _uniqueStorage()._maxRetryCount = newValue }
    }

    public var liveBufferSize: Int32 {
        get { _storage._liveBufferSize }
        set { _uniqueStorage()._liveBufferSize = newValue }
    }

    public var bufferSize: Int32 {
        get { _storage._bufferSize }
        set { _uniqueStorage()._bufferSize = newValue }
    }

    public var readBatchSize: Int32 {
        get { _storage._readBatchSize }
        set { _uniqueStorage()._readBatchSize = newValue }
    }

    public var checkPointAfterMilliseconds: Int32 {
        get { _storage._checkPointAfterMilliseconds }
        set { _uniqueStorage()._checkPointAfterMilliseconds = newValue }
    }

    public var minCheckPointCount: Int32 {
        get { _storage._minCheckPointCount }
        set { _uniqueStorage()._minCheckPointCount = newValue }
    }

    public var maxCheckPointCount: Int32 {
        get { _storage._maxCheckPointCount }
        set { _uniqueStorage()._maxCheckPointCount = newValue }
    }

    public var readBufferCount: Int32 {
        get { _storage._readBufferCount }
        set { _uniqueStorage()._readBufferCount = newValue }
    }

    public var liveBufferCount: Int64 {
        get { _storage._liveBufferCount }
        set { _uniqueStorage()._liveBufferCount = newValue }
    }

    public var retryBufferCount: Int32 {
        get { _storage._retryBufferCount }
        set { _uniqueStorage()._retryBufferCount = newValue }
    }

    public var totalInFlightMessages: Int32 {
        get { _storage._totalInFlightMessages }
        set { _uniqueStorage()._totalInFlightMessages = newValue }
    }

    public var outstandingMessagesCount: Int32 {
        get { _storage._outstandingMessagesCount }
        set { _uniqueStorage()._outstandingMessagesCount = newValue }
    }

    public var namedConsumerStrategy: String {
        get { _storage._namedConsumerStrategy }
        set { _uniqueStorage()._namedConsumerStrategy = newValue }
    }

    public var maxSubscriberCount: Int32 {
        get { _storage._maxSubscriberCount }
        set { _uniqueStorage()._maxSubscriberCount = newValue }
    }

    public var parkedMessageCount: Int64 {
        get { _storage._parkedMessageCount }
        set { _uniqueStorage()._parkedMessageCount = newValue }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct ConnectionInfo {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var from: String = .init()

        public var username: String = .init()

        public var averageItemsPerSecond: Int32 = 0

        public var totalItems: Int64 = 0

        public var countSinceLastMeasurement: Int64 = 0

        public var observedMeasurements: [EventStore_Client_PersistentSubscriptions_SubscriptionInfo.Measurement] = []

        public var availableSlots: Int32 = 0

        public var inFlightMessages: Int32 = 0

        public var connectionName: String = .init()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public struct Measurement {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var key: String = .init()

        public var value: Int64 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

public struct EventStore_Client_PersistentSubscriptions_ReplayParkedReq {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var options: EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options {
        get { _options ?? EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    public var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    public mutating func clearOptions() { _options = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Options {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var groupName: String = .init()

        public var streamOption: EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options.OneOf_StreamOption?

        public var streamIdentifier: EventStore_Client_StreamIdentifier {
            get {
                if case let .streamIdentifier(v)? = streamOption { return v }
                return EventStore_Client_StreamIdentifier()
            }
            set { streamOption = .streamIdentifier(newValue) }
        }

        public var all: EventStore_Client_Empty {
            get {
                if case let .all(v)? = streamOption { return v }
                return EventStore_Client_Empty()
            }
            set { streamOption = .all(newValue) }
        }

        public var stopAtOption: EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options.OneOf_StopAtOption?

        public var stopAt: Int64 {
            get {
                if case let .stopAt(v)? = stopAtOption { return v }
                return 0
            }
            set { stopAtOption = .stopAt(newValue) }
        }

        public var noLimit: EventStore_Client_Empty {
            get {
                if case let .noLimit(v)? = stopAtOption { return v }
                return EventStore_Client_Empty()
            }
            set { stopAtOption = .noLimit(newValue) }
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_StreamOption: Equatable {
            case streamIdentifier(EventStore_Client_StreamIdentifier)
            case all(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options.OneOf_StreamOption, rhs: EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options.OneOf_StreamOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.streamIdentifier, .streamIdentifier): {
                            guard case let .streamIdentifier(l) = lhs, case let .streamIdentifier(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.all, .all): {
                            guard case let .all(l) = lhs, case let .all(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public enum OneOf_StopAtOption: Equatable {
            case stopAt(Int64)
            case noLimit(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options.OneOf_StopAtOption, rhs: EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options.OneOf_StopAtOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.stopAt, .stopAt): {
                            guard case let .stopAt(l) = lhs, case let .stopAt(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.noLimit, .noLimit): {
                            guard case let .noLimit(l) = lhs, case let .noLimit(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public init() {}
    }

    public init() {}

    fileprivate var _options: EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options?
}

public struct EventStore_Client_PersistentSubscriptions_ReplayParkedResp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStore_Client_PersistentSubscriptions_ListReq {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var options: EventStore_Client_PersistentSubscriptions_ListReq.Options {
        get { _options ?? EventStore_Client_PersistentSubscriptions_ListReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    public var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    public mutating func clearOptions() { _options = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Options {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var listOption: EventStore_Client_PersistentSubscriptions_ListReq.Options.OneOf_ListOption?

        public var listAllSubscriptions: EventStore_Client_Empty {
            get {
                if case let .listAllSubscriptions(v)? = listOption { return v }
                return EventStore_Client_Empty()
            }
            set { listOption = .listAllSubscriptions(newValue) }
        }

        public var listForStream: EventStore_Client_PersistentSubscriptions_ListReq.StreamOption {
            get {
                if case let .listForStream(v)? = listOption { return v }
                return EventStore_Client_PersistentSubscriptions_ListReq.StreamOption()
            }
            set { listOption = .listForStream(newValue) }
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_ListOption: Equatable {
            case listAllSubscriptions(EventStore_Client_Empty)
            case listForStream(EventStore_Client_PersistentSubscriptions_ListReq.StreamOption)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_PersistentSubscriptions_ListReq.Options.OneOf_ListOption, rhs: EventStore_Client_PersistentSubscriptions_ListReq.Options.OneOf_ListOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.listAllSubscriptions, .listAllSubscriptions): {
                            guard case let .listAllSubscriptions(l) = lhs, case let .listAllSubscriptions(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.listForStream, .listForStream): {
                            guard case let .listForStream(l) = lhs, case let .listForStream(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public init() {}
    }

    public struct StreamOption {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var streamOption: EventStore_Client_PersistentSubscriptions_ListReq.StreamOption.OneOf_StreamOption?

        public var stream: EventStore_Client_StreamIdentifier {
            get {
                if case let .stream(v)? = streamOption { return v }
                return EventStore_Client_StreamIdentifier()
            }
            set { streamOption = .stream(newValue) }
        }

        public var all: EventStore_Client_Empty {
            get {
                if case let .all(v)? = streamOption { return v }
                return EventStore_Client_Empty()
            }
            set { streamOption = .all(newValue) }
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_StreamOption: Equatable {
            case stream(EventStore_Client_StreamIdentifier)
            case all(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_PersistentSubscriptions_ListReq.StreamOption.OneOf_StreamOption, rhs: EventStore_Client_PersistentSubscriptions_ListReq.StreamOption.OneOf_StreamOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.stream, .stream): {
                            guard case let .stream(l) = lhs, case let .stream(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.all, .all): {
                            guard case let .all(l) = lhs, case let .all(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public init() {}
    }

    public init() {}

    fileprivate var _options: EventStore_Client_PersistentSubscriptions_ListReq.Options?
}

public struct EventStore_Client_PersistentSubscriptions_ListResp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var subscriptions: [EventStore_Client_PersistentSubscriptions_SubscriptionInfo] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
    extension EventStore_Client_PersistentSubscriptions_ReadReq: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ReadReq.OneOf_Content: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ReadReq.Options: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ReadReq.Options.OneOf_StreamOption: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption.OneOf_Content: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ReadReq.Ack: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ReadReq.Nack: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ReadReq.Nack.Action: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ReadResp: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ReadResp.OneOf_Content: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.OneOf_Position: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.OneOf_Count: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ReadResp.SubscriptionConfirmation: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_CreateReq: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_CreateReq.ConsumerStrategy: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_CreateReq.Options: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_CreateReq.Options.OneOf_StreamOption: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions.OneOf_RevisionOption: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.OneOf_AllOption: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.OneOf_FilterOption: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.OneOf_Filter: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.OneOf_Window: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_CreateReq.Position: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_CreateReq.Settings: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_CreateReq.Settings.OneOf_MessageTimeout: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_CreateReq.Settings.OneOf_CheckpointAfter: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_CreateResp: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_UpdateReq: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_UpdateReq.ConsumerStrategy: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_UpdateReq.Options: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_UpdateReq.Options.OneOf_StreamOption: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions.OneOf_RevisionOption: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions.OneOf_AllOption: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_UpdateReq.Position: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_UpdateReq.Settings: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_UpdateReq.Settings.OneOf_MessageTimeout: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_UpdateReq.Settings.OneOf_CheckpointAfter: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_UpdateResp: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_DeleteReq: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_DeleteReq.Options: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_DeleteReq.Options.OneOf_StreamOption: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_DeleteResp: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_GetInfoReq: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_GetInfoReq.Options: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_GetInfoReq.Options.OneOf_StreamOption: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_GetInfoResp: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_SubscriptionInfo: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_SubscriptionInfo.ConnectionInfo: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_SubscriptionInfo.Measurement: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ReplayParkedReq: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options.OneOf_StreamOption: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options.OneOf_StopAtOption: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ReplayParkedResp: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ListReq: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ListReq.Options: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ListReq.Options.OneOf_ListOption: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ListReq.StreamOption: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ListReq.StreamOption.OneOf_StreamOption: @unchecked Sendable {}
    extension EventStore_Client_PersistentSubscriptions_ListResp: @unchecked Sendable {}
#endif // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "event_store.client.persistent_subscriptions"

extension EventStore_Client_PersistentSubscriptions_ReadReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ReadReq"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
        2: .same(proto: "ack"),
        3: .same(proto: "nack"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_PersistentSubscriptions_ReadReq.Options?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .options(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .options(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_PersistentSubscriptions_ReadReq.Ack?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .ack(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .ack(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_PersistentSubscriptions_ReadReq.Nack?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .nack(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .nack(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch content {
        case .options?: try {
                guard case let .options(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .ack?: try {
                guard case let .ack(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .nack?: try {
                guard case let .nack(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadReq, rhs: EventStore_Client_PersistentSubscriptions_ReadReq) -> Bool {
        if lhs.content != rhs.content { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ReadReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReadReq.protoMessageName + ".Options"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        5: .same(proto: "all"),
        2: .standard(proto: "group_name"),
        3: .standard(proto: "buffer_size"),
        4: .standard(proto: "uuid_option"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_StreamIdentifier?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .streamIdentifier(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .streamIdentifier(v)
                    }
                }()
            case 2: try decoder.decodeSingularStringField(value: &groupName)
            case 3: try decoder.decodeSingularInt32Field(value: &bufferSize)
            case 4: try decoder.decodeSingularMessageField(value: &_uuidOption)
            case 5: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .all(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .all(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if case let .streamIdentifier(v)? = streamOption {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !groupName.isEmpty {
            try visitor.visitSingularStringField(value: groupName, fieldNumber: 2)
        }
        if bufferSize != 0 {
            try visitor.visitSingularInt32Field(value: bufferSize, fieldNumber: 3)
        }
        try { if let v = self._uuidOption {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try { if case let .all(v)? = self.streamOption {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadReq.Options, rhs: EventStore_Client_PersistentSubscriptions_ReadReq.Options) -> Bool {
        if lhs.streamOption != rhs.streamOption { return false }
        if lhs.groupName != rhs.groupName { return false }
        if lhs.bufferSize != rhs.bufferSize { return false }
        if lhs._uuidOption != rhs._uuidOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReadReq.Options.protoMessageName + ".UUIDOption"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "structured"),
        2: .same(proto: "string"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .structured(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .structured(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .string(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .string(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch content {
        case .structured?: try {
                guard case let .structured(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .string?: try {
                guard case let .string(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption, rhs: EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption) -> Bool {
        if lhs.content != rhs.content { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ReadReq.Ack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReadReq.protoMessageName + ".Ack"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "ids"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &id)
            case 2: try decoder.decodeRepeatedMessageField(value: &ids)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !id.isEmpty {
            try visitor.visitSingularBytesField(value: id, fieldNumber: 1)
        }
        if !ids.isEmpty {
            try visitor.visitRepeatedMessageField(value: ids, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadReq.Ack, rhs: EventStore_Client_PersistentSubscriptions_ReadReq.Ack) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.ids != rhs.ids { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ReadReq.Nack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReadReq.protoMessageName + ".Nack"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "ids"),
        3: .same(proto: "action"),
        4: .same(proto: "reason"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &id)
            case 2: try decoder.decodeRepeatedMessageField(value: &ids)
            case 3: try decoder.decodeSingularEnumField(value: &action)
            case 4: try decoder.decodeSingularStringField(value: &reason)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !id.isEmpty {
            try visitor.visitSingularBytesField(value: id, fieldNumber: 1)
        }
        if !ids.isEmpty {
            try visitor.visitRepeatedMessageField(value: ids, fieldNumber: 2)
        }
        if action != .unknown {
            try visitor.visitSingularEnumField(value: action, fieldNumber: 3)
        }
        if !reason.isEmpty {
            try visitor.visitSingularStringField(value: reason, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadReq.Nack, rhs: EventStore_Client_PersistentSubscriptions_ReadReq.Nack) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.ids != rhs.ids { return false }
        if lhs.action != rhs.action { return false }
        if lhs.reason != rhs.reason { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ReadReq.Nack.Action: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Unknown"),
        1: .same(proto: "Park"),
        2: .same(proto: "Retry"),
        3: .same(proto: "Skip"),
        4: .same(proto: "Stop"),
    ]
}

extension EventStore_Client_PersistentSubscriptions_ReadResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ReadResp"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "event"),
        2: .standard(proto: "subscription_confirmation"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .event(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .event(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_PersistentSubscriptions_ReadResp.SubscriptionConfirmation?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .subscriptionConfirmation(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .subscriptionConfirmation(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch content {
        case .event?: try {
                guard case let .event(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .subscriptionConfirmation?: try {
                guard case let .subscriptionConfirmation(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadResp, rhs: EventStore_Client_PersistentSubscriptions_ReadResp) -> Bool {
        if lhs.content != rhs.content { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReadResp.protoMessageName + ".ReadEvent"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "event"),
        2: .same(proto: "link"),
        3: .standard(proto: "commit_position"),
        4: .standard(proto: "no_position"),
        5: .standard(proto: "retry_count"),
        6: .standard(proto: "no_retry_count"),
    ]

    fileprivate class _StorageClass {
        var _event: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent?
        var _link: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent?
        var _position: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.OneOf_Position?
        var _count: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.OneOf_Count?

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _event = source._event
            _link = source._link
            _position = source._position
            _count = source._count
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularMessageField(value: &_storage._event)
                case 2: try decoder.decodeSingularMessageField(value: &_storage._link)
                case 3: try {
                        var v: UInt64?
                        try decoder.decodeSingularUInt64Field(value: &v)
                        if let v {
                            if _storage._position != nil { try decoder.handleConflictingOneOf() }
                            _storage._position = .commitPosition(v)
                        }
                    }()
                case 4: try {
                        var v: EventStore_Client_Empty?
                        var hadOneofValue = false
                        if let current = _storage._position {
                            hadOneofValue = true
                            if case let .noPosition(m) = current { v = m }
                        }
                        try decoder.decodeSingularMessageField(value: &v)
                        if let v {
                            if hadOneofValue { try decoder.handleConflictingOneOf() }
                            _storage._position = .noPosition(v)
                        }
                    }()
                case 5: try {
                        var v: Int32?
                        try decoder.decodeSingularInt32Field(value: &v)
                        if let v {
                            if _storage._count != nil { try decoder.handleConflictingOneOf() }
                            _storage._count = .retryCount(v)
                        }
                    }()
                case 6: try {
                        var v: EventStore_Client_Empty?
                        var hadOneofValue = false
                        if let current = _storage._count {
                            hadOneofValue = true
                            if case let .noRetryCount(m) = current { v = m }
                        }
                        try decoder.decodeSingularMessageField(value: &v)
                        if let v {
                            if hadOneofValue { try decoder.handleConflictingOneOf() }
                            _storage._count = .noRetryCount(v)
                        }
                    }()
                default: break
                }
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._event {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            try { if let v = _storage._link {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            } }()
            switch _storage._position {
            case .commitPosition?: try {
                    guard case let .commitPosition(v)? = _storage._position else { preconditionFailure() }
                    try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
                }()
            case .noPosition?: try {
                    guard case let .noPosition(v)? = _storage._position else { preconditionFailure() }
                    try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
                }()
            case nil: break
            }
            switch _storage._count {
            case .retryCount?: try {
                    guard case let .retryCount(v)? = _storage._count else { preconditionFailure() }
                    try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
                }()
            case .noRetryCount?: try {
                    guard case let .noRetryCount(v)? = _storage._count else { preconditionFailure() }
                    try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
                }()
            case nil: break
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent, rhs: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._event != rhs_storage._event { return false }
                if _storage._link != rhs_storage._link { return false }
                if _storage._position != rhs_storage._position { return false }
                if _storage._count != rhs_storage._count { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.protoMessageName + ".RecordedEvent"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .standard(proto: "stream_identifier"),
        3: .standard(proto: "stream_revision"),
        4: .standard(proto: "prepare_position"),
        5: .standard(proto: "commit_position"),
        6: .same(proto: "metadata"),
        7: .standard(proto: "custom_metadata"),
        8: .same(proto: "data"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_id)
            case 2: try decoder.decodeSingularMessageField(value: &_streamIdentifier)
            case 3: try decoder.decodeSingularUInt64Field(value: &streamRevision)
            case 4: try decoder.decodeSingularUInt64Field(value: &preparePosition)
            case 5: try decoder.decodeSingularUInt64Field(value: &commitPosition)
            case 6: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: &metadata)
            case 7: try decoder.decodeSingularBytesField(value: &customMetadata)
            case 8: try decoder.decodeSingularBytesField(value: &data)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _id {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try { if let v = self._streamIdentifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if streamRevision != 0 {
            try visitor.visitSingularUInt64Field(value: streamRevision, fieldNumber: 3)
        }
        if preparePosition != 0 {
            try visitor.visitSingularUInt64Field(value: preparePosition, fieldNumber: 4)
        }
        if commitPosition != 0 {
            try visitor.visitSingularUInt64Field(value: commitPosition, fieldNumber: 5)
        }
        if !metadata.isEmpty {
            try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: metadata, fieldNumber: 6)
        }
        if !customMetadata.isEmpty {
            try visitor.visitSingularBytesField(value: customMetadata, fieldNumber: 7)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent, rhs: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent) -> Bool {
        if lhs._id != rhs._id { return false }
        if lhs._streamIdentifier != rhs._streamIdentifier { return false }
        if lhs.streamRevision != rhs.streamRevision { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.metadata != rhs.metadata { return false }
        if lhs.customMetadata != rhs.customMetadata { return false }
        if lhs.data != rhs.data { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ReadResp.SubscriptionConfirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReadResp.protoMessageName + ".SubscriptionConfirmation"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "subscription_id"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &subscriptionID)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !subscriptionID.isEmpty {
            try visitor.visitSingularStringField(value: subscriptionID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_ReadResp.SubscriptionConfirmation, rhs: EventStore_Client_PersistentSubscriptions_ReadResp.SubscriptionConfirmation) -> Bool {
        if lhs.subscriptionID != rhs.subscriptionID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateReq"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq, rhs: EventStore_Client_PersistentSubscriptions_CreateReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.ConsumerStrategy: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "DispatchToSingle"),
        1: .same(proto: "RoundRobin"),
        2: .same(proto: "Pinned"),
    ]
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_CreateReq.protoMessageName + ".Options"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        4: .same(proto: "stream"),
        5: .same(proto: "all"),
        1: .standard(proto: "stream_identifier"),
        2: .standard(proto: "group_name"),
        3: .same(proto: "settings"),
    ]

    fileprivate class _StorageClass {
        var _streamOption: EventStore_Client_PersistentSubscriptions_CreateReq.Options.OneOf_StreamOption?
        var _streamIdentifier: EventStore_Client_StreamIdentifier?
        var _groupName: String = .init()
        var _settings: EventStore_Client_PersistentSubscriptions_CreateReq.Settings?

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _streamOption = source._streamOption
            _streamIdentifier = source._streamIdentifier
            _groupName = source._groupName
            _settings = source._settings
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularMessageField(value: &_storage._streamIdentifier)
                case 2: try decoder.decodeSingularStringField(value: &_storage._groupName)
                case 3: try decoder.decodeSingularMessageField(value: &_storage._settings)
                case 4: try {
                        var v: EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions?
                        var hadOneofValue = false
                        if let current = _storage._streamOption {
                            hadOneofValue = true
                            if case let .stream(m) = current { v = m }
                        }
                        try decoder.decodeSingularMessageField(value: &v)
                        if let v {
                            if hadOneofValue { try decoder.handleConflictingOneOf() }
                            _storage._streamOption = .stream(v)
                        }
                    }()
                case 5: try {
                        var v: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions?
                        var hadOneofValue = false
                        if let current = _storage._streamOption {
                            hadOneofValue = true
                            if case let .all(m) = current { v = m }
                        }
                        try decoder.decodeSingularMessageField(value: &v)
                        if let v {
                            if hadOneofValue { try decoder.handleConflictingOneOf() }
                            _storage._streamOption = .all(v)
                        }
                    }()
                default: break
                }
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._streamIdentifier {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            if !_storage._groupName.isEmpty {
                try visitor.visitSingularStringField(value: _storage._groupName, fieldNumber: 2)
            }
            try { if let v = _storage._settings {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            } }()
            switch _storage._streamOption {
            case .stream?: try {
                    guard case let .stream(v)? = _storage._streamOption else { preconditionFailure() }
                    try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
                }()
            case .all?: try {
                    guard case let .all(v)? = _storage._streamOption else { preconditionFailure() }
                    try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
                }()
            case nil: break
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq.Options, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.Options) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._streamOption != rhs_storage._streamOption { return false }
                if _storage._streamIdentifier != rhs_storage._streamIdentifier { return false }
                if _storage._groupName != rhs_storage._groupName { return false }
                if _storage._settings != rhs_storage._settings { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_CreateReq.protoMessageName + ".StreamOptions"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        2: .same(proto: "revision"),
        3: .same(proto: "start"),
        4: .same(proto: "end"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_streamIdentifier)
            case 2: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.revisionOption != nil { try decoder.handleConflictingOneOf() }
                        self.revisionOption = .revision(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.revisionOption {
                        hadOneofValue = true
                        if case let .start(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.revisionOption = .start(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.revisionOption {
                        hadOneofValue = true
                        if case let .end(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.revisionOption = .end(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _streamIdentifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        switch revisionOption {
        case .revision?: try {
                guard case let .revision(v)? = self.revisionOption else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
            }()
        case .start?: try {
                guard case let .start(v)? = self.revisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .end?: try {
                guard case let .end(v)? = self.revisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions) -> Bool {
        if lhs._streamIdentifier != rhs._streamIdentifier { return false }
        if lhs.revisionOption != rhs.revisionOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_CreateReq.protoMessageName + ".AllOptions"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "position"),
        2: .same(proto: "start"),
        3: .same(proto: "end"),
        4: .same(proto: "filter"),
        5: .standard(proto: "no_filter"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_PersistentSubscriptions_CreateReq.Position?
                    var hadOneofValue = false
                    if let current = self.allOption {
                        hadOneofValue = true
                        if case let .position(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.allOption = .position(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.allOption {
                        hadOneofValue = true
                        if case let .start(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.allOption = .start(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.allOption {
                        hadOneofValue = true
                        if case let .end(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.allOption = .end(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions?
                    var hadOneofValue = false
                    if let current = self.filterOption {
                        hadOneofValue = true
                        if case let .filter(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.filterOption = .filter(v)
                    }
                }()
            case 5: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.filterOption {
                        hadOneofValue = true
                        if case let .noFilter(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.filterOption = .noFilter(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch allOption {
        case .position?: try {
                guard case let .position(v)? = self.allOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .start?: try {
                guard case let .start(v)? = self.allOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .end?: try {
                guard case let .end(v)? = self.allOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        switch filterOption {
        case .filter?: try {
                guard case let .filter(v)? = self.filterOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .noFilter?: try {
                guard case let .noFilter(v)? = self.filterOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions) -> Bool {
        if lhs.allOption != rhs.allOption { return false }
        if lhs.filterOption != rhs.filterOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.protoMessageName + ".FilterOptions"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        2: .standard(proto: "event_type"),
        3: .same(proto: "max"),
        4: .same(proto: "count"),
        5: .same(proto: "checkpointIntervalMultiplier"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression?
                    var hadOneofValue = false
                    if let current = self.filter {
                        hadOneofValue = true
                        if case let .streamIdentifier(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.filter = .streamIdentifier(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression?
                    var hadOneofValue = false
                    if let current = self.filter {
                        hadOneofValue = true
                        if case let .eventType(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.filter = .eventType(v)
                    }
                }()
            case 3: try {
                    var v: UInt32?
                    try decoder.decodeSingularUInt32Field(value: &v)
                    if let v {
                        if self.window != nil { try decoder.handleConflictingOneOf() }
                        self.window = .max(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.window {
                        hadOneofValue = true
                        if case let .count(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.window = .count(v)
                    }
                }()
            case 5: try decoder.decodeSingularUInt32Field(value: &checkpointIntervalMultiplier)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch filter {
        case .streamIdentifier?: try {
                guard case let .streamIdentifier(v)? = self.filter else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .eventType?: try {
                guard case let .eventType(v)? = self.filter else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        switch window {
        case .max?: try {
                guard case let .max(v)? = self.window else { preconditionFailure() }
                try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
            }()
        case .count?: try {
                guard case let .count(v)? = self.window else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case nil: break
        }
        if checkpointIntervalMultiplier != 0 {
            try visitor.visitSingularUInt32Field(value: checkpointIntervalMultiplier, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions) -> Bool {
        if lhs.filter != rhs.filter { return false }
        if lhs.window != rhs.window { return false }
        if lhs.checkpointIntervalMultiplier != rhs.checkpointIntervalMultiplier { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.protoMessageName + ".Expression"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "regex"),
        2: .same(proto: "prefix"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &regex)
            case 2: try decoder.decodeRepeatedStringField(value: &prefix)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !regex.isEmpty {
            try visitor.visitSingularStringField(value: regex, fieldNumber: 1)
        }
        if !prefix.isEmpty {
            try visitor.visitRepeatedStringField(value: prefix, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression) -> Bool {
        if lhs.regex != rhs.regex { return false }
        if lhs.prefix != rhs.prefix { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_CreateReq.protoMessageName + ".Position"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "commit_position"),
        2: .standard(proto: "prepare_position"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt64Field(value: &commitPosition)
            case 2: try decoder.decodeSingularUInt64Field(value: &preparePosition)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if commitPosition != 0 {
            try visitor.visitSingularUInt64Field(value: commitPosition, fieldNumber: 1)
        }
        if preparePosition != 0 {
            try visitor.visitSingularUInt64Field(value: preparePosition, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq.Position, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.Position) -> Bool {
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.Settings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_CreateReq.protoMessageName + ".Settings"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "resolve_links"),
        2: .same(proto: "revision"),
        3: .standard(proto: "extra_statistics"),
        5: .standard(proto: "max_retry_count"),
        7: .standard(proto: "min_checkpoint_count"),
        8: .standard(proto: "max_checkpoint_count"),
        9: .standard(proto: "max_subscriber_count"),
        10: .standard(proto: "live_buffer_size"),
        11: .standard(proto: "read_batch_size"),
        12: .standard(proto: "history_buffer_size"),
        13: .standard(proto: "named_consumer_strategy"),
        4: .standard(proto: "message_timeout_ticks"),
        14: .standard(proto: "message_timeout_ms"),
        6: .standard(proto: "checkpoint_after_ticks"),
        15: .standard(proto: "checkpoint_after_ms"),
        16: .standard(proto: "consumer_strategy"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &resolveLinks)
            case 2: try decoder.decodeSingularUInt64Field(value: &revision)
            case 3: try decoder.decodeSingularBoolField(value: &extraStatistics)
            case 4: try {
                    var v: Int64?
                    try decoder.decodeSingularInt64Field(value: &v)
                    if let v {
                        if self.messageTimeout != nil { try decoder.handleConflictingOneOf() }
                        self.messageTimeout = .messageTimeoutTicks(v)
                    }
                }()
            case 5: try decoder.decodeSingularInt32Field(value: &maxRetryCount)
            case 6: try {
                    var v: Int64?
                    try decoder.decodeSingularInt64Field(value: &v)
                    if let v {
                        if self.checkpointAfter != nil { try decoder.handleConflictingOneOf() }
                        self.checkpointAfter = .checkpointAfterTicks(v)
                    }
                }()
            case 7: try decoder.decodeSingularInt32Field(value: &minCheckpointCount)
            case 8: try decoder.decodeSingularInt32Field(value: &maxCheckpointCount)
            case 9: try decoder.decodeSingularInt32Field(value: &maxSubscriberCount)
            case 10: try decoder.decodeSingularInt32Field(value: &liveBufferSize)
            case 11: try decoder.decodeSingularInt32Field(value: &readBatchSize)
            case 12: try decoder.decodeSingularInt32Field(value: &historyBufferSize)
            case 13: try decoder.decodeSingularEnumField(value: &namedConsumerStrategy)
            case 14: try {
                    var v: Int32?
                    try decoder.decodeSingularInt32Field(value: &v)
                    if let v {
                        if self.messageTimeout != nil { try decoder.handleConflictingOneOf() }
                        self.messageTimeout = .messageTimeoutMs(v)
                    }
                }()
            case 15: try {
                    var v: Int32?
                    try decoder.decodeSingularInt32Field(value: &v)
                    if let v {
                        if self.checkpointAfter != nil { try decoder.handleConflictingOneOf() }
                        self.checkpointAfter = .checkpointAfterMs(v)
                    }
                }()
            case 16: try decoder.decodeSingularStringField(value: &consumerStrategy)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if resolveLinks != false {
            try visitor.visitSingularBoolField(value: resolveLinks, fieldNumber: 1)
        }
        if revision != 0 {
            try visitor.visitSingularUInt64Field(value: revision, fieldNumber: 2)
        }
        if extraStatistics != false {
            try visitor.visitSingularBoolField(value: extraStatistics, fieldNumber: 3)
        }
        try { if case let .messageTimeoutTicks(v)? = self.messageTimeout {
            try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
        } }()
        if maxRetryCount != 0 {
            try visitor.visitSingularInt32Field(value: maxRetryCount, fieldNumber: 5)
        }
        try { if case let .checkpointAfterTicks(v)? = self.checkpointAfter {
            try visitor.visitSingularInt64Field(value: v, fieldNumber: 6)
        } }()
        if minCheckpointCount != 0 {
            try visitor.visitSingularInt32Field(value: minCheckpointCount, fieldNumber: 7)
        }
        if maxCheckpointCount != 0 {
            try visitor.visitSingularInt32Field(value: maxCheckpointCount, fieldNumber: 8)
        }
        if maxSubscriberCount != 0 {
            try visitor.visitSingularInt32Field(value: maxSubscriberCount, fieldNumber: 9)
        }
        if liveBufferSize != 0 {
            try visitor.visitSingularInt32Field(value: liveBufferSize, fieldNumber: 10)
        }
        if readBatchSize != 0 {
            try visitor.visitSingularInt32Field(value: readBatchSize, fieldNumber: 11)
        }
        if historyBufferSize != 0 {
            try visitor.visitSingularInt32Field(value: historyBufferSize, fieldNumber: 12)
        }
        if namedConsumerStrategy != .dispatchToSingle {
            try visitor.visitSingularEnumField(value: namedConsumerStrategy, fieldNumber: 13)
        }
        try { if case let .messageTimeoutMs(v)? = self.messageTimeout {
            try visitor.visitSingularInt32Field(value: v, fieldNumber: 14)
        } }()
        try { if case let .checkpointAfterMs(v)? = self.checkpointAfter {
            try visitor.visitSingularInt32Field(value: v, fieldNumber: 15)
        } }()
        if !consumerStrategy.isEmpty {
            try visitor.visitSingularStringField(value: consumerStrategy, fieldNumber: 16)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateReq.Settings, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.Settings) -> Bool {
        if lhs.resolveLinks != rhs.resolveLinks { return false }
        if lhs.revision != rhs.revision { return false }
        if lhs.extraStatistics != rhs.extraStatistics { return false }
        if lhs.maxRetryCount != rhs.maxRetryCount { return false }
        if lhs.minCheckpointCount != rhs.minCheckpointCount { return false }
        if lhs.maxCheckpointCount != rhs.maxCheckpointCount { return false }
        if lhs.maxSubscriberCount != rhs.maxSubscriberCount { return false }
        if lhs.liveBufferSize != rhs.liveBufferSize { return false }
        if lhs.readBatchSize != rhs.readBatchSize { return false }
        if lhs.historyBufferSize != rhs.historyBufferSize { return false }
        if lhs.namedConsumerStrategy != rhs.namedConsumerStrategy { return false }
        if lhs.messageTimeout != rhs.messageTimeout { return false }
        if lhs.checkpointAfter != rhs.checkpointAfter { return false }
        if lhs.consumerStrategy != rhs.consumerStrategy { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_CreateResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateResp"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_CreateResp, rhs: EventStore_Client_PersistentSubscriptions_CreateResp) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_UpdateReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".UpdateReq"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_UpdateReq, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_UpdateReq.ConsumerStrategy: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "DispatchToSingle"),
        1: .same(proto: "RoundRobin"),
        2: .same(proto: "Pinned"),
    ]
}

extension EventStore_Client_PersistentSubscriptions_UpdateReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_UpdateReq.protoMessageName + ".Options"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        4: .same(proto: "stream"),
        5: .same(proto: "all"),
        1: .standard(proto: "stream_identifier"),
        2: .standard(proto: "group_name"),
        3: .same(proto: "settings"),
    ]

    fileprivate class _StorageClass {
        var _streamOption: EventStore_Client_PersistentSubscriptions_UpdateReq.Options.OneOf_StreamOption?
        var _streamIdentifier: EventStore_Client_StreamIdentifier?
        var _groupName: String = .init()
        var _settings: EventStore_Client_PersistentSubscriptions_UpdateReq.Settings?

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _streamOption = source._streamOption
            _streamIdentifier = source._streamIdentifier
            _groupName = source._groupName
            _settings = source._settings
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularMessageField(value: &_storage._streamIdentifier)
                case 2: try decoder.decodeSingularStringField(value: &_storage._groupName)
                case 3: try decoder.decodeSingularMessageField(value: &_storage._settings)
                case 4: try {
                        var v: EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions?
                        var hadOneofValue = false
                        if let current = _storage._streamOption {
                            hadOneofValue = true
                            if case let .stream(m) = current { v = m }
                        }
                        try decoder.decodeSingularMessageField(value: &v)
                        if let v {
                            if hadOneofValue { try decoder.handleConflictingOneOf() }
                            _storage._streamOption = .stream(v)
                        }
                    }()
                case 5: try {
                        var v: EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions?
                        var hadOneofValue = false
                        if let current = _storage._streamOption {
                            hadOneofValue = true
                            if case let .all(m) = current { v = m }
                        }
                        try decoder.decodeSingularMessageField(value: &v)
                        if let v {
                            if hadOneofValue { try decoder.handleConflictingOneOf() }
                            _storage._streamOption = .all(v)
                        }
                    }()
                default: break
                }
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._streamIdentifier {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            if !_storage._groupName.isEmpty {
                try visitor.visitSingularStringField(value: _storage._groupName, fieldNumber: 2)
            }
            try { if let v = _storage._settings {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            } }()
            switch _storage._streamOption {
            case .stream?: try {
                    guard case let .stream(v)? = _storage._streamOption else { preconditionFailure() }
                    try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
                }()
            case .all?: try {
                    guard case let .all(v)? = _storage._streamOption else { preconditionFailure() }
                    try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
                }()
            case nil: break
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Options, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Options) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._streamOption != rhs_storage._streamOption { return false }
                if _storage._streamIdentifier != rhs_storage._streamIdentifier { return false }
                if _storage._groupName != rhs_storage._groupName { return false }
                if _storage._settings != rhs_storage._settings { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_UpdateReq.protoMessageName + ".StreamOptions"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        2: .same(proto: "revision"),
        3: .same(proto: "start"),
        4: .same(proto: "end"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_streamIdentifier)
            case 2: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.revisionOption != nil { try decoder.handleConflictingOneOf() }
                        self.revisionOption = .revision(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.revisionOption {
                        hadOneofValue = true
                        if case let .start(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.revisionOption = .start(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.revisionOption {
                        hadOneofValue = true
                        if case let .end(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.revisionOption = .end(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _streamIdentifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        switch revisionOption {
        case .revision?: try {
                guard case let .revision(v)? = self.revisionOption else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
            }()
        case .start?: try {
                guard case let .start(v)? = self.revisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .end?: try {
                guard case let .end(v)? = self.revisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions) -> Bool {
        if lhs._streamIdentifier != rhs._streamIdentifier { return false }
        if lhs.revisionOption != rhs.revisionOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_UpdateReq.protoMessageName + ".AllOptions"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "position"),
        2: .same(proto: "start"),
        3: .same(proto: "end"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_PersistentSubscriptions_UpdateReq.Position?
                    var hadOneofValue = false
                    if let current = self.allOption {
                        hadOneofValue = true
                        if case let .position(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.allOption = .position(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.allOption {
                        hadOneofValue = true
                        if case let .start(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.allOption = .start(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.allOption {
                        hadOneofValue = true
                        if case let .end(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.allOption = .end(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch allOption {
        case .position?: try {
                guard case let .position(v)? = self.allOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .start?: try {
                guard case let .start(v)? = self.allOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .end?: try {
                guard case let .end(v)? = self.allOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions) -> Bool {
        if lhs.allOption != rhs.allOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_UpdateReq.Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_UpdateReq.protoMessageName + ".Position"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "commit_position"),
        2: .standard(proto: "prepare_position"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt64Field(value: &commitPosition)
            case 2: try decoder.decodeSingularUInt64Field(value: &preparePosition)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if commitPosition != 0 {
            try visitor.visitSingularUInt64Field(value: commitPosition, fieldNumber: 1)
        }
        if preparePosition != 0 {
            try visitor.visitSingularUInt64Field(value: preparePosition, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Position, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Position) -> Bool {
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_UpdateReq.Settings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_UpdateReq.protoMessageName + ".Settings"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "resolve_links"),
        2: .same(proto: "revision"),
        3: .standard(proto: "extra_statistics"),
        5: .standard(proto: "max_retry_count"),
        7: .standard(proto: "min_checkpoint_count"),
        8: .standard(proto: "max_checkpoint_count"),
        9: .standard(proto: "max_subscriber_count"),
        10: .standard(proto: "live_buffer_size"),
        11: .standard(proto: "read_batch_size"),
        12: .standard(proto: "history_buffer_size"),
        13: .standard(proto: "named_consumer_strategy"),
        4: .standard(proto: "message_timeout_ticks"),
        14: .standard(proto: "message_timeout_ms"),
        6: .standard(proto: "checkpoint_after_ticks"),
        15: .standard(proto: "checkpoint_after_ms"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &resolveLinks)
            case 2: try decoder.decodeSingularUInt64Field(value: &revision)
            case 3: try decoder.decodeSingularBoolField(value: &extraStatistics)
            case 4: try {
                    var v: Int64?
                    try decoder.decodeSingularInt64Field(value: &v)
                    if let v {
                        if self.messageTimeout != nil { try decoder.handleConflictingOneOf() }
                        self.messageTimeout = .messageTimeoutTicks(v)
                    }
                }()
            case 5: try decoder.decodeSingularInt32Field(value: &maxRetryCount)
            case 6: try {
                    var v: Int64?
                    try decoder.decodeSingularInt64Field(value: &v)
                    if let v {
                        if self.checkpointAfter != nil { try decoder.handleConflictingOneOf() }
                        self.checkpointAfter = .checkpointAfterTicks(v)
                    }
                }()
            case 7: try decoder.decodeSingularInt32Field(value: &minCheckpointCount)
            case 8: try decoder.decodeSingularInt32Field(value: &maxCheckpointCount)
            case 9: try decoder.decodeSingularInt32Field(value: &maxSubscriberCount)
            case 10: try decoder.decodeSingularInt32Field(value: &liveBufferSize)
            case 11: try decoder.decodeSingularInt32Field(value: &readBatchSize)
            case 12: try decoder.decodeSingularInt32Field(value: &historyBufferSize)
            case 13: try decoder.decodeSingularEnumField(value: &namedConsumerStrategy)
            case 14: try {
                    var v: Int32?
                    try decoder.decodeSingularInt32Field(value: &v)
                    if let v {
                        if self.messageTimeout != nil { try decoder.handleConflictingOneOf() }
                        self.messageTimeout = .messageTimeoutMs(v)
                    }
                }()
            case 15: try {
                    var v: Int32?
                    try decoder.decodeSingularInt32Field(value: &v)
                    if let v {
                        if self.checkpointAfter != nil { try decoder.handleConflictingOneOf() }
                        self.checkpointAfter = .checkpointAfterMs(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if resolveLinks != false {
            try visitor.visitSingularBoolField(value: resolveLinks, fieldNumber: 1)
        }
        if revision != 0 {
            try visitor.visitSingularUInt64Field(value: revision, fieldNumber: 2)
        }
        if extraStatistics != false {
            try visitor.visitSingularBoolField(value: extraStatistics, fieldNumber: 3)
        }
        try { if case let .messageTimeoutTicks(v)? = self.messageTimeout {
            try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
        } }()
        if maxRetryCount != 0 {
            try visitor.visitSingularInt32Field(value: maxRetryCount, fieldNumber: 5)
        }
        try { if case let .checkpointAfterTicks(v)? = self.checkpointAfter {
            try visitor.visitSingularInt64Field(value: v, fieldNumber: 6)
        } }()
        if minCheckpointCount != 0 {
            try visitor.visitSingularInt32Field(value: minCheckpointCount, fieldNumber: 7)
        }
        if maxCheckpointCount != 0 {
            try visitor.visitSingularInt32Field(value: maxCheckpointCount, fieldNumber: 8)
        }
        if maxSubscriberCount != 0 {
            try visitor.visitSingularInt32Field(value: maxSubscriberCount, fieldNumber: 9)
        }
        if liveBufferSize != 0 {
            try visitor.visitSingularInt32Field(value: liveBufferSize, fieldNumber: 10)
        }
        if readBatchSize != 0 {
            try visitor.visitSingularInt32Field(value: readBatchSize, fieldNumber: 11)
        }
        if historyBufferSize != 0 {
            try visitor.visitSingularInt32Field(value: historyBufferSize, fieldNumber: 12)
        }
        if namedConsumerStrategy != .dispatchToSingle {
            try visitor.visitSingularEnumField(value: namedConsumerStrategy, fieldNumber: 13)
        }
        try { if case let .messageTimeoutMs(v)? = self.messageTimeout {
            try visitor.visitSingularInt32Field(value: v, fieldNumber: 14)
        } }()
        try { if case let .checkpointAfterMs(v)? = self.checkpointAfter {
            try visitor.visitSingularInt32Field(value: v, fieldNumber: 15)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Settings, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Settings) -> Bool {
        if lhs.resolveLinks != rhs.resolveLinks { return false }
        if lhs.revision != rhs.revision { return false }
        if lhs.extraStatistics != rhs.extraStatistics { return false }
        if lhs.maxRetryCount != rhs.maxRetryCount { return false }
        if lhs.minCheckpointCount != rhs.minCheckpointCount { return false }
        if lhs.maxCheckpointCount != rhs.maxCheckpointCount { return false }
        if lhs.maxSubscriberCount != rhs.maxSubscriberCount { return false }
        if lhs.liveBufferSize != rhs.liveBufferSize { return false }
        if lhs.readBatchSize != rhs.readBatchSize { return false }
        if lhs.historyBufferSize != rhs.historyBufferSize { return false }
        if lhs.namedConsumerStrategy != rhs.namedConsumerStrategy { return false }
        if lhs.messageTimeout != rhs.messageTimeout { return false }
        if lhs.checkpointAfter != rhs.checkpointAfter { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_UpdateResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".UpdateResp"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_UpdateResp, rhs: EventStore_Client_PersistentSubscriptions_UpdateResp) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_DeleteReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DeleteReq"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_DeleteReq, rhs: EventStore_Client_PersistentSubscriptions_DeleteReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_DeleteReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_DeleteReq.protoMessageName + ".Options"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        3: .same(proto: "all"),
        2: .standard(proto: "group_name"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_StreamIdentifier?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .streamIdentifier(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .streamIdentifier(v)
                    }
                }()
            case 2: try decoder.decodeSingularStringField(value: &groupName)
            case 3: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .all(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .all(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if case let .streamIdentifier(v)? = streamOption {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !groupName.isEmpty {
            try visitor.visitSingularStringField(value: groupName, fieldNumber: 2)
        }
        try { if case let .all(v)? = self.streamOption {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_DeleteReq.Options, rhs: EventStore_Client_PersistentSubscriptions_DeleteReq.Options) -> Bool {
        if lhs.streamOption != rhs.streamOption { return false }
        if lhs.groupName != rhs.groupName { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_DeleteResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DeleteResp"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_DeleteResp, rhs: EventStore_Client_PersistentSubscriptions_DeleteResp) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_GetInfoReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetInfoReq"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_GetInfoReq, rhs: EventStore_Client_PersistentSubscriptions_GetInfoReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_GetInfoReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_GetInfoReq.protoMessageName + ".Options"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        2: .same(proto: "all"),
        3: .standard(proto: "group_name"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_StreamIdentifier?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .streamIdentifier(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .streamIdentifier(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .all(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .all(v)
                    }
                }()
            case 3: try decoder.decodeSingularStringField(value: &groupName)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch streamOption {
        case .streamIdentifier?: try {
                guard case let .streamIdentifier(v)? = self.streamOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .all?: try {
                guard case let .all(v)? = self.streamOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        if !groupName.isEmpty {
            try visitor.visitSingularStringField(value: groupName, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_GetInfoReq.Options, rhs: EventStore_Client_PersistentSubscriptions_GetInfoReq.Options) -> Bool {
        if lhs.streamOption != rhs.streamOption { return false }
        if lhs.groupName != rhs.groupName { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_GetInfoResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetInfoResp"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "subscription_info"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_subscriptionInfo)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _subscriptionInfo {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_GetInfoResp, rhs: EventStore_Client_PersistentSubscriptions_GetInfoResp) -> Bool {
        if lhs._subscriptionInfo != rhs._subscriptionInfo { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_SubscriptionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".SubscriptionInfo"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "event_source"),
        2: .standard(proto: "group_name"),
        3: .same(proto: "status"),
        4: .same(proto: "connections"),
        5: .standard(proto: "average_per_second"),
        6: .standard(proto: "total_items"),
        7: .standard(proto: "count_since_last_measurement"),
        8: .standard(proto: "last_checkpointed_event_position"),
        9: .standard(proto: "last_known_event_position"),
        10: .standard(proto: "resolve_link_tos"),
        11: .standard(proto: "start_from"),
        12: .standard(proto: "message_timeout_milliseconds"),
        13: .standard(proto: "extra_statistics"),
        14: .standard(proto: "max_retry_count"),
        15: .standard(proto: "live_buffer_size"),
        16: .standard(proto: "buffer_size"),
        17: .standard(proto: "read_batch_size"),
        18: .standard(proto: "check_point_after_milliseconds"),
        19: .standard(proto: "min_check_point_count"),
        20: .standard(proto: "max_check_point_count"),
        21: .standard(proto: "read_buffer_count"),
        22: .standard(proto: "live_buffer_count"),
        23: .standard(proto: "retry_buffer_count"),
        24: .standard(proto: "total_in_flight_messages"),
        25: .standard(proto: "outstanding_messages_count"),
        26: .standard(proto: "named_consumer_strategy"),
        27: .standard(proto: "max_subscriber_count"),
        28: .standard(proto: "parked_message_count"),
    ]

    fileprivate class _StorageClass {
        var _eventSource: String = .init()
        var _groupName: String = .init()
        var _status: String = .init()
        var _connections: [EventStore_Client_PersistentSubscriptions_SubscriptionInfo.ConnectionInfo] = []
        var _averagePerSecond: Int32 = 0
        var _totalItems: Int64 = 0
        var _countSinceLastMeasurement: Int64 = 0
        var _lastCheckpointedEventPosition: String = .init()
        var _lastKnownEventPosition: String = .init()
        var _resolveLinkTos: Bool = false
        var _startFrom: String = .init()
        var _messageTimeoutMilliseconds: Int32 = 0
        var _extraStatistics: Bool = false
        var _maxRetryCount: Int32 = 0
        var _liveBufferSize: Int32 = 0
        var _bufferSize: Int32 = 0
        var _readBatchSize: Int32 = 0
        var _checkPointAfterMilliseconds: Int32 = 0
        var _minCheckPointCount: Int32 = 0
        var _maxCheckPointCount: Int32 = 0
        var _readBufferCount: Int32 = 0
        var _liveBufferCount: Int64 = 0
        var _retryBufferCount: Int32 = 0
        var _totalInFlightMessages: Int32 = 0
        var _outstandingMessagesCount: Int32 = 0
        var _namedConsumerStrategy: String = .init()
        var _maxSubscriberCount: Int32 = 0
        var _parkedMessageCount: Int64 = 0

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _eventSource = source._eventSource
            _groupName = source._groupName
            _status = source._status
            _connections = source._connections
            _averagePerSecond = source._averagePerSecond
            _totalItems = source._totalItems
            _countSinceLastMeasurement = source._countSinceLastMeasurement
            _lastCheckpointedEventPosition = source._lastCheckpointedEventPosition
            _lastKnownEventPosition = source._lastKnownEventPosition
            _resolveLinkTos = source._resolveLinkTos
            _startFrom = source._startFrom
            _messageTimeoutMilliseconds = source._messageTimeoutMilliseconds
            _extraStatistics = source._extraStatistics
            _maxRetryCount = source._maxRetryCount
            _liveBufferSize = source._liveBufferSize
            _bufferSize = source._bufferSize
            _readBatchSize = source._readBatchSize
            _checkPointAfterMilliseconds = source._checkPointAfterMilliseconds
            _minCheckPointCount = source._minCheckPointCount
            _maxCheckPointCount = source._maxCheckPointCount
            _readBufferCount = source._readBufferCount
            _liveBufferCount = source._liveBufferCount
            _retryBufferCount = source._retryBufferCount
            _totalInFlightMessages = source._totalInFlightMessages
            _outstandingMessagesCount = source._outstandingMessagesCount
            _namedConsumerStrategy = source._namedConsumerStrategy
            _maxSubscriberCount = source._maxSubscriberCount
            _parkedMessageCount = source._parkedMessageCount
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularStringField(value: &_storage._eventSource)
                case 2: try decoder.decodeSingularStringField(value: &_storage._groupName)
                case 3: try decoder.decodeSingularStringField(value: &_storage._status)
                case 4: try decoder.decodeRepeatedMessageField(value: &_storage._connections)
                case 5: try decoder.decodeSingularInt32Field(value: &_storage._averagePerSecond)
                case 6: try decoder.decodeSingularInt64Field(value: &_storage._totalItems)
                case 7: try decoder.decodeSingularInt64Field(value: &_storage._countSinceLastMeasurement)
                case 8: try decoder.decodeSingularStringField(value: &_storage._lastCheckpointedEventPosition)
                case 9: try decoder.decodeSingularStringField(value: &_storage._lastKnownEventPosition)
                case 10: try decoder.decodeSingularBoolField(value: &_storage._resolveLinkTos)
                case 11: try decoder.decodeSingularStringField(value: &_storage._startFrom)
                case 12: try decoder.decodeSingularInt32Field(value: &_storage._messageTimeoutMilliseconds)
                case 13: try decoder.decodeSingularBoolField(value: &_storage._extraStatistics)
                case 14: try decoder.decodeSingularInt32Field(value: &_storage._maxRetryCount)
                case 15: try decoder.decodeSingularInt32Field(value: &_storage._liveBufferSize)
                case 16: try decoder.decodeSingularInt32Field(value: &_storage._bufferSize)
                case 17: try decoder.decodeSingularInt32Field(value: &_storage._readBatchSize)
                case 18: try decoder.decodeSingularInt32Field(value: &_storage._checkPointAfterMilliseconds)
                case 19: try decoder.decodeSingularInt32Field(value: &_storage._minCheckPointCount)
                case 20: try decoder.decodeSingularInt32Field(value: &_storage._maxCheckPointCount)
                case 21: try decoder.decodeSingularInt32Field(value: &_storage._readBufferCount)
                case 22: try decoder.decodeSingularInt64Field(value: &_storage._liveBufferCount)
                case 23: try decoder.decodeSingularInt32Field(value: &_storage._retryBufferCount)
                case 24: try decoder.decodeSingularInt32Field(value: &_storage._totalInFlightMessages)
                case 25: try decoder.decodeSingularInt32Field(value: &_storage._outstandingMessagesCount)
                case 26: try decoder.decodeSingularStringField(value: &_storage._namedConsumerStrategy)
                case 27: try decoder.decodeSingularInt32Field(value: &_storage._maxSubscriberCount)
                case 28: try decoder.decodeSingularInt64Field(value: &_storage._parkedMessageCount)
                default: break
                }
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if !_storage._eventSource.isEmpty {
                try visitor.visitSingularStringField(value: _storage._eventSource, fieldNumber: 1)
            }
            if !_storage._groupName.isEmpty {
                try visitor.visitSingularStringField(value: _storage._groupName, fieldNumber: 2)
            }
            if !_storage._status.isEmpty {
                try visitor.visitSingularStringField(value: _storage._status, fieldNumber: 3)
            }
            if !_storage._connections.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._connections, fieldNumber: 4)
            }
            if _storage._averagePerSecond != 0 {
                try visitor.visitSingularInt32Field(value: _storage._averagePerSecond, fieldNumber: 5)
            }
            if _storage._totalItems != 0 {
                try visitor.visitSingularInt64Field(value: _storage._totalItems, fieldNumber: 6)
            }
            if _storage._countSinceLastMeasurement != 0 {
                try visitor.visitSingularInt64Field(value: _storage._countSinceLastMeasurement, fieldNumber: 7)
            }
            if !_storage._lastCheckpointedEventPosition.isEmpty {
                try visitor.visitSingularStringField(value: _storage._lastCheckpointedEventPosition, fieldNumber: 8)
            }
            if !_storage._lastKnownEventPosition.isEmpty {
                try visitor.visitSingularStringField(value: _storage._lastKnownEventPosition, fieldNumber: 9)
            }
            if _storage._resolveLinkTos != false {
                try visitor.visitSingularBoolField(value: _storage._resolveLinkTos, fieldNumber: 10)
            }
            if !_storage._startFrom.isEmpty {
                try visitor.visitSingularStringField(value: _storage._startFrom, fieldNumber: 11)
            }
            if _storage._messageTimeoutMilliseconds != 0 {
                try visitor.visitSingularInt32Field(value: _storage._messageTimeoutMilliseconds, fieldNumber: 12)
            }
            if _storage._extraStatistics != false {
                try visitor.visitSingularBoolField(value: _storage._extraStatistics, fieldNumber: 13)
            }
            if _storage._maxRetryCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._maxRetryCount, fieldNumber: 14)
            }
            if _storage._liveBufferSize != 0 {
                try visitor.visitSingularInt32Field(value: _storage._liveBufferSize, fieldNumber: 15)
            }
            if _storage._bufferSize != 0 {
                try visitor.visitSingularInt32Field(value: _storage._bufferSize, fieldNumber: 16)
            }
            if _storage._readBatchSize != 0 {
                try visitor.visitSingularInt32Field(value: _storage._readBatchSize, fieldNumber: 17)
            }
            if _storage._checkPointAfterMilliseconds != 0 {
                try visitor.visitSingularInt32Field(value: _storage._checkPointAfterMilliseconds, fieldNumber: 18)
            }
            if _storage._minCheckPointCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._minCheckPointCount, fieldNumber: 19)
            }
            if _storage._maxCheckPointCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._maxCheckPointCount, fieldNumber: 20)
            }
            if _storage._readBufferCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._readBufferCount, fieldNumber: 21)
            }
            if _storage._liveBufferCount != 0 {
                try visitor.visitSingularInt64Field(value: _storage._liveBufferCount, fieldNumber: 22)
            }
            if _storage._retryBufferCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._retryBufferCount, fieldNumber: 23)
            }
            if _storage._totalInFlightMessages != 0 {
                try visitor.visitSingularInt32Field(value: _storage._totalInFlightMessages, fieldNumber: 24)
            }
            if _storage._outstandingMessagesCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._outstandingMessagesCount, fieldNumber: 25)
            }
            if !_storage._namedConsumerStrategy.isEmpty {
                try visitor.visitSingularStringField(value: _storage._namedConsumerStrategy, fieldNumber: 26)
            }
            if _storage._maxSubscriberCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._maxSubscriberCount, fieldNumber: 27)
            }
            if _storage._parkedMessageCount != 0 {
                try visitor.visitSingularInt64Field(value: _storage._parkedMessageCount, fieldNumber: 28)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_SubscriptionInfo, rhs: EventStore_Client_PersistentSubscriptions_SubscriptionInfo) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._eventSource != rhs_storage._eventSource { return false }
                if _storage._groupName != rhs_storage._groupName { return false }
                if _storage._status != rhs_storage._status { return false }
                if _storage._connections != rhs_storage._connections { return false }
                if _storage._averagePerSecond != rhs_storage._averagePerSecond { return false }
                if _storage._totalItems != rhs_storage._totalItems { return false }
                if _storage._countSinceLastMeasurement != rhs_storage._countSinceLastMeasurement { return false }
                if _storage._lastCheckpointedEventPosition != rhs_storage._lastCheckpointedEventPosition { return false }
                if _storage._lastKnownEventPosition != rhs_storage._lastKnownEventPosition { return false }
                if _storage._resolveLinkTos != rhs_storage._resolveLinkTos { return false }
                if _storage._startFrom != rhs_storage._startFrom { return false }
                if _storage._messageTimeoutMilliseconds != rhs_storage._messageTimeoutMilliseconds { return false }
                if _storage._extraStatistics != rhs_storage._extraStatistics { return false }
                if _storage._maxRetryCount != rhs_storage._maxRetryCount { return false }
                if _storage._liveBufferSize != rhs_storage._liveBufferSize { return false }
                if _storage._bufferSize != rhs_storage._bufferSize { return false }
                if _storage._readBatchSize != rhs_storage._readBatchSize { return false }
                if _storage._checkPointAfterMilliseconds != rhs_storage._checkPointAfterMilliseconds { return false }
                if _storage._minCheckPointCount != rhs_storage._minCheckPointCount { return false }
                if _storage._maxCheckPointCount != rhs_storage._maxCheckPointCount { return false }
                if _storage._readBufferCount != rhs_storage._readBufferCount { return false }
                if _storage._liveBufferCount != rhs_storage._liveBufferCount { return false }
                if _storage._retryBufferCount != rhs_storage._retryBufferCount { return false }
                if _storage._totalInFlightMessages != rhs_storage._totalInFlightMessages { return false }
                if _storage._outstandingMessagesCount != rhs_storage._outstandingMessagesCount { return false }
                if _storage._namedConsumerStrategy != rhs_storage._namedConsumerStrategy { return false }
                if _storage._maxSubscriberCount != rhs_storage._maxSubscriberCount { return false }
                if _storage._parkedMessageCount != rhs_storage._parkedMessageCount { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_SubscriptionInfo.ConnectionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_SubscriptionInfo.protoMessageName + ".ConnectionInfo"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "from"),
        2: .same(proto: "username"),
        3: .standard(proto: "average_items_per_second"),
        4: .standard(proto: "total_items"),
        5: .standard(proto: "count_since_last_measurement"),
        6: .standard(proto: "observed_measurements"),
        7: .standard(proto: "available_slots"),
        8: .standard(proto: "in_flight_messages"),
        9: .standard(proto: "connection_name"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &from)
            case 2: try decoder.decodeSingularStringField(value: &username)
            case 3: try decoder.decodeSingularInt32Field(value: &averageItemsPerSecond)
            case 4: try decoder.decodeSingularInt64Field(value: &totalItems)
            case 5: try decoder.decodeSingularInt64Field(value: &countSinceLastMeasurement)
            case 6: try decoder.decodeRepeatedMessageField(value: &observedMeasurements)
            case 7: try decoder.decodeSingularInt32Field(value: &availableSlots)
            case 8: try decoder.decodeSingularInt32Field(value: &inFlightMessages)
            case 9: try decoder.decodeSingularStringField(value: &connectionName)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !from.isEmpty {
            try visitor.visitSingularStringField(value: from, fieldNumber: 1)
        }
        if !username.isEmpty {
            try visitor.visitSingularStringField(value: username, fieldNumber: 2)
        }
        if averageItemsPerSecond != 0 {
            try visitor.visitSingularInt32Field(value: averageItemsPerSecond, fieldNumber: 3)
        }
        if totalItems != 0 {
            try visitor.visitSingularInt64Field(value: totalItems, fieldNumber: 4)
        }
        if countSinceLastMeasurement != 0 {
            try visitor.visitSingularInt64Field(value: countSinceLastMeasurement, fieldNumber: 5)
        }
        if !observedMeasurements.isEmpty {
            try visitor.visitRepeatedMessageField(value: observedMeasurements, fieldNumber: 6)
        }
        if availableSlots != 0 {
            try visitor.visitSingularInt32Field(value: availableSlots, fieldNumber: 7)
        }
        if inFlightMessages != 0 {
            try visitor.visitSingularInt32Field(value: inFlightMessages, fieldNumber: 8)
        }
        if !connectionName.isEmpty {
            try visitor.visitSingularStringField(value: connectionName, fieldNumber: 9)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_SubscriptionInfo.ConnectionInfo, rhs: EventStore_Client_PersistentSubscriptions_SubscriptionInfo.ConnectionInfo) -> Bool {
        if lhs.from != rhs.from { return false }
        if lhs.username != rhs.username { return false }
        if lhs.averageItemsPerSecond != rhs.averageItemsPerSecond { return false }
        if lhs.totalItems != rhs.totalItems { return false }
        if lhs.countSinceLastMeasurement != rhs.countSinceLastMeasurement { return false }
        if lhs.observedMeasurements != rhs.observedMeasurements { return false }
        if lhs.availableSlots != rhs.availableSlots { return false }
        if lhs.inFlightMessages != rhs.inFlightMessages { return false }
        if lhs.connectionName != rhs.connectionName { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_SubscriptionInfo.Measurement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_SubscriptionInfo.protoMessageName + ".Measurement"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "key"),
        2: .same(proto: "value"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &key)
            case 2: try decoder.decodeSingularInt64Field(value: &value)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !key.isEmpty {
            try visitor.visitSingularStringField(value: key, fieldNumber: 1)
        }
        if value != 0 {
            try visitor.visitSingularInt64Field(value: value, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_SubscriptionInfo.Measurement, rhs: EventStore_Client_PersistentSubscriptions_SubscriptionInfo.Measurement) -> Bool {
        if lhs.key != rhs.key { return false }
        if lhs.value != rhs.value { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ReplayParkedReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ReplayParkedReq"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_ReplayParkedReq, rhs: EventStore_Client_PersistentSubscriptions_ReplayParkedReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReplayParkedReq.protoMessageName + ".Options"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "group_name"),
        2: .standard(proto: "stream_identifier"),
        3: .same(proto: "all"),
        4: .standard(proto: "stop_at"),
        5: .standard(proto: "no_limit"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &groupName)
            case 2: try {
                    var v: EventStore_Client_StreamIdentifier?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .streamIdentifier(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .streamIdentifier(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .all(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .all(v)
                    }
                }()
            case 4: try {
                    var v: Int64?
                    try decoder.decodeSingularInt64Field(value: &v)
                    if let v {
                        if self.stopAtOption != nil { try decoder.handleConflictingOneOf() }
                        self.stopAtOption = .stopAt(v)
                    }
                }()
            case 5: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.stopAtOption {
                        hadOneofValue = true
                        if case let .noLimit(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.stopAtOption = .noLimit(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !groupName.isEmpty {
            try visitor.visitSingularStringField(value: groupName, fieldNumber: 1)
        }
        switch streamOption {
        case .streamIdentifier?: try {
                guard case let .streamIdentifier(v)? = self.streamOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .all?: try {
                guard case let .all(v)? = self.streamOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        switch stopAtOption {
        case .stopAt?: try {
                guard case let .stopAt(v)? = self.stopAtOption else { preconditionFailure() }
                try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
            }()
        case .noLimit?: try {
                guard case let .noLimit(v)? = self.stopAtOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options, rhs: EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options) -> Bool {
        if lhs.groupName != rhs.groupName { return false }
        if lhs.streamOption != rhs.streamOption { return false }
        if lhs.stopAtOption != rhs.stopAtOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ReplayParkedResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ReplayParkedResp"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_ReplayParkedResp, rhs: EventStore_Client_PersistentSubscriptions_ReplayParkedResp) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ListReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ListReq"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_ListReq, rhs: EventStore_Client_PersistentSubscriptions_ListReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ListReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ListReq.protoMessageName + ".Options"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "list_all_subscriptions"),
        2: .standard(proto: "list_for_stream"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.listOption {
                        hadOneofValue = true
                        if case let .listAllSubscriptions(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.listOption = .listAllSubscriptions(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_PersistentSubscriptions_ListReq.StreamOption?
                    var hadOneofValue = false
                    if let current = self.listOption {
                        hadOneofValue = true
                        if case let .listForStream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.listOption = .listForStream(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch listOption {
        case .listAllSubscriptions?: try {
                guard case let .listAllSubscriptions(v)? = self.listOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .listForStream?: try {
                guard case let .listForStream(v)? = self.listOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_ListReq.Options, rhs: EventStore_Client_PersistentSubscriptions_ListReq.Options) -> Bool {
        if lhs.listOption != rhs.listOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ListReq.StreamOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ListReq.protoMessageName + ".StreamOption"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "stream"),
        2: .same(proto: "all"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_StreamIdentifier?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .stream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .stream(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .all(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .all(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch streamOption {
        case .stream?: try {
                guard case let .stream(v)? = self.streamOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .all?: try {
                guard case let .all(v)? = self.streamOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_ListReq.StreamOption, rhs: EventStore_Client_PersistentSubscriptions_ListReq.StreamOption) -> Bool {
        if lhs.streamOption != rhs.streamOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_PersistentSubscriptions_ListResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ListResp"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "subscriptions"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &subscriptions)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !subscriptions.isEmpty {
            try visitor.visitRepeatedMessageField(value: subscriptions, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_PersistentSubscriptions_ListResp, rhs: EventStore_Client_PersistentSubscriptions_ListResp) -> Bool {
        if lhs.subscriptions != rhs.subscriptions { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
