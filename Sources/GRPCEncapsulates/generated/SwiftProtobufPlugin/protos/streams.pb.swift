// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protos/streams.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

public struct EventStore_Client_Streams_ReadReq {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var options: EventStore_Client_Streams_ReadReq.Options {
        get { _options ?? EventStore_Client_Streams_ReadReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    public var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    public mutating func clearOptions() { _options = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Options {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var streamOption: EventStore_Client_Streams_ReadReq.Options.OneOf_StreamOption?

        public var stream: EventStore_Client_Streams_ReadReq.Options.StreamOptions {
            get {
                if case let .stream(v)? = streamOption { return v }
                return EventStore_Client_Streams_ReadReq.Options.StreamOptions()
            }
            set { streamOption = .stream(newValue) }
        }

        public var all: EventStore_Client_Streams_ReadReq.Options.AllOptions {
            get {
                if case let .all(v)? = streamOption { return v }
                return EventStore_Client_Streams_ReadReq.Options.AllOptions()
            }
            set { streamOption = .all(newValue) }
        }

        public var readDirection: EventStore_Client_Streams_ReadReq.Options.ReadDirection = .forwards

        public var resolveLinks: Bool = false

        public var countOption: EventStore_Client_Streams_ReadReq.Options.OneOf_CountOption?

        public var count: UInt64 {
            get {
                if case let .count(v)? = countOption { return v }
                return 0
            }
            set { countOption = .count(newValue) }
        }

        public var subscription: EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions {
            get {
                if case let .subscription(v)? = countOption { return v }
                return EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions()
            }
            set { countOption = .subscription(newValue) }
        }

        public var filterOption: EventStore_Client_Streams_ReadReq.Options.OneOf_FilterOption?

        public var filter: EventStore_Client_Streams_ReadReq.Options.FilterOptions {
            get {
                if case let .filter(v)? = filterOption { return v }
                return EventStore_Client_Streams_ReadReq.Options.FilterOptions()
            }
            set { filterOption = .filter(newValue) }
        }

        public var noFilter: EventStore_Client_Empty {
            get {
                if case let .noFilter(v)? = filterOption { return v }
                return EventStore_Client_Empty()
            }
            set { filterOption = .noFilter(newValue) }
        }

        public var uuidOption: EventStore_Client_Streams_ReadReq.Options.UUIDOption {
            get { _uuidOption ?? EventStore_Client_Streams_ReadReq.Options.UUIDOption() }
            set { _uuidOption = newValue }
        }

        /// Returns true if `uuidOption` has been explicitly set.
        public var hasUuidOption: Bool { _uuidOption != nil }
        /// Clears the value of `uuidOption`. Subsequent reads from it will return its default value.
        public mutating func clearUuidOption() { _uuidOption = nil }

        public var controlOption: EventStore_Client_Streams_ReadReq.Options.ControlOption {
            get { _controlOption ?? EventStore_Client_Streams_ReadReq.Options.ControlOption() }
            set { _controlOption = newValue }
        }

        /// Returns true if `controlOption` has been explicitly set.
        public var hasControlOption: Bool { _controlOption != nil }
        /// Clears the value of `controlOption`. Subsequent reads from it will return its default value.
        public mutating func clearControlOption() { _controlOption = nil }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_StreamOption: Equatable {
            case stream(EventStore_Client_Streams_ReadReq.Options.StreamOptions)
            case all(EventStore_Client_Streams_ReadReq.Options.AllOptions)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_Streams_ReadReq.Options.OneOf_StreamOption, rhs: EventStore_Client_Streams_ReadReq.Options.OneOf_StreamOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.stream, .stream): {
                            guard case let .stream(l) = lhs, case let .stream(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.all, .all): {
                            guard case let .all(l) = lhs, case let .all(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public enum OneOf_CountOption: Equatable {
            case count(UInt64)
            case subscription(EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_Streams_ReadReq.Options.OneOf_CountOption, rhs: EventStore_Client_Streams_ReadReq.Options.OneOf_CountOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.count, .count): {
                            guard case let .count(l) = lhs, case let .count(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.subscription, .subscription): {
                            guard case let .subscription(l) = lhs, case let .subscription(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public enum OneOf_FilterOption: Equatable {
            case filter(EventStore_Client_Streams_ReadReq.Options.FilterOptions)
            case noFilter(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_Streams_ReadReq.Options.OneOf_FilterOption, rhs: EventStore_Client_Streams_ReadReq.Options.OneOf_FilterOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.filter, .filter): {
                            guard case let .filter(l) = lhs, case let .filter(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.noFilter, .noFilter): {
                            guard case let .noFilter(l) = lhs, case let .noFilter(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public enum ReadDirection: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case forwards // = 0
            case backwards // = 1
            case UNRECOGNIZED(Int)

            public init() {
                self = .forwards
            }

            public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .forwards
                case 1: self = .backwards
                default: self = .UNRECOGNIZED(rawValue)
                }
            }

            public var rawValue: Int {
                switch self {
                case .forwards: 0
                case .backwards: 1
                case let .UNRECOGNIZED(i): i
                }
            }
        }

        public struct StreamOptions {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var streamIdentifier: EventStore_Client_StreamIdentifier {
                get { _streamIdentifier ?? EventStore_Client_StreamIdentifier() }
                set { _streamIdentifier = newValue }
            }

            /// Returns true if `streamIdentifier` has been explicitly set.
            public var hasStreamIdentifier: Bool { _streamIdentifier != nil }
            /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
            public mutating func clearStreamIdentifier() { _streamIdentifier = nil }

            public var revisionOption: EventStore_Client_Streams_ReadReq.Options.StreamOptions.OneOf_RevisionOption?

            public var revision: UInt64 {
                get {
                    if case let .revision(v)? = revisionOption { return v }
                    return 0
                }
                set { revisionOption = .revision(newValue) }
            }

            public var start: EventStore_Client_Empty {
                get {
                    if case let .start(v)? = revisionOption { return v }
                    return EventStore_Client_Empty()
                }
                set { revisionOption = .start(newValue) }
            }

            public var end: EventStore_Client_Empty {
                get {
                    if case let .end(v)? = revisionOption { return v }
                    return EventStore_Client_Empty()
                }
                set { revisionOption = .end(newValue) }
            }

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum OneOf_RevisionOption: Equatable {
                case revision(UInt64)
                case start(EventStore_Client_Empty)
                case end(EventStore_Client_Empty)

                #if !swift(>=4.1)
                    public static func == (lhs: EventStore_Client_Streams_ReadReq.Options.StreamOptions.OneOf_RevisionOption, rhs: EventStore_Client_Streams_ReadReq.Options.StreamOptions.OneOf_RevisionOption) -> Bool {
                        // The use of inline closures is to circumvent an issue where the compiler
                        // allocates stack space for every case branch when no optimizations are
                        // enabled. https://github.com/apple/swift-protobuf/issues/1034
                        switch (lhs, rhs) {
                        case (.revision, .revision): {
                                guard case let .revision(l) = lhs, case let .revision(r) = rhs else { preconditionFailure() }
                                return l == r
                            }()
                        case (.start, .start): {
                                guard case let .start(l) = lhs, case let .start(r) = rhs else { preconditionFailure() }
                                return l == r
                            }()
                        case (.end, .end): {
                                guard case let .end(l) = lhs, case let .end(r) = rhs else { preconditionFailure() }
                                return l == r
                            }()
                        default: false
                        }
                    }
                #endif
            }

            public init() {}

            fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier?
        }

        public struct AllOptions {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var allOption: EventStore_Client_Streams_ReadReq.Options.AllOptions.OneOf_AllOption?

            public var position: EventStore_Client_Streams_ReadReq.Options.Position {
                get {
                    if case let .position(v)? = allOption { return v }
                    return EventStore_Client_Streams_ReadReq.Options.Position()
                }
                set { allOption = .position(newValue) }
            }

            public var start: EventStore_Client_Empty {
                get {
                    if case let .start(v)? = allOption { return v }
                    return EventStore_Client_Empty()
                }
                set { allOption = .start(newValue) }
            }

            public var end: EventStore_Client_Empty {
                get {
                    if case let .end(v)? = allOption { return v }
                    return EventStore_Client_Empty()
                }
                set { allOption = .end(newValue) }
            }

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum OneOf_AllOption: Equatable {
                case position(EventStore_Client_Streams_ReadReq.Options.Position)
                case start(EventStore_Client_Empty)
                case end(EventStore_Client_Empty)

                #if !swift(>=4.1)
                    public static func == (lhs: EventStore_Client_Streams_ReadReq.Options.AllOptions.OneOf_AllOption, rhs: EventStore_Client_Streams_ReadReq.Options.AllOptions.OneOf_AllOption) -> Bool {
                        // The use of inline closures is to circumvent an issue where the compiler
                        // allocates stack space for every case branch when no optimizations are
                        // enabled. https://github.com/apple/swift-protobuf/issues/1034
                        switch (lhs, rhs) {
                        case (.position, .position): {
                                guard case let .position(l) = lhs, case let .position(r) = rhs else { preconditionFailure() }
                                return l == r
                            }()
                        case (.start, .start): {
                                guard case let .start(l) = lhs, case let .start(r) = rhs else { preconditionFailure() }
                                return l == r
                            }()
                        case (.end, .end): {
                                guard case let .end(l) = lhs, case let .end(r) = rhs else { preconditionFailure() }
                                return l == r
                            }()
                        default: false
                        }
                    }
                #endif
            }

            public init() {}
        }

        public struct SubscriptionOptions {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}
        }

        public struct Position {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var commitPosition: UInt64 = 0

            public var preparePosition: UInt64 = 0

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}
        }

        public struct FilterOptions {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var filter: EventStore_Client_Streams_ReadReq.Options.FilterOptions.OneOf_Filter?

            public var streamIdentifier: EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression {
                get {
                    if case let .streamIdentifier(v)? = filter { return v }
                    return EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression()
                }
                set { filter = .streamIdentifier(newValue) }
            }

            public var eventType: EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression {
                get {
                    if case let .eventType(v)? = filter { return v }
                    return EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression()
                }
                set { filter = .eventType(newValue) }
            }

            public var window: EventStore_Client_Streams_ReadReq.Options.FilterOptions.OneOf_Window?

            public var max: UInt32 {
                get {
                    if case let .max(v)? = window { return v }
                    return 0
                }
                set { window = .max(newValue) }
            }

            public var count: EventStore_Client_Empty {
                get {
                    if case let .count(v)? = window { return v }
                    return EventStore_Client_Empty()
                }
                set { window = .count(newValue) }
            }

            public var checkpointIntervalMultiplier: UInt32 = 0

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum OneOf_Filter: Equatable {
                case streamIdentifier(EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression)
                case eventType(EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression)

                #if !swift(>=4.1)
                    public static func == (lhs: EventStore_Client_Streams_ReadReq.Options.FilterOptions.OneOf_Filter, rhs: EventStore_Client_Streams_ReadReq.Options.FilterOptions.OneOf_Filter) -> Bool {
                        // The use of inline closures is to circumvent an issue where the compiler
                        // allocates stack space for every case branch when no optimizations are
                        // enabled. https://github.com/apple/swift-protobuf/issues/1034
                        switch (lhs, rhs) {
                        case (.streamIdentifier, .streamIdentifier): {
                                guard case let .streamIdentifier(l) = lhs, case let .streamIdentifier(r) = rhs else { preconditionFailure() }
                                return l == r
                            }()
                        case (.eventType, .eventType): {
                                guard case let .eventType(l) = lhs, case let .eventType(r) = rhs else { preconditionFailure() }
                                return l == r
                            }()
                        default: false
                        }
                    }
                #endif
            }

            public enum OneOf_Window: Equatable {
                case max(UInt32)
                case count(EventStore_Client_Empty)

                #if !swift(>=4.1)
                    public static func == (lhs: EventStore_Client_Streams_ReadReq.Options.FilterOptions.OneOf_Window, rhs: EventStore_Client_Streams_ReadReq.Options.FilterOptions.OneOf_Window) -> Bool {
                        // The use of inline closures is to circumvent an issue where the compiler
                        // allocates stack space for every case branch when no optimizations are
                        // enabled. https://github.com/apple/swift-protobuf/issues/1034
                        switch (lhs, rhs) {
                        case (.max, .max): {
                                guard case let .max(l) = lhs, case let .max(r) = rhs else { preconditionFailure() }
                                return l == r
                            }()
                        case (.count, .count): {
                                guard case let .count(l) = lhs, case let .count(r) = rhs else { preconditionFailure() }
                                return l == r
                            }()
                        default: false
                        }
                    }
                #endif
            }

            public struct Expression {
                // SwiftProtobuf.Message conformance is added in an extension below. See the
                // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
                // methods supported on all messages.

                public var regex: String = .init()

                public var prefix: [String] = []

                public var unknownFields = SwiftProtobuf.UnknownStorage()

                public init() {}
            }

            public init() {}
        }

        public struct UUIDOption {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var content: EventStore_Client_Streams_ReadReq.Options.UUIDOption.OneOf_Content?

            public var structured: EventStore_Client_Empty {
                get {
                    if case let .structured(v)? = content { return v }
                    return EventStore_Client_Empty()
                }
                set { content = .structured(newValue) }
            }

            public var string: EventStore_Client_Empty {
                get {
                    if case let .string(v)? = content { return v }
                    return EventStore_Client_Empty()
                }
                set { content = .string(newValue) }
            }

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum OneOf_Content: Equatable {
                case structured(EventStore_Client_Empty)
                case string(EventStore_Client_Empty)

                #if !swift(>=4.1)
                    public static func == (lhs: EventStore_Client_Streams_ReadReq.Options.UUIDOption.OneOf_Content, rhs: EventStore_Client_Streams_ReadReq.Options.UUIDOption.OneOf_Content) -> Bool {
                        // The use of inline closures is to circumvent an issue where the compiler
                        // allocates stack space for every case branch when no optimizations are
                        // enabled. https://github.com/apple/swift-protobuf/issues/1034
                        switch (lhs, rhs) {
                        case (.structured, .structured): {
                                guard case let .structured(l) = lhs, case let .structured(r) = rhs else { preconditionFailure() }
                                return l == r
                            }()
                        case (.string, .string): {
                                guard case let .string(l) = lhs, case let .string(r) = rhs else { preconditionFailure() }
                                return l == r
                            }()
                        default: false
                        }
                    }
                #endif
            }

            public init() {}
        }

        public struct ControlOption {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var compatibility: UInt32 = 0

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}
        }

        public init() {}

        fileprivate var _uuidOption: EventStore_Client_Streams_ReadReq.Options.UUIDOption?
        fileprivate var _controlOption: EventStore_Client_Streams_ReadReq.Options.ControlOption?
    }

    public init() {}

    fileprivate var _options: EventStore_Client_Streams_ReadReq.Options?
}

#if swift(>=4.2)

    extension EventStore_Client_Streams_ReadReq.Options.ReadDirection: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [EventStore_Client_Streams_ReadReq.Options.ReadDirection] = [
            .forwards,
            .backwards,
        ]
    }

#endif // swift(>=4.2)

public struct EventStore_Client_Streams_ReadResp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var content: EventStore_Client_Streams_ReadResp.OneOf_Content?

    public var event: EventStore_Client_Streams_ReadResp.ReadEvent {
        get {
            if case let .event(v)? = content { return v }
            return EventStore_Client_Streams_ReadResp.ReadEvent()
        }
        set { content = .event(newValue) }
    }

    public var confirmation: EventStore_Client_Streams_ReadResp.SubscriptionConfirmation {
        get {
            if case let .confirmation(v)? = content { return v }
            return EventStore_Client_Streams_ReadResp.SubscriptionConfirmation()
        }
        set { content = .confirmation(newValue) }
    }

    public var checkpoint: EventStore_Client_Streams_ReadResp.Checkpoint {
        get {
            if case let .checkpoint(v)? = content { return v }
            return EventStore_Client_Streams_ReadResp.Checkpoint()
        }
        set { content = .checkpoint(newValue) }
    }

    public var streamNotFound: EventStore_Client_Streams_ReadResp.StreamNotFound {
        get {
            if case let .streamNotFound(v)? = content { return v }
            return EventStore_Client_Streams_ReadResp.StreamNotFound()
        }
        set { content = .streamNotFound(newValue) }
    }

    public var firstStreamPosition: UInt64 {
        get {
            if case let .firstStreamPosition(v)? = content { return v }
            return 0
        }
        set { content = .firstStreamPosition(newValue) }
    }

    public var lastStreamPosition: UInt64 {
        get {
            if case let .lastStreamPosition(v)? = content { return v }
            return 0
        }
        set { content = .lastStreamPosition(newValue) }
    }

    public var lastAllStreamPosition: EventStore_Client_AllStreamPosition {
        get {
            if case let .lastAllStreamPosition(v)? = content { return v }
            return EventStore_Client_AllStreamPosition()
        }
        set { content = .lastAllStreamPosition(newValue) }
    }

    public var caughtUp: EventStore_Client_Streams_ReadResp.CaughtUp {
        get {
            if case let .caughtUp(v)? = content { return v }
            return EventStore_Client_Streams_ReadResp.CaughtUp()
        }
        set { content = .caughtUp(newValue) }
    }

    public var fellBehind: EventStore_Client_Streams_ReadResp.FellBehind {
        get {
            if case let .fellBehind(v)? = content { return v }
            return EventStore_Client_Streams_ReadResp.FellBehind()
        }
        set { content = .fellBehind(newValue) }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Content: Equatable {
        case event(EventStore_Client_Streams_ReadResp.ReadEvent)
        case confirmation(EventStore_Client_Streams_ReadResp.SubscriptionConfirmation)
        case checkpoint(EventStore_Client_Streams_ReadResp.Checkpoint)
        case streamNotFound(EventStore_Client_Streams_ReadResp.StreamNotFound)
        case firstStreamPosition(UInt64)
        case lastStreamPosition(UInt64)
        case lastAllStreamPosition(EventStore_Client_AllStreamPosition)
        case caughtUp(EventStore_Client_Streams_ReadResp.CaughtUp)
        case fellBehind(EventStore_Client_Streams_ReadResp.FellBehind)

        #if !swift(>=4.1)
            public static func == (lhs: EventStore_Client_Streams_ReadResp.OneOf_Content, rhs: EventStore_Client_Streams_ReadResp.OneOf_Content) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.event, .event): {
                        guard case let .event(l) = lhs, case let .event(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.confirmation, .confirmation): {
                        guard case let .confirmation(l) = lhs, case let .confirmation(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.checkpoint, .checkpoint): {
                        guard case let .checkpoint(l) = lhs, case let .checkpoint(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.streamNotFound, .streamNotFound): {
                        guard case let .streamNotFound(l) = lhs, case let .streamNotFound(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.firstStreamPosition, .firstStreamPosition): {
                        guard case let .firstStreamPosition(l) = lhs, case let .firstStreamPosition(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.lastStreamPosition, .lastStreamPosition): {
                        guard case let .lastStreamPosition(l) = lhs, case let .lastStreamPosition(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.lastAllStreamPosition, .lastAllStreamPosition): {
                        guard case let .lastAllStreamPosition(l) = lhs, case let .lastAllStreamPosition(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.caughtUp, .caughtUp): {
                        guard case let .caughtUp(l) = lhs, case let .caughtUp(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.fellBehind, .fellBehind): {
                        guard case let .fellBehind(l) = lhs, case let .fellBehind(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: false
                }
            }
        #endif
    }

    public struct CaughtUp {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public struct FellBehind {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public struct ReadEvent {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var event: EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent {
            get { _storage._event ?? EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent() }
            set { _uniqueStorage()._event = newValue }
        }

        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool { _storage._event != nil }
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() { _uniqueStorage()._event = nil }

        public var link: EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent {
            get { _storage._link ?? EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent() }
            set { _uniqueStorage()._link = newValue }
        }

        /// Returns true if `link` has been explicitly set.
        public var hasLink: Bool { _storage._link != nil }
        /// Clears the value of `link`. Subsequent reads from it will return its default value.
        public mutating func clearLink() { _uniqueStorage()._link = nil }

        public var position: OneOf_Position? {
            get { _storage._position }
            set { _uniqueStorage()._position = newValue }
        }

        public var commitPosition: UInt64 {
            get {
                if case let .commitPosition(v)? = _storage._position { return v }
                return 0
            }
            set { _uniqueStorage()._position = .commitPosition(newValue) }
        }

        public var noPosition: EventStore_Client_Empty {
            get {
                if case let .noPosition(v)? = _storage._position { return v }
                return EventStore_Client_Empty()
            }
            set { _uniqueStorage()._position = .noPosition(newValue) }
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_Position: Equatable {
            case commitPosition(UInt64)
            case noPosition(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_Streams_ReadResp.ReadEvent.OneOf_Position, rhs: EventStore_Client_Streams_ReadResp.ReadEvent.OneOf_Position) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.commitPosition, .commitPosition): {
                            guard case let .commitPosition(l) = lhs, case let .commitPosition(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.noPosition, .noPosition): {
                            guard case let .noPosition(l) = lhs, case let .noPosition(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public struct RecordedEvent {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var id: EventStore_Client_UUID {
                get { _id ?? EventStore_Client_UUID() }
                set { _id = newValue }
            }

            /// Returns true if `id` has been explicitly set.
            public var hasID: Bool { _id != nil }
            /// Clears the value of `id`. Subsequent reads from it will return its default value.
            public mutating func clearID() { _id = nil }

            public var streamIdentifier: EventStore_Client_StreamIdentifier {
                get { _streamIdentifier ?? EventStore_Client_StreamIdentifier() }
                set { _streamIdentifier = newValue }
            }

            /// Returns true if `streamIdentifier` has been explicitly set.
            public var hasStreamIdentifier: Bool { _streamIdentifier != nil }
            /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
            public mutating func clearStreamIdentifier() { _streamIdentifier = nil }

            public var streamRevision: UInt64 = 0

            public var preparePosition: UInt64 = 0

            public var commitPosition: UInt64 = 0

            public var metadata: [String: String] = [:]

            public var customMetadata: Data = .init()

            public var data: Data = .init()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}

            fileprivate var _id: EventStore_Client_UUID?
            fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier?
        }

        public init() {}

        fileprivate var _storage = _StorageClass.defaultInstance
    }

    public struct SubscriptionConfirmation {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var subscriptionID: String = .init()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public struct Checkpoint {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var commitPosition: UInt64 = 0

        public var preparePosition: UInt64 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public struct StreamNotFound {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var streamIdentifier: EventStore_Client_StreamIdentifier {
            get { _streamIdentifier ?? EventStore_Client_StreamIdentifier() }
            set { _streamIdentifier = newValue }
        }

        /// Returns true if `streamIdentifier` has been explicitly set.
        public var hasStreamIdentifier: Bool { _streamIdentifier != nil }
        /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
        public mutating func clearStreamIdentifier() { _streamIdentifier = nil }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier?
    }

    public init() {}
}

public struct EventStore_Client_Streams_AppendReq {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var content: EventStore_Client_Streams_AppendReq.OneOf_Content?

    public var options: EventStore_Client_Streams_AppendReq.Options {
        get {
            if case let .options(v)? = content { return v }
            return EventStore_Client_Streams_AppendReq.Options()
        }
        set { content = .options(newValue) }
    }

    public var proposedMessage: EventStore_Client_Streams_AppendReq.ProposedMessage {
        get {
            if case let .proposedMessage(v)? = content { return v }
            return EventStore_Client_Streams_AppendReq.ProposedMessage()
        }
        set { content = .proposedMessage(newValue) }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Content: Equatable {
        case options(EventStore_Client_Streams_AppendReq.Options)
        case proposedMessage(EventStore_Client_Streams_AppendReq.ProposedMessage)

        #if !swift(>=4.1)
            public static func == (lhs: EventStore_Client_Streams_AppendReq.OneOf_Content, rhs: EventStore_Client_Streams_AppendReq.OneOf_Content) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.options, .options): {
                        guard case let .options(l) = lhs, case let .options(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.proposedMessage, .proposedMessage): {
                        guard case let .proposedMessage(l) = lhs, case let .proposedMessage(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: false
                }
            }
        #endif
    }

    public struct Options {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var streamIdentifier: EventStore_Client_StreamIdentifier {
            get { _streamIdentifier ?? EventStore_Client_StreamIdentifier() }
            set { _streamIdentifier = newValue }
        }

        /// Returns true if `streamIdentifier` has been explicitly set.
        public var hasStreamIdentifier: Bool { _streamIdentifier != nil }
        /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
        public mutating func clearStreamIdentifier() { _streamIdentifier = nil }

        public var expectedStreamRevision: EventStore_Client_Streams_AppendReq.Options.OneOf_ExpectedStreamRevision?

        public var revision: UInt64 {
            get {
                if case let .revision(v)? = expectedStreamRevision { return v }
                return 0
            }
            set { expectedStreamRevision = .revision(newValue) }
        }

        public var noStream: EventStore_Client_Empty {
            get {
                if case let .noStream(v)? = expectedStreamRevision { return v }
                return EventStore_Client_Empty()
            }
            set { expectedStreamRevision = .noStream(newValue) }
        }

        public var any: EventStore_Client_Empty {
            get {
                if case let .any(v)? = expectedStreamRevision { return v }
                return EventStore_Client_Empty()
            }
            set { expectedStreamRevision = .any(newValue) }
        }

        public var streamExists: EventStore_Client_Empty {
            get {
                if case let .streamExists(v)? = expectedStreamRevision { return v }
                return EventStore_Client_Empty()
            }
            set { expectedStreamRevision = .streamExists(newValue) }
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_ExpectedStreamRevision: Equatable {
            case revision(UInt64)
            case noStream(EventStore_Client_Empty)
            case any(EventStore_Client_Empty)
            case streamExists(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_Streams_AppendReq.Options.OneOf_ExpectedStreamRevision, rhs: EventStore_Client_Streams_AppendReq.Options.OneOf_ExpectedStreamRevision) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.revision, .revision): {
                            guard case let .revision(l) = lhs, case let .revision(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.noStream, .noStream): {
                            guard case let .noStream(l) = lhs, case let .noStream(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.any, .any): {
                            guard case let .any(l) = lhs, case let .any(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.streamExists, .streamExists): {
                            guard case let .streamExists(l) = lhs, case let .streamExists(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public init() {}

        fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier?
    }

    public struct ProposedMessage {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: EventStore_Client_UUID {
            get { _id ?? EventStore_Client_UUID() }
            set { _id = newValue }
        }

        /// Returns true if `id` has been explicitly set.
        public var hasID: Bool { _id != nil }
        /// Clears the value of `id`. Subsequent reads from it will return its default value.
        public mutating func clearID() { _id = nil }

        public var metadata: [String: String] = [:]

        public var customMetadata: Data = .init()

        public var data: Data = .init()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _id: EventStore_Client_UUID?
    }

    public init() {}
}

public struct EventStore_Client_Streams_AppendResp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var result: EventStore_Client_Streams_AppendResp.OneOf_Result?

    public var success: EventStore_Client_Streams_AppendResp.Success {
        get {
            if case let .success(v)? = result { return v }
            return EventStore_Client_Streams_AppendResp.Success()
        }
        set { result = .success(newValue) }
    }

    public var wrongExpectedVersion: EventStore_Client_Streams_AppendResp.WrongExpectedVersion {
        get {
            if case let .wrongExpectedVersion(v)? = result { return v }
            return EventStore_Client_Streams_AppendResp.WrongExpectedVersion()
        }
        set { result = .wrongExpectedVersion(newValue) }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Result: Equatable {
        case success(EventStore_Client_Streams_AppendResp.Success)
        case wrongExpectedVersion(EventStore_Client_Streams_AppendResp.WrongExpectedVersion)

        #if !swift(>=4.1)
            public static func == (lhs: EventStore_Client_Streams_AppendResp.OneOf_Result, rhs: EventStore_Client_Streams_AppendResp.OneOf_Result) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.success, .success): {
                        guard case let .success(l) = lhs, case let .success(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.wrongExpectedVersion, .wrongExpectedVersion): {
                        guard case let .wrongExpectedVersion(l) = lhs, case let .wrongExpectedVersion(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: false
                }
            }
        #endif
    }

    public struct Position {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var commitPosition: UInt64 = 0

        public var preparePosition: UInt64 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public struct Success {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var currentRevisionOption: EventStore_Client_Streams_AppendResp.Success.OneOf_CurrentRevisionOption?

        public var currentRevision: UInt64 {
            get {
                if case let .currentRevision(v)? = currentRevisionOption { return v }
                return 0
            }
            set { currentRevisionOption = .currentRevision(newValue) }
        }

        public var noStream: EventStore_Client_Empty {
            get {
                if case let .noStream(v)? = currentRevisionOption { return v }
                return EventStore_Client_Empty()
            }
            set { currentRevisionOption = .noStream(newValue) }
        }

        public var positionOption: EventStore_Client_Streams_AppendResp.Success.OneOf_PositionOption?

        public var position: EventStore_Client_Streams_AppendResp.Position {
            get {
                if case let .position(v)? = positionOption { return v }
                return EventStore_Client_Streams_AppendResp.Position()
            }
            set { positionOption = .position(newValue) }
        }

        public var noPosition: EventStore_Client_Empty {
            get {
                if case let .noPosition(v)? = positionOption { return v }
                return EventStore_Client_Empty()
            }
            set { positionOption = .noPosition(newValue) }
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_CurrentRevisionOption: Equatable {
            case currentRevision(UInt64)
            case noStream(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_Streams_AppendResp.Success.OneOf_CurrentRevisionOption, rhs: EventStore_Client_Streams_AppendResp.Success.OneOf_CurrentRevisionOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.currentRevision, .currentRevision): {
                            guard case let .currentRevision(l) = lhs, case let .currentRevision(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.noStream, .noStream): {
                            guard case let .noStream(l) = lhs, case let .noStream(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public enum OneOf_PositionOption: Equatable {
            case position(EventStore_Client_Streams_AppendResp.Position)
            case noPosition(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_Streams_AppendResp.Success.OneOf_PositionOption, rhs: EventStore_Client_Streams_AppendResp.Success.OneOf_PositionOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.position, .position): {
                            guard case let .position(l) = lhs, case let .position(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.noPosition, .noPosition): {
                            guard case let .noPosition(l) = lhs, case let .noPosition(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public init() {}
    }

    public struct WrongExpectedVersion {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var currentRevisionOption2060: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_CurrentRevisionOption2060?

        public var currentRevision2060: UInt64 {
            get {
                if case let .currentRevision2060(v)? = currentRevisionOption2060 { return v }
                return 0
            }
            set { currentRevisionOption2060 = .currentRevision2060(newValue) }
        }

        public var noStream2060: EventStore_Client_Empty {
            get {
                if case let .noStream2060(v)? = currentRevisionOption2060 { return v }
                return EventStore_Client_Empty()
            }
            set { currentRevisionOption2060 = .noStream2060(newValue) }
        }

        public var expectedRevisionOption2060: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_ExpectedRevisionOption2060?

        public var expectedRevision2060: UInt64 {
            get {
                if case let .expectedRevision2060(v)? = expectedRevisionOption2060 { return v }
                return 0
            }
            set { expectedRevisionOption2060 = .expectedRevision2060(newValue) }
        }

        public var any2060: EventStore_Client_Empty {
            get {
                if case let .any2060(v)? = expectedRevisionOption2060 { return v }
                return EventStore_Client_Empty()
            }
            set { expectedRevisionOption2060 = .any2060(newValue) }
        }

        public var streamExists2060: EventStore_Client_Empty {
            get {
                if case let .streamExists2060(v)? = expectedRevisionOption2060 { return v }
                return EventStore_Client_Empty()
            }
            set { expectedRevisionOption2060 = .streamExists2060(newValue) }
        }

        public var currentRevisionOption: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_CurrentRevisionOption?

        public var currentRevision: UInt64 {
            get {
                if case let .currentRevision(v)? = currentRevisionOption { return v }
                return 0
            }
            set { currentRevisionOption = .currentRevision(newValue) }
        }

        public var currentNoStream: EventStore_Client_Empty {
            get {
                if case let .currentNoStream(v)? = currentRevisionOption { return v }
                return EventStore_Client_Empty()
            }
            set { currentRevisionOption = .currentNoStream(newValue) }
        }

        public var expectedRevisionOption: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_ExpectedRevisionOption?

        public var expectedRevision: UInt64 {
            get {
                if case let .expectedRevision(v)? = expectedRevisionOption { return v }
                return 0
            }
            set { expectedRevisionOption = .expectedRevision(newValue) }
        }

        public var expectedAny: EventStore_Client_Empty {
            get {
                if case let .expectedAny(v)? = expectedRevisionOption { return v }
                return EventStore_Client_Empty()
            }
            set { expectedRevisionOption = .expectedAny(newValue) }
        }

        public var expectedStreamExists: EventStore_Client_Empty {
            get {
                if case let .expectedStreamExists(v)? = expectedRevisionOption { return v }
                return EventStore_Client_Empty()
            }
            set { expectedRevisionOption = .expectedStreamExists(newValue) }
        }

        public var expectedNoStream: EventStore_Client_Empty {
            get {
                if case let .expectedNoStream(v)? = expectedRevisionOption { return v }
                return EventStore_Client_Empty()
            }
            set { expectedRevisionOption = .expectedNoStream(newValue) }
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_CurrentRevisionOption2060: Equatable {
            case currentRevision2060(UInt64)
            case noStream2060(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_CurrentRevisionOption2060, rhs: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_CurrentRevisionOption2060) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.currentRevision2060, .currentRevision2060): {
                            guard case let .currentRevision2060(l) = lhs, case let .currentRevision2060(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.noStream2060, .noStream2060): {
                            guard case let .noStream2060(l) = lhs, case let .noStream2060(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public enum OneOf_ExpectedRevisionOption2060: Equatable {
            case expectedRevision2060(UInt64)
            case any2060(EventStore_Client_Empty)
            case streamExists2060(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_ExpectedRevisionOption2060, rhs: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_ExpectedRevisionOption2060) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.expectedRevision2060, .expectedRevision2060): {
                            guard case let .expectedRevision2060(l) = lhs, case let .expectedRevision2060(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.any2060, .any2060): {
                            guard case let .any2060(l) = lhs, case let .any2060(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.streamExists2060, .streamExists2060): {
                            guard case let .streamExists2060(l) = lhs, case let .streamExists2060(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public enum OneOf_CurrentRevisionOption: Equatable {
            case currentRevision(UInt64)
            case currentNoStream(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_CurrentRevisionOption, rhs: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_CurrentRevisionOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.currentRevision, .currentRevision): {
                            guard case let .currentRevision(l) = lhs, case let .currentRevision(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.currentNoStream, .currentNoStream): {
                            guard case let .currentNoStream(l) = lhs, case let .currentNoStream(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public enum OneOf_ExpectedRevisionOption: Equatable {
            case expectedRevision(UInt64)
            case expectedAny(EventStore_Client_Empty)
            case expectedStreamExists(EventStore_Client_Empty)
            case expectedNoStream(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_ExpectedRevisionOption, rhs: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_ExpectedRevisionOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.expectedRevision, .expectedRevision): {
                            guard case let .expectedRevision(l) = lhs, case let .expectedRevision(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.expectedAny, .expectedAny): {
                            guard case let .expectedAny(l) = lhs, case let .expectedAny(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.expectedStreamExists, .expectedStreamExists): {
                            guard case let .expectedStreamExists(l) = lhs, case let .expectedStreamExists(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.expectedNoStream, .expectedNoStream): {
                            guard case let .expectedNoStream(l) = lhs, case let .expectedNoStream(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public init() {}
    }

    public init() {}
}

public struct EventStore_Client_Streams_BatchAppendReq {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var correlationID: EventStore_Client_UUID {
        get { _correlationID ?? EventStore_Client_UUID() }
        set { _correlationID = newValue }
    }

    /// Returns true if `correlationID` has been explicitly set.
    public var hasCorrelationID: Bool { _correlationID != nil }
    /// Clears the value of `correlationID`. Subsequent reads from it will return its default value.
    public mutating func clearCorrelationID() { _correlationID = nil }

    public var options: EventStore_Client_Streams_BatchAppendReq.Options {
        get { _options ?? EventStore_Client_Streams_BatchAppendReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    public var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    public mutating func clearOptions() { _options = nil }

    public var proposedMessages: [EventStore_Client_Streams_BatchAppendReq.ProposedMessage] = []

    public var isFinal: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Options {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var streamIdentifier: EventStore_Client_StreamIdentifier {
            get { _streamIdentifier ?? EventStore_Client_StreamIdentifier() }
            set { _streamIdentifier = newValue }
        }

        /// Returns true if `streamIdentifier` has been explicitly set.
        public var hasStreamIdentifier: Bool { _streamIdentifier != nil }
        /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
        public mutating func clearStreamIdentifier() { _streamIdentifier = nil }

        public var expectedStreamPosition: EventStore_Client_Streams_BatchAppendReq.Options.OneOf_ExpectedStreamPosition?

        public var streamPosition: UInt64 {
            get {
                if case let .streamPosition(v)? = expectedStreamPosition { return v }
                return 0
            }
            set { expectedStreamPosition = .streamPosition(newValue) }
        }

        public var noStream: SwiftProtobuf.Google_Protobuf_Empty {
            get {
                if case let .noStream(v)? = expectedStreamPosition { return v }
                return SwiftProtobuf.Google_Protobuf_Empty()
            }
            set { expectedStreamPosition = .noStream(newValue) }
        }

        public var any: SwiftProtobuf.Google_Protobuf_Empty {
            get {
                if case let .any(v)? = expectedStreamPosition { return v }
                return SwiftProtobuf.Google_Protobuf_Empty()
            }
            set { expectedStreamPosition = .any(newValue) }
        }

        public var streamExists: SwiftProtobuf.Google_Protobuf_Empty {
            get {
                if case let .streamExists(v)? = expectedStreamPosition { return v }
                return SwiftProtobuf.Google_Protobuf_Empty()
            }
            set { expectedStreamPosition = .streamExists(newValue) }
        }

        public var deadlineOption: EventStore_Client_Streams_BatchAppendReq.Options.OneOf_DeadlineOption?

        public var deadline21100: SwiftProtobuf.Google_Protobuf_Timestamp {
            get {
                if case let .deadline21100(v)? = deadlineOption { return v }
                return SwiftProtobuf.Google_Protobuf_Timestamp()
            }
            set { deadlineOption = .deadline21100(newValue) }
        }

        public var deadline: SwiftProtobuf.Google_Protobuf_Duration {
            get {
                if case let .deadline(v)? = deadlineOption { return v }
                return SwiftProtobuf.Google_Protobuf_Duration()
            }
            set { deadlineOption = .deadline(newValue) }
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_ExpectedStreamPosition: Equatable {
            case streamPosition(UInt64)
            case noStream(SwiftProtobuf.Google_Protobuf_Empty)
            case any(SwiftProtobuf.Google_Protobuf_Empty)
            case streamExists(SwiftProtobuf.Google_Protobuf_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_Streams_BatchAppendReq.Options.OneOf_ExpectedStreamPosition, rhs: EventStore_Client_Streams_BatchAppendReq.Options.OneOf_ExpectedStreamPosition) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.streamPosition, .streamPosition): {
                            guard case let .streamPosition(l) = lhs, case let .streamPosition(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.noStream, .noStream): {
                            guard case let .noStream(l) = lhs, case let .noStream(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.any, .any): {
                            guard case let .any(l) = lhs, case let .any(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.streamExists, .streamExists): {
                            guard case let .streamExists(l) = lhs, case let .streamExists(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public enum OneOf_DeadlineOption: Equatable {
            case deadline21100(SwiftProtobuf.Google_Protobuf_Timestamp)
            case deadline(SwiftProtobuf.Google_Protobuf_Duration)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_Streams_BatchAppendReq.Options.OneOf_DeadlineOption, rhs: EventStore_Client_Streams_BatchAppendReq.Options.OneOf_DeadlineOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.deadline21100, .deadline21100): {
                            guard case let .deadline21100(l) = lhs, case let .deadline21100(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.deadline, .deadline): {
                            guard case let .deadline(l) = lhs, case let .deadline(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public init() {}

        fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier?
    }

    public struct ProposedMessage {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: EventStore_Client_UUID {
            get { _id ?? EventStore_Client_UUID() }
            set { _id = newValue }
        }

        /// Returns true if `id` has been explicitly set.
        public var hasID: Bool { _id != nil }
        /// Clears the value of `id`. Subsequent reads from it will return its default value.
        public mutating func clearID() { _id = nil }

        public var metadata: [String: String] = [:]

        public var customMetadata: Data = .init()

        public var data: Data = .init()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _id: EventStore_Client_UUID?
    }

    public init() {}

    fileprivate var _correlationID: EventStore_Client_UUID?
    fileprivate var _options: EventStore_Client_Streams_BatchAppendReq.Options?
}

public struct EventStore_Client_Streams_BatchAppendResp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var correlationID: EventStore_Client_UUID {
        get { _correlationID ?? EventStore_Client_UUID() }
        set { _correlationID = newValue }
    }

    /// Returns true if `correlationID` has been explicitly set.
    public var hasCorrelationID: Bool { _correlationID != nil }
    /// Clears the value of `correlationID`. Subsequent reads from it will return its default value.
    public mutating func clearCorrelationID() { _correlationID = nil }

    public var result: EventStore_Client_Streams_BatchAppendResp.OneOf_Result?

    public var error: Google_Rpc_Status {
        get {
            if case let .error(v)? = result { return v }
            return Google_Rpc_Status()
        }
        set { result = .error(newValue) }
    }

    public var success: EventStore_Client_Streams_BatchAppendResp.Success {
        get {
            if case let .success(v)? = result { return v }
            return EventStore_Client_Streams_BatchAppendResp.Success()
        }
        set { result = .success(newValue) }
    }

    public var streamIdentifier: EventStore_Client_StreamIdentifier {
        get { _streamIdentifier ?? EventStore_Client_StreamIdentifier() }
        set { _streamIdentifier = newValue }
    }

    /// Returns true if `streamIdentifier` has been explicitly set.
    public var hasStreamIdentifier: Bool { _streamIdentifier != nil }
    /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
    public mutating func clearStreamIdentifier() { _streamIdentifier = nil }

    public var expectedStreamPosition: EventStore_Client_Streams_BatchAppendResp.OneOf_ExpectedStreamPosition?

    public var streamPosition: UInt64 {
        get {
            if case let .streamPosition(v)? = expectedStreamPosition { return v }
            return 0
        }
        set { expectedStreamPosition = .streamPosition(newValue) }
    }

    public var noStream: SwiftProtobuf.Google_Protobuf_Empty {
        get {
            if case let .noStream(v)? = expectedStreamPosition { return v }
            return SwiftProtobuf.Google_Protobuf_Empty()
        }
        set { expectedStreamPosition = .noStream(newValue) }
    }

    public var any: SwiftProtobuf.Google_Protobuf_Empty {
        get {
            if case let .any(v)? = expectedStreamPosition { return v }
            return SwiftProtobuf.Google_Protobuf_Empty()
        }
        set { expectedStreamPosition = .any(newValue) }
    }

    public var streamExists: SwiftProtobuf.Google_Protobuf_Empty {
        get {
            if case let .streamExists(v)? = expectedStreamPosition { return v }
            return SwiftProtobuf.Google_Protobuf_Empty()
        }
        set { expectedStreamPosition = .streamExists(newValue) }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Result: Equatable {
        case error(Google_Rpc_Status)
        case success(EventStore_Client_Streams_BatchAppendResp.Success)

        #if !swift(>=4.1)
            public static func == (lhs: EventStore_Client_Streams_BatchAppendResp.OneOf_Result, rhs: EventStore_Client_Streams_BatchAppendResp.OneOf_Result) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.error, .error): {
                        guard case let .error(l) = lhs, case let .error(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.success, .success): {
                        guard case let .success(l) = lhs, case let .success(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: false
                }
            }
        #endif
    }

    public enum OneOf_ExpectedStreamPosition: Equatable {
        case streamPosition(UInt64)
        case noStream(SwiftProtobuf.Google_Protobuf_Empty)
        case any(SwiftProtobuf.Google_Protobuf_Empty)
        case streamExists(SwiftProtobuf.Google_Protobuf_Empty)

        #if !swift(>=4.1)
            public static func == (lhs: EventStore_Client_Streams_BatchAppendResp.OneOf_ExpectedStreamPosition, rhs: EventStore_Client_Streams_BatchAppendResp.OneOf_ExpectedStreamPosition) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.streamPosition, .streamPosition): {
                        guard case let .streamPosition(l) = lhs, case let .streamPosition(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.noStream, .noStream): {
                        guard case let .noStream(l) = lhs, case let .noStream(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.any, .any): {
                        guard case let .any(l) = lhs, case let .any(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.streamExists, .streamExists): {
                        guard case let .streamExists(l) = lhs, case let .streamExists(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: false
                }
            }
        #endif
    }

    public struct Success {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var currentRevisionOption: EventStore_Client_Streams_BatchAppendResp.Success.OneOf_CurrentRevisionOption?

        public var currentRevision: UInt64 {
            get {
                if case let .currentRevision(v)? = currentRevisionOption { return v }
                return 0
            }
            set { currentRevisionOption = .currentRevision(newValue) }
        }

        public var noStream: SwiftProtobuf.Google_Protobuf_Empty {
            get {
                if case let .noStream(v)? = currentRevisionOption { return v }
                return SwiftProtobuf.Google_Protobuf_Empty()
            }
            set { currentRevisionOption = .noStream(newValue) }
        }

        public var positionOption: EventStore_Client_Streams_BatchAppendResp.Success.OneOf_PositionOption?

        public var position: EventStore_Client_AllStreamPosition {
            get {
                if case let .position(v)? = positionOption { return v }
                return EventStore_Client_AllStreamPosition()
            }
            set { positionOption = .position(newValue) }
        }

        public var noPosition: SwiftProtobuf.Google_Protobuf_Empty {
            get {
                if case let .noPosition(v)? = positionOption { return v }
                return SwiftProtobuf.Google_Protobuf_Empty()
            }
            set { positionOption = .noPosition(newValue) }
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_CurrentRevisionOption: Equatable {
            case currentRevision(UInt64)
            case noStream(SwiftProtobuf.Google_Protobuf_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_Streams_BatchAppendResp.Success.OneOf_CurrentRevisionOption, rhs: EventStore_Client_Streams_BatchAppendResp.Success.OneOf_CurrentRevisionOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.currentRevision, .currentRevision): {
                            guard case let .currentRevision(l) = lhs, case let .currentRevision(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.noStream, .noStream): {
                            guard case let .noStream(l) = lhs, case let .noStream(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public enum OneOf_PositionOption: Equatable {
            case position(EventStore_Client_AllStreamPosition)
            case noPosition(SwiftProtobuf.Google_Protobuf_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_Streams_BatchAppendResp.Success.OneOf_PositionOption, rhs: EventStore_Client_Streams_BatchAppendResp.Success.OneOf_PositionOption) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.position, .position): {
                            guard case let .position(l) = lhs, case let .position(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.noPosition, .noPosition): {
                            guard case let .noPosition(l) = lhs, case let .noPosition(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public init() {}
    }

    public init() {}

    fileprivate var _correlationID: EventStore_Client_UUID?
    fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier?
}

public struct EventStore_Client_Streams_DeleteReq {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var options: EventStore_Client_Streams_DeleteReq.Options {
        get { _options ?? EventStore_Client_Streams_DeleteReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    public var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    public mutating func clearOptions() { _options = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Options {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var streamIdentifier: EventStore_Client_StreamIdentifier {
            get { _streamIdentifier ?? EventStore_Client_StreamIdentifier() }
            set { _streamIdentifier = newValue }
        }

        /// Returns true if `streamIdentifier` has been explicitly set.
        public var hasStreamIdentifier: Bool { _streamIdentifier != nil }
        /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
        public mutating func clearStreamIdentifier() { _streamIdentifier = nil }

        public var expectedStreamRevision: EventStore_Client_Streams_DeleteReq.Options.OneOf_ExpectedStreamRevision?

        public var revision: UInt64 {
            get {
                if case let .revision(v)? = expectedStreamRevision { return v }
                return 0
            }
            set { expectedStreamRevision = .revision(newValue) }
        }

        public var noStream: EventStore_Client_Empty {
            get {
                if case let .noStream(v)? = expectedStreamRevision { return v }
                return EventStore_Client_Empty()
            }
            set { expectedStreamRevision = .noStream(newValue) }
        }

        public var any: EventStore_Client_Empty {
            get {
                if case let .any(v)? = expectedStreamRevision { return v }
                return EventStore_Client_Empty()
            }
            set { expectedStreamRevision = .any(newValue) }
        }

        public var streamExists: EventStore_Client_Empty {
            get {
                if case let .streamExists(v)? = expectedStreamRevision { return v }
                return EventStore_Client_Empty()
            }
            set { expectedStreamRevision = .streamExists(newValue) }
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_ExpectedStreamRevision: Equatable {
            case revision(UInt64)
            case noStream(EventStore_Client_Empty)
            case any(EventStore_Client_Empty)
            case streamExists(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_Streams_DeleteReq.Options.OneOf_ExpectedStreamRevision, rhs: EventStore_Client_Streams_DeleteReq.Options.OneOf_ExpectedStreamRevision) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.revision, .revision): {
                            guard case let .revision(l) = lhs, case let .revision(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.noStream, .noStream): {
                            guard case let .noStream(l) = lhs, case let .noStream(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.any, .any): {
                            guard case let .any(l) = lhs, case let .any(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.streamExists, .streamExists): {
                            guard case let .streamExists(l) = lhs, case let .streamExists(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public init() {}

        fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier?
    }

    public init() {}

    fileprivate var _options: EventStore_Client_Streams_DeleteReq.Options?
}

public struct EventStore_Client_Streams_DeleteResp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var positionOption: EventStore_Client_Streams_DeleteResp.OneOf_PositionOption?

    public var position: EventStore_Client_Streams_DeleteResp.Position {
        get {
            if case let .position(v)? = positionOption { return v }
            return EventStore_Client_Streams_DeleteResp.Position()
        }
        set { positionOption = .position(newValue) }
    }

    public var noPosition: EventStore_Client_Empty {
        get {
            if case let .noPosition(v)? = positionOption { return v }
            return EventStore_Client_Empty()
        }
        set { positionOption = .noPosition(newValue) }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_PositionOption: Equatable {
        case position(EventStore_Client_Streams_DeleteResp.Position)
        case noPosition(EventStore_Client_Empty)

        #if !swift(>=4.1)
            public static func == (lhs: EventStore_Client_Streams_DeleteResp.OneOf_PositionOption, rhs: EventStore_Client_Streams_DeleteResp.OneOf_PositionOption) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.position, .position): {
                        guard case let .position(l) = lhs, case let .position(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.noPosition, .noPosition): {
                        guard case let .noPosition(l) = lhs, case let .noPosition(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: false
                }
            }
        #endif
    }

    public struct Position {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var commitPosition: UInt64 = 0

        public var preparePosition: UInt64 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public init() {}
}

public struct EventStore_Client_Streams_TombstoneReq {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var options: EventStore_Client_Streams_TombstoneReq.Options {
        get { _options ?? EventStore_Client_Streams_TombstoneReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    public var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    public mutating func clearOptions() { _options = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Options {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var streamIdentifier: EventStore_Client_StreamIdentifier {
            get { _streamIdentifier ?? EventStore_Client_StreamIdentifier() }
            set { _streamIdentifier = newValue }
        }

        /// Returns true if `streamIdentifier` has been explicitly set.
        public var hasStreamIdentifier: Bool { _streamIdentifier != nil }
        /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
        public mutating func clearStreamIdentifier() { _streamIdentifier = nil }

        public var expectedStreamRevision: EventStore_Client_Streams_TombstoneReq.Options.OneOf_ExpectedStreamRevision?

        public var revision: UInt64 {
            get {
                if case let .revision(v)? = expectedStreamRevision { return v }
                return 0
            }
            set { expectedStreamRevision = .revision(newValue) }
        }

        public var noStream: EventStore_Client_Empty {
            get {
                if case let .noStream(v)? = expectedStreamRevision { return v }
                return EventStore_Client_Empty()
            }
            set { expectedStreamRevision = .noStream(newValue) }
        }

        public var any: EventStore_Client_Empty {
            get {
                if case let .any(v)? = expectedStreamRevision { return v }
                return EventStore_Client_Empty()
            }
            set { expectedStreamRevision = .any(newValue) }
        }

        public var streamExists: EventStore_Client_Empty {
            get {
                if case let .streamExists(v)? = expectedStreamRevision { return v }
                return EventStore_Client_Empty()
            }
            set { expectedStreamRevision = .streamExists(newValue) }
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_ExpectedStreamRevision: Equatable {
            case revision(UInt64)
            case noStream(EventStore_Client_Empty)
            case any(EventStore_Client_Empty)
            case streamExists(EventStore_Client_Empty)

            #if !swift(>=4.1)
                public static func == (lhs: EventStore_Client_Streams_TombstoneReq.Options.OneOf_ExpectedStreamRevision, rhs: EventStore_Client_Streams_TombstoneReq.Options.OneOf_ExpectedStreamRevision) -> Bool {
                    // The use of inline closures is to circumvent an issue where the compiler
                    // allocates stack space for every case branch when no optimizations are
                    // enabled. https://github.com/apple/swift-protobuf/issues/1034
                    switch (lhs, rhs) {
                    case (.revision, .revision): {
                            guard case let .revision(l) = lhs, case let .revision(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.noStream, .noStream): {
                            guard case let .noStream(l) = lhs, case let .noStream(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.any, .any): {
                            guard case let .any(l) = lhs, case let .any(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    case (.streamExists, .streamExists): {
                            guard case let .streamExists(l) = lhs, case let .streamExists(r) = rhs else { preconditionFailure() }
                            return l == r
                        }()
                    default: false
                    }
                }
            #endif
        }

        public init() {}

        fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier?
    }

    public init() {}

    fileprivate var _options: EventStore_Client_Streams_TombstoneReq.Options?
}

public struct EventStore_Client_Streams_TombstoneResp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var positionOption: EventStore_Client_Streams_TombstoneResp.OneOf_PositionOption?

    public var position: EventStore_Client_Streams_TombstoneResp.Position {
        get {
            if case let .position(v)? = positionOption { return v }
            return EventStore_Client_Streams_TombstoneResp.Position()
        }
        set { positionOption = .position(newValue) }
    }

    public var noPosition: EventStore_Client_Empty {
        get {
            if case let .noPosition(v)? = positionOption { return v }
            return EventStore_Client_Empty()
        }
        set { positionOption = .noPosition(newValue) }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_PositionOption: Equatable {
        case position(EventStore_Client_Streams_TombstoneResp.Position)
        case noPosition(EventStore_Client_Empty)

        #if !swift(>=4.1)
            public static func == (lhs: EventStore_Client_Streams_TombstoneResp.OneOf_PositionOption, rhs: EventStore_Client_Streams_TombstoneResp.OneOf_PositionOption) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.position, .position): {
                        guard case let .position(l) = lhs, case let .position(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.noPosition, .noPosition): {
                        guard case let .noPosition(l) = lhs, case let .noPosition(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: false
                }
            }
        #endif
    }

    public struct Position {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var commitPosition: UInt64 = 0

        public var preparePosition: UInt64 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
    extension EventStore_Client_Streams_ReadReq: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadReq.Options: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadReq.Options.OneOf_StreamOption: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadReq.Options.OneOf_CountOption: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadReq.Options.OneOf_FilterOption: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadReq.Options.ReadDirection: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadReq.Options.StreamOptions: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadReq.Options.StreamOptions.OneOf_RevisionOption: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadReq.Options.AllOptions: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadReq.Options.AllOptions.OneOf_AllOption: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadReq.Options.Position: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadReq.Options.FilterOptions: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadReq.Options.FilterOptions.OneOf_Filter: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadReq.Options.FilterOptions.OneOf_Window: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadReq.Options.UUIDOption: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadReq.Options.UUIDOption.OneOf_Content: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadReq.Options.ControlOption: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadResp: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadResp.OneOf_Content: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadResp.CaughtUp: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadResp.FellBehind: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadResp.ReadEvent: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadResp.ReadEvent.OneOf_Position: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadResp.SubscriptionConfirmation: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadResp.Checkpoint: @unchecked Sendable {}
    extension EventStore_Client_Streams_ReadResp.StreamNotFound: @unchecked Sendable {}
    extension EventStore_Client_Streams_AppendReq: @unchecked Sendable {}
    extension EventStore_Client_Streams_AppendReq.OneOf_Content: @unchecked Sendable {}
    extension EventStore_Client_Streams_AppendReq.Options: @unchecked Sendable {}
    extension EventStore_Client_Streams_AppendReq.Options.OneOf_ExpectedStreamRevision: @unchecked Sendable {}
    extension EventStore_Client_Streams_AppendReq.ProposedMessage: @unchecked Sendable {}
    extension EventStore_Client_Streams_AppendResp: @unchecked Sendable {}
    extension EventStore_Client_Streams_AppendResp.OneOf_Result: @unchecked Sendable {}
    extension EventStore_Client_Streams_AppendResp.Position: @unchecked Sendable {}
    extension EventStore_Client_Streams_AppendResp.Success: @unchecked Sendable {}
    extension EventStore_Client_Streams_AppendResp.Success.OneOf_CurrentRevisionOption: @unchecked Sendable {}
    extension EventStore_Client_Streams_AppendResp.Success.OneOf_PositionOption: @unchecked Sendable {}
    extension EventStore_Client_Streams_AppendResp.WrongExpectedVersion: @unchecked Sendable {}
    extension EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_CurrentRevisionOption2060: @unchecked Sendable {}
    extension EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_ExpectedRevisionOption2060: @unchecked Sendable {}
    extension EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_CurrentRevisionOption: @unchecked Sendable {}
    extension EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_ExpectedRevisionOption: @unchecked Sendable {}
    extension EventStore_Client_Streams_BatchAppendReq: @unchecked Sendable {}
    extension EventStore_Client_Streams_BatchAppendReq.Options: @unchecked Sendable {}
    extension EventStore_Client_Streams_BatchAppendReq.Options.OneOf_ExpectedStreamPosition: @unchecked Sendable {}
    extension EventStore_Client_Streams_BatchAppendReq.Options.OneOf_DeadlineOption: @unchecked Sendable {}
    extension EventStore_Client_Streams_BatchAppendReq.ProposedMessage: @unchecked Sendable {}
    extension EventStore_Client_Streams_BatchAppendResp: @unchecked Sendable {}
    extension EventStore_Client_Streams_BatchAppendResp.OneOf_Result: @unchecked Sendable {}
    extension EventStore_Client_Streams_BatchAppendResp.OneOf_ExpectedStreamPosition: @unchecked Sendable {}
    extension EventStore_Client_Streams_BatchAppendResp.Success: @unchecked Sendable {}
    extension EventStore_Client_Streams_BatchAppendResp.Success.OneOf_CurrentRevisionOption: @unchecked Sendable {}
    extension EventStore_Client_Streams_BatchAppendResp.Success.OneOf_PositionOption: @unchecked Sendable {}
    extension EventStore_Client_Streams_DeleteReq: @unchecked Sendable {}
    extension EventStore_Client_Streams_DeleteReq.Options: @unchecked Sendable {}
    extension EventStore_Client_Streams_DeleteReq.Options.OneOf_ExpectedStreamRevision: @unchecked Sendable {}
    extension EventStore_Client_Streams_DeleteResp: @unchecked Sendable {}
    extension EventStore_Client_Streams_DeleteResp.OneOf_PositionOption: @unchecked Sendable {}
    extension EventStore_Client_Streams_DeleteResp.Position: @unchecked Sendable {}
    extension EventStore_Client_Streams_TombstoneReq: @unchecked Sendable {}
    extension EventStore_Client_Streams_TombstoneReq.Options: @unchecked Sendable {}
    extension EventStore_Client_Streams_TombstoneReq.Options.OneOf_ExpectedStreamRevision: @unchecked Sendable {}
    extension EventStore_Client_Streams_TombstoneResp: @unchecked Sendable {}
    extension EventStore_Client_Streams_TombstoneResp.OneOf_PositionOption: @unchecked Sendable {}
    extension EventStore_Client_Streams_TombstoneResp.Position: @unchecked Sendable {}
#endif // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "event_store.client.streams"

extension EventStore_Client_Streams_ReadReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ReadReq"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_ReadReq, rhs: EventStore_Client_Streams_ReadReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_ReadReq.protoMessageName + ".Options"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "stream"),
        2: .same(proto: "all"),
        3: .standard(proto: "read_direction"),
        4: .standard(proto: "resolve_links"),
        5: .same(proto: "count"),
        6: .same(proto: "subscription"),
        7: .same(proto: "filter"),
        8: .standard(proto: "no_filter"),
        9: .standard(proto: "uuid_option"),
        10: .standard(proto: "control_option"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_Streams_ReadReq.Options.StreamOptions?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .stream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .stream(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Streams_ReadReq.Options.AllOptions?
                    var hadOneofValue = false
                    if let current = self.streamOption {
                        hadOneofValue = true
                        if case let .all(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.streamOption = .all(v)
                    }
                }()
            case 3: try decoder.decodeSingularEnumField(value: &readDirection)
            case 4: try decoder.decodeSingularBoolField(value: &resolveLinks)
            case 5: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.countOption != nil { try decoder.handleConflictingOneOf() }
                        self.countOption = .count(v)
                    }
                }()
            case 6: try {
                    var v: EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions?
                    var hadOneofValue = false
                    if let current = self.countOption {
                        hadOneofValue = true
                        if case let .subscription(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.countOption = .subscription(v)
                    }
                }()
            case 7: try {
                    var v: EventStore_Client_Streams_ReadReq.Options.FilterOptions?
                    var hadOneofValue = false
                    if let current = self.filterOption {
                        hadOneofValue = true
                        if case let .filter(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.filterOption = .filter(v)
                    }
                }()
            case 8: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.filterOption {
                        hadOneofValue = true
                        if case let .noFilter(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.filterOption = .noFilter(v)
                    }
                }()
            case 9: try decoder.decodeSingularMessageField(value: &_uuidOption)
            case 10: try decoder.decodeSingularMessageField(value: &_controlOption)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch streamOption {
        case .stream?: try {
                guard case let .stream(v)? = self.streamOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .all?: try {
                guard case let .all(v)? = self.streamOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        if readDirection != .forwards {
            try visitor.visitSingularEnumField(value: readDirection, fieldNumber: 3)
        }
        if resolveLinks != false {
            try visitor.visitSingularBoolField(value: resolveLinks, fieldNumber: 4)
        }
        switch countOption {
        case .count?: try {
                guard case let .count(v)? = self.countOption else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
            }()
        case .subscription?: try {
                guard case let .subscription(v)? = self.countOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
            }()
        case nil: break
        }
        switch filterOption {
        case .filter?: try {
                guard case let .filter(v)? = self.filterOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
            }()
        case .noFilter?: try {
                guard case let .noFilter(v)? = self.filterOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
            }()
        case nil: break
        }
        try { if let v = self._uuidOption {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
        } }()
        try { if let v = self._controlOption {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_ReadReq.Options, rhs: EventStore_Client_Streams_ReadReq.Options) -> Bool {
        if lhs.streamOption != rhs.streamOption { return false }
        if lhs.readDirection != rhs.readDirection { return false }
        if lhs.resolveLinks != rhs.resolveLinks { return false }
        if lhs.countOption != rhs.countOption { return false }
        if lhs.filterOption != rhs.filterOption { return false }
        if lhs._uuidOption != rhs._uuidOption { return false }
        if lhs._controlOption != rhs._controlOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadReq.Options.ReadDirection: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Forwards"),
        1: .same(proto: "Backwards"),
    ]
}

extension EventStore_Client_Streams_ReadReq.Options.StreamOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.protoMessageName + ".StreamOptions"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        2: .same(proto: "revision"),
        3: .same(proto: "start"),
        4: .same(proto: "end"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_streamIdentifier)
            case 2: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.revisionOption != nil { try decoder.handleConflictingOneOf() }
                        self.revisionOption = .revision(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.revisionOption {
                        hadOneofValue = true
                        if case let .start(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.revisionOption = .start(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.revisionOption {
                        hadOneofValue = true
                        if case let .end(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.revisionOption = .end(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _streamIdentifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        switch revisionOption {
        case .revision?: try {
                guard case let .revision(v)? = self.revisionOption else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
            }()
        case .start?: try {
                guard case let .start(v)? = self.revisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .end?: try {
                guard case let .end(v)? = self.revisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_ReadReq.Options.StreamOptions, rhs: EventStore_Client_Streams_ReadReq.Options.StreamOptions) -> Bool {
        if lhs._streamIdentifier != rhs._streamIdentifier { return false }
        if lhs.revisionOption != rhs.revisionOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadReq.Options.AllOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.protoMessageName + ".AllOptions"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "position"),
        2: .same(proto: "start"),
        3: .same(proto: "end"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_Streams_ReadReq.Options.Position?
                    var hadOneofValue = false
                    if let current = self.allOption {
                        hadOneofValue = true
                        if case let .position(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.allOption = .position(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.allOption {
                        hadOneofValue = true
                        if case let .start(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.allOption = .start(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.allOption {
                        hadOneofValue = true
                        if case let .end(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.allOption = .end(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch allOption {
        case .position?: try {
                guard case let .position(v)? = self.allOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .start?: try {
                guard case let .start(v)? = self.allOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .end?: try {
                guard case let .end(v)? = self.allOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_ReadReq.Options.AllOptions, rhs: EventStore_Client_Streams_ReadReq.Options.AllOptions) -> Bool {
        if lhs.allOption != rhs.allOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.protoMessageName + ".SubscriptionOptions"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions, rhs: EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadReq.Options.Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.protoMessageName + ".Position"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "commit_position"),
        2: .standard(proto: "prepare_position"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt64Field(value: &commitPosition)
            case 2: try decoder.decodeSingularUInt64Field(value: &preparePosition)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if commitPosition != 0 {
            try visitor.visitSingularUInt64Field(value: commitPosition, fieldNumber: 1)
        }
        if preparePosition != 0 {
            try visitor.visitSingularUInt64Field(value: preparePosition, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_ReadReq.Options.Position, rhs: EventStore_Client_Streams_ReadReq.Options.Position) -> Bool {
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadReq.Options.FilterOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.protoMessageName + ".FilterOptions"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        2: .standard(proto: "event_type"),
        3: .same(proto: "max"),
        4: .same(proto: "count"),
        5: .same(proto: "checkpointIntervalMultiplier"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression?
                    var hadOneofValue = false
                    if let current = self.filter {
                        hadOneofValue = true
                        if case let .streamIdentifier(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.filter = .streamIdentifier(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression?
                    var hadOneofValue = false
                    if let current = self.filter {
                        hadOneofValue = true
                        if case let .eventType(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.filter = .eventType(v)
                    }
                }()
            case 3: try {
                    var v: UInt32?
                    try decoder.decodeSingularUInt32Field(value: &v)
                    if let v {
                        if self.window != nil { try decoder.handleConflictingOneOf() }
                        self.window = .max(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.window {
                        hadOneofValue = true
                        if case let .count(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.window = .count(v)
                    }
                }()
            case 5: try decoder.decodeSingularUInt32Field(value: &checkpointIntervalMultiplier)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch filter {
        case .streamIdentifier?: try {
                guard case let .streamIdentifier(v)? = self.filter else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .eventType?: try {
                guard case let .eventType(v)? = self.filter else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        switch window {
        case .max?: try {
                guard case let .max(v)? = self.window else { preconditionFailure() }
                try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
            }()
        case .count?: try {
                guard case let .count(v)? = self.window else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case nil: break
        }
        if checkpointIntervalMultiplier != 0 {
            try visitor.visitSingularUInt32Field(value: checkpointIntervalMultiplier, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_ReadReq.Options.FilterOptions, rhs: EventStore_Client_Streams_ReadReq.Options.FilterOptions) -> Bool {
        if lhs.filter != rhs.filter { return false }
        if lhs.window != rhs.window { return false }
        if lhs.checkpointIntervalMultiplier != rhs.checkpointIntervalMultiplier { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.FilterOptions.protoMessageName + ".Expression"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "regex"),
        2: .same(proto: "prefix"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &regex)
            case 2: try decoder.decodeRepeatedStringField(value: &prefix)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !regex.isEmpty {
            try visitor.visitSingularStringField(value: regex, fieldNumber: 1)
        }
        if !prefix.isEmpty {
            try visitor.visitRepeatedStringField(value: prefix, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression, rhs: EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression) -> Bool {
        if lhs.regex != rhs.regex { return false }
        if lhs.prefix != rhs.prefix { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadReq.Options.UUIDOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.protoMessageName + ".UUIDOption"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "structured"),
        2: .same(proto: "string"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .structured(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .structured(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .string(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .string(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch content {
        case .structured?: try {
                guard case let .structured(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .string?: try {
                guard case let .string(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_ReadReq.Options.UUIDOption, rhs: EventStore_Client_Streams_ReadReq.Options.UUIDOption) -> Bool {
        if lhs.content != rhs.content { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadReq.Options.ControlOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.protoMessageName + ".ControlOption"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "compatibility"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt32Field(value: &compatibility)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if compatibility != 0 {
            try visitor.visitSingularUInt32Field(value: compatibility, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_ReadReq.Options.ControlOption, rhs: EventStore_Client_Streams_ReadReq.Options.ControlOption) -> Bool {
        if lhs.compatibility != rhs.compatibility { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ReadResp"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "event"),
        2: .same(proto: "confirmation"),
        3: .same(proto: "checkpoint"),
        4: .standard(proto: "stream_not_found"),
        5: .standard(proto: "first_stream_position"),
        6: .standard(proto: "last_stream_position"),
        7: .standard(proto: "last_all_stream_position"),
        8: .standard(proto: "caught_up"),
        9: .standard(proto: "fell_behind"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_Streams_ReadResp.ReadEvent?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .event(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .event(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Streams_ReadResp.SubscriptionConfirmation?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .confirmation(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .confirmation(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Streams_ReadResp.Checkpoint?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .checkpoint(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .checkpoint(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_Streams_ReadResp.StreamNotFound?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .streamNotFound(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .streamNotFound(v)
                    }
                }()
            case 5: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.content != nil { try decoder.handleConflictingOneOf() }
                        self.content = .firstStreamPosition(v)
                    }
                }()
            case 6: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.content != nil { try decoder.handleConflictingOneOf() }
                        self.content = .lastStreamPosition(v)
                    }
                }()
            case 7: try {
                    var v: EventStore_Client_AllStreamPosition?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .lastAllStreamPosition(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .lastAllStreamPosition(v)
                    }
                }()
            case 8: try {
                    var v: EventStore_Client_Streams_ReadResp.CaughtUp?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .caughtUp(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .caughtUp(v)
                    }
                }()
            case 9: try {
                    var v: EventStore_Client_Streams_ReadResp.FellBehind?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .fellBehind(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .fellBehind(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch content {
        case .event?: try {
                guard case let .event(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .confirmation?: try {
                guard case let .confirmation(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .checkpoint?: try {
                guard case let .checkpoint(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .streamNotFound?: try {
                guard case let .streamNotFound(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .firstStreamPosition?: try {
                guard case let .firstStreamPosition(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
            }()
        case .lastStreamPosition?: try {
                guard case let .lastStreamPosition(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
            }()
        case .lastAllStreamPosition?: try {
                guard case let .lastAllStreamPosition(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
            }()
        case .caughtUp?: try {
                guard case let .caughtUp(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
            }()
        case .fellBehind?: try {
                guard case let .fellBehind(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_ReadResp, rhs: EventStore_Client_Streams_ReadResp) -> Bool {
        if lhs.content != rhs.content { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadResp.CaughtUp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_ReadResp.protoMessageName + ".CaughtUp"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_ReadResp.CaughtUp, rhs: EventStore_Client_Streams_ReadResp.CaughtUp) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadResp.FellBehind: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_ReadResp.protoMessageName + ".FellBehind"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_ReadResp.FellBehind, rhs: EventStore_Client_Streams_ReadResp.FellBehind) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadResp.ReadEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_ReadResp.protoMessageName + ".ReadEvent"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "event"),
        2: .same(proto: "link"),
        3: .standard(proto: "commit_position"),
        4: .standard(proto: "no_position"),
    ]

    fileprivate class _StorageClass {
        var _event: EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent?
        var _link: EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent?
        var _position: EventStore_Client_Streams_ReadResp.ReadEvent.OneOf_Position?

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _event = source._event
            _link = source._link
            _position = source._position
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularMessageField(value: &_storage._event)
                case 2: try decoder.decodeSingularMessageField(value: &_storage._link)
                case 3: try {
                        var v: UInt64?
                        try decoder.decodeSingularUInt64Field(value: &v)
                        if let v {
                            if _storage._position != nil { try decoder.handleConflictingOneOf() }
                            _storage._position = .commitPosition(v)
                        }
                    }()
                case 4: try {
                        var v: EventStore_Client_Empty?
                        var hadOneofValue = false
                        if let current = _storage._position {
                            hadOneofValue = true
                            if case let .noPosition(m) = current { v = m }
                        }
                        try decoder.decodeSingularMessageField(value: &v)
                        if let v {
                            if hadOneofValue { try decoder.handleConflictingOneOf() }
                            _storage._position = .noPosition(v)
                        }
                    }()
                default: break
                }
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._event {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            try { if let v = _storage._link {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            } }()
            switch _storage._position {
            case .commitPosition?: try {
                    guard case let .commitPosition(v)? = _storage._position else { preconditionFailure() }
                    try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
                }()
            case .noPosition?: try {
                    guard case let .noPosition(v)? = _storage._position else { preconditionFailure() }
                    try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
                }()
            case nil: break
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_ReadResp.ReadEvent, rhs: EventStore_Client_Streams_ReadResp.ReadEvent) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._event != rhs_storage._event { return false }
                if _storage._link != rhs_storage._link { return false }
                if _storage._position != rhs_storage._position { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_ReadResp.ReadEvent.protoMessageName + ".RecordedEvent"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .standard(proto: "stream_identifier"),
        3: .standard(proto: "stream_revision"),
        4: .standard(proto: "prepare_position"),
        5: .standard(proto: "commit_position"),
        6: .same(proto: "metadata"),
        7: .standard(proto: "custom_metadata"),
        8: .same(proto: "data"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_id)
            case 2: try decoder.decodeSingularMessageField(value: &_streamIdentifier)
            case 3: try decoder.decodeSingularUInt64Field(value: &streamRevision)
            case 4: try decoder.decodeSingularUInt64Field(value: &preparePosition)
            case 5: try decoder.decodeSingularUInt64Field(value: &commitPosition)
            case 6: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: &metadata)
            case 7: try decoder.decodeSingularBytesField(value: &customMetadata)
            case 8: try decoder.decodeSingularBytesField(value: &data)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _id {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try { if let v = self._streamIdentifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if streamRevision != 0 {
            try visitor.visitSingularUInt64Field(value: streamRevision, fieldNumber: 3)
        }
        if preparePosition != 0 {
            try visitor.visitSingularUInt64Field(value: preparePosition, fieldNumber: 4)
        }
        if commitPosition != 0 {
            try visitor.visitSingularUInt64Field(value: commitPosition, fieldNumber: 5)
        }
        if !metadata.isEmpty {
            try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: metadata, fieldNumber: 6)
        }
        if !customMetadata.isEmpty {
            try visitor.visitSingularBytesField(value: customMetadata, fieldNumber: 7)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent, rhs: EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent) -> Bool {
        if lhs._id != rhs._id { return false }
        if lhs._streamIdentifier != rhs._streamIdentifier { return false }
        if lhs.streamRevision != rhs.streamRevision { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.metadata != rhs.metadata { return false }
        if lhs.customMetadata != rhs.customMetadata { return false }
        if lhs.data != rhs.data { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadResp.SubscriptionConfirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_ReadResp.protoMessageName + ".SubscriptionConfirmation"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "subscription_id"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &subscriptionID)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !subscriptionID.isEmpty {
            try visitor.visitSingularStringField(value: subscriptionID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_ReadResp.SubscriptionConfirmation, rhs: EventStore_Client_Streams_ReadResp.SubscriptionConfirmation) -> Bool {
        if lhs.subscriptionID != rhs.subscriptionID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadResp.Checkpoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_ReadResp.protoMessageName + ".Checkpoint"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "commit_position"),
        2: .standard(proto: "prepare_position"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt64Field(value: &commitPosition)
            case 2: try decoder.decodeSingularUInt64Field(value: &preparePosition)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if commitPosition != 0 {
            try visitor.visitSingularUInt64Field(value: commitPosition, fieldNumber: 1)
        }
        if preparePosition != 0 {
            try visitor.visitSingularUInt64Field(value: preparePosition, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_ReadResp.Checkpoint, rhs: EventStore_Client_Streams_ReadResp.Checkpoint) -> Bool {
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_ReadResp.StreamNotFound: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_ReadResp.protoMessageName + ".StreamNotFound"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_streamIdentifier)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _streamIdentifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_ReadResp.StreamNotFound, rhs: EventStore_Client_Streams_ReadResp.StreamNotFound) -> Bool {
        if lhs._streamIdentifier != rhs._streamIdentifier { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_AppendReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".AppendReq"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
        2: .standard(proto: "proposed_message"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_Streams_AppendReq.Options?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .options(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .options(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Streams_AppendReq.ProposedMessage?
                    var hadOneofValue = false
                    if let current = self.content {
                        hadOneofValue = true
                        if case let .proposedMessage(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.content = .proposedMessage(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch content {
        case .options?: try {
                guard case let .options(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .proposedMessage?: try {
                guard case let .proposedMessage(v)? = self.content else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_AppendReq, rhs: EventStore_Client_Streams_AppendReq) -> Bool {
        if lhs.content != rhs.content { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_AppendReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_AppendReq.protoMessageName + ".Options"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        2: .same(proto: "revision"),
        3: .standard(proto: "no_stream"),
        4: .same(proto: "any"),
        5: .standard(proto: "stream_exists"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_streamIdentifier)
            case 2: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.expectedStreamRevision != nil { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .revision(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamRevision {
                        hadOneofValue = true
                        if case let .noStream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .noStream(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamRevision {
                        hadOneofValue = true
                        if case let .any(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .any(v)
                    }
                }()
            case 5: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamRevision {
                        hadOneofValue = true
                        if case let .streamExists(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .streamExists(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _streamIdentifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        switch expectedStreamRevision {
        case .revision?: try {
                guard case let .revision(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
            }()
        case .noStream?: try {
                guard case let .noStream(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .any?: try {
                guard case let .any(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .streamExists?: try {
                guard case let .streamExists(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_AppendReq.Options, rhs: EventStore_Client_Streams_AppendReq.Options) -> Bool {
        if lhs._streamIdentifier != rhs._streamIdentifier { return false }
        if lhs.expectedStreamRevision != rhs.expectedStreamRevision { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_AppendReq.ProposedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_AppendReq.protoMessageName + ".ProposedMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "metadata"),
        3: .standard(proto: "custom_metadata"),
        4: .same(proto: "data"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_id)
            case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: &metadata)
            case 3: try decoder.decodeSingularBytesField(value: &customMetadata)
            case 4: try decoder.decodeSingularBytesField(value: &data)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _id {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !metadata.isEmpty {
            try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: metadata, fieldNumber: 2)
        }
        if !customMetadata.isEmpty {
            try visitor.visitSingularBytesField(value: customMetadata, fieldNumber: 3)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_AppendReq.ProposedMessage, rhs: EventStore_Client_Streams_AppendReq.ProposedMessage) -> Bool {
        if lhs._id != rhs._id { return false }
        if lhs.metadata != rhs.metadata { return false }
        if lhs.customMetadata != rhs.customMetadata { return false }
        if lhs.data != rhs.data { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_AppendResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".AppendResp"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "success"),
        2: .standard(proto: "wrong_expected_version"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_Streams_AppendResp.Success?
                    var hadOneofValue = false
                    if let current = self.result {
                        hadOneofValue = true
                        if case let .success(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.result = .success(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Streams_AppendResp.WrongExpectedVersion?
                    var hadOneofValue = false
                    if let current = self.result {
                        hadOneofValue = true
                        if case let .wrongExpectedVersion(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.result = .wrongExpectedVersion(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch result {
        case .success?: try {
                guard case let .success(v)? = self.result else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .wrongExpectedVersion?: try {
                guard case let .wrongExpectedVersion(v)? = self.result else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_AppendResp, rhs: EventStore_Client_Streams_AppendResp) -> Bool {
        if lhs.result != rhs.result { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_AppendResp.Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_AppendResp.protoMessageName + ".Position"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "commit_position"),
        2: .standard(proto: "prepare_position"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt64Field(value: &commitPosition)
            case 2: try decoder.decodeSingularUInt64Field(value: &preparePosition)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if commitPosition != 0 {
            try visitor.visitSingularUInt64Field(value: commitPosition, fieldNumber: 1)
        }
        if preparePosition != 0 {
            try visitor.visitSingularUInt64Field(value: preparePosition, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_AppendResp.Position, rhs: EventStore_Client_Streams_AppendResp.Position) -> Bool {
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_AppendResp.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_AppendResp.protoMessageName + ".Success"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "current_revision"),
        2: .standard(proto: "no_stream"),
        3: .same(proto: "position"),
        4: .standard(proto: "no_position"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.currentRevisionOption != nil { try decoder.handleConflictingOneOf() }
                        self.currentRevisionOption = .currentRevision(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.currentRevisionOption {
                        hadOneofValue = true
                        if case let .noStream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.currentRevisionOption = .noStream(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Streams_AppendResp.Position?
                    var hadOneofValue = false
                    if let current = self.positionOption {
                        hadOneofValue = true
                        if case let .position(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.positionOption = .position(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.positionOption {
                        hadOneofValue = true
                        if case let .noPosition(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.positionOption = .noPosition(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch currentRevisionOption {
        case .currentRevision?: try {
                guard case let .currentRevision(v)? = self.currentRevisionOption else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
            }()
        case .noStream?: try {
                guard case let .noStream(v)? = self.currentRevisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        switch positionOption {
        case .position?: try {
                guard case let .position(v)? = self.positionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .noPosition?: try {
                guard case let .noPosition(v)? = self.positionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_AppendResp.Success, rhs: EventStore_Client_Streams_AppendResp.Success) -> Bool {
        if lhs.currentRevisionOption != rhs.currentRevisionOption { return false }
        if lhs.positionOption != rhs.positionOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_AppendResp.WrongExpectedVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_AppendResp.protoMessageName + ".WrongExpectedVersion"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "current_revision_20_6_0"),
        2: .standard(proto: "no_stream_20_6_0"),
        3: .standard(proto: "expected_revision_20_6_0"),
        4: .standard(proto: "any_20_6_0"),
        5: .standard(proto: "stream_exists_20_6_0"),
        6: .standard(proto: "current_revision"),
        7: .standard(proto: "current_no_stream"),
        8: .standard(proto: "expected_revision"),
        9: .standard(proto: "expected_any"),
        10: .standard(proto: "expected_stream_exists"),
        11: .standard(proto: "expected_no_stream"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.currentRevisionOption2060 != nil { try decoder.handleConflictingOneOf() }
                        self.currentRevisionOption2060 = .currentRevision2060(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.currentRevisionOption2060 {
                        hadOneofValue = true
                        if case let .noStream2060(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.currentRevisionOption2060 = .noStream2060(v)
                    }
                }()
            case 3: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.expectedRevisionOption2060 != nil { try decoder.handleConflictingOneOf() }
                        self.expectedRevisionOption2060 = .expectedRevision2060(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedRevisionOption2060 {
                        hadOneofValue = true
                        if case let .any2060(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedRevisionOption2060 = .any2060(v)
                    }
                }()
            case 5: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedRevisionOption2060 {
                        hadOneofValue = true
                        if case let .streamExists2060(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedRevisionOption2060 = .streamExists2060(v)
                    }
                }()
            case 6: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.currentRevisionOption != nil { try decoder.handleConflictingOneOf() }
                        self.currentRevisionOption = .currentRevision(v)
                    }
                }()
            case 7: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.currentRevisionOption {
                        hadOneofValue = true
                        if case let .currentNoStream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.currentRevisionOption = .currentNoStream(v)
                    }
                }()
            case 8: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.expectedRevisionOption != nil { try decoder.handleConflictingOneOf() }
                        self.expectedRevisionOption = .expectedRevision(v)
                    }
                }()
            case 9: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedRevisionOption {
                        hadOneofValue = true
                        if case let .expectedAny(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedRevisionOption = .expectedAny(v)
                    }
                }()
            case 10: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedRevisionOption {
                        hadOneofValue = true
                        if case let .expectedStreamExists(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedRevisionOption = .expectedStreamExists(v)
                    }
                }()
            case 11: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedRevisionOption {
                        hadOneofValue = true
                        if case let .expectedNoStream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedRevisionOption = .expectedNoStream(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch currentRevisionOption2060 {
        case .currentRevision2060?: try {
                guard case let .currentRevision2060(v)? = self.currentRevisionOption2060 else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
            }()
        case .noStream2060?: try {
                guard case let .noStream2060(v)? = self.currentRevisionOption2060 else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        switch expectedRevisionOption2060 {
        case .expectedRevision2060?: try {
                guard case let .expectedRevision2060(v)? = self.expectedRevisionOption2060 else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
            }()
        case .any2060?: try {
                guard case let .any2060(v)? = self.expectedRevisionOption2060 else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .streamExists2060?: try {
                guard case let .streamExists2060(v)? = self.expectedRevisionOption2060 else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case nil: break
        }
        switch currentRevisionOption {
        case .currentRevision?: try {
                guard case let .currentRevision(v)? = self.currentRevisionOption else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
            }()
        case .currentNoStream?: try {
                guard case let .currentNoStream(v)? = self.currentRevisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
            }()
        case nil: break
        }
        switch expectedRevisionOption {
        case .expectedRevision?: try {
                guard case let .expectedRevision(v)? = self.expectedRevisionOption else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
            }()
        case .expectedAny?: try {
                guard case let .expectedAny(v)? = self.expectedRevisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
            }()
        case .expectedStreamExists?: try {
                guard case let .expectedStreamExists(v)? = self.expectedRevisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
            }()
        case .expectedNoStream?: try {
                guard case let .expectedNoStream(v)? = self.expectedRevisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_AppendResp.WrongExpectedVersion, rhs: EventStore_Client_Streams_AppendResp.WrongExpectedVersion) -> Bool {
        if lhs.currentRevisionOption2060 != rhs.currentRevisionOption2060 { return false }
        if lhs.expectedRevisionOption2060 != rhs.expectedRevisionOption2060 { return false }
        if lhs.currentRevisionOption != rhs.currentRevisionOption { return false }
        if lhs.expectedRevisionOption != rhs.expectedRevisionOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_BatchAppendReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".BatchAppendReq"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "correlation_id"),
        2: .same(proto: "options"),
        3: .standard(proto: "proposed_messages"),
        4: .standard(proto: "is_final"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_correlationID)
            case 2: try decoder.decodeSingularMessageField(value: &_options)
            case 3: try decoder.decodeRepeatedMessageField(value: &proposedMessages)
            case 4: try decoder.decodeSingularBoolField(value: &isFinal)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _correlationID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try { if let v = self._options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if !proposedMessages.isEmpty {
            try visitor.visitRepeatedMessageField(value: proposedMessages, fieldNumber: 3)
        }
        if isFinal != false {
            try visitor.visitSingularBoolField(value: isFinal, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_BatchAppendReq, rhs: EventStore_Client_Streams_BatchAppendReq) -> Bool {
        if lhs._correlationID != rhs._correlationID { return false }
        if lhs._options != rhs._options { return false }
        if lhs.proposedMessages != rhs.proposedMessages { return false }
        if lhs.isFinal != rhs.isFinal { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_BatchAppendReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_BatchAppendReq.protoMessageName + ".Options"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        2: .standard(proto: "stream_position"),
        3: .standard(proto: "no_stream"),
        4: .same(proto: "any"),
        5: .standard(proto: "stream_exists"),
        6: .standard(proto: "deadline_21_10_0"),
        7: .same(proto: "deadline"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_streamIdentifier)
            case 2: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.expectedStreamPosition != nil { try decoder.handleConflictingOneOf() }
                        self.expectedStreamPosition = .streamPosition(v)
                    }
                }()
            case 3: try {
                    var v: SwiftProtobuf.Google_Protobuf_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamPosition {
                        hadOneofValue = true
                        if case let .noStream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamPosition = .noStream(v)
                    }
                }()
            case 4: try {
                    var v: SwiftProtobuf.Google_Protobuf_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamPosition {
                        hadOneofValue = true
                        if case let .any(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamPosition = .any(v)
                    }
                }()
            case 5: try {
                    var v: SwiftProtobuf.Google_Protobuf_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamPosition {
                        hadOneofValue = true
                        if case let .streamExists(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamPosition = .streamExists(v)
                    }
                }()
            case 6: try {
                    var v: SwiftProtobuf.Google_Protobuf_Timestamp?
                    var hadOneofValue = false
                    if let current = self.deadlineOption {
                        hadOneofValue = true
                        if case let .deadline21100(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.deadlineOption = .deadline21100(v)
                    }
                }()
            case 7: try {
                    var v: SwiftProtobuf.Google_Protobuf_Duration?
                    var hadOneofValue = false
                    if let current = self.deadlineOption {
                        hadOneofValue = true
                        if case let .deadline(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.deadlineOption = .deadline(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _streamIdentifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        switch expectedStreamPosition {
        case .streamPosition?: try {
                guard case let .streamPosition(v)? = self.expectedStreamPosition else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
            }()
        case .noStream?: try {
                guard case let .noStream(v)? = self.expectedStreamPosition else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .any?: try {
                guard case let .any(v)? = self.expectedStreamPosition else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .streamExists?: try {
                guard case let .streamExists(v)? = self.expectedStreamPosition else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case nil: break
        }
        switch deadlineOption {
        case .deadline21100?: try {
                guard case let .deadline21100(v)? = self.deadlineOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
            }()
        case .deadline?: try {
                guard case let .deadline(v)? = self.deadlineOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_BatchAppendReq.Options, rhs: EventStore_Client_Streams_BatchAppendReq.Options) -> Bool {
        if lhs._streamIdentifier != rhs._streamIdentifier { return false }
        if lhs.expectedStreamPosition != rhs.expectedStreamPosition { return false }
        if lhs.deadlineOption != rhs.deadlineOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_BatchAppendReq.ProposedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_BatchAppendReq.protoMessageName + ".ProposedMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "metadata"),
        3: .standard(proto: "custom_metadata"),
        4: .same(proto: "data"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_id)
            case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: &metadata)
            case 3: try decoder.decodeSingularBytesField(value: &customMetadata)
            case 4: try decoder.decodeSingularBytesField(value: &data)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _id {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !metadata.isEmpty {
            try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: metadata, fieldNumber: 2)
        }
        if !customMetadata.isEmpty {
            try visitor.visitSingularBytesField(value: customMetadata, fieldNumber: 3)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_BatchAppendReq.ProposedMessage, rhs: EventStore_Client_Streams_BatchAppendReq.ProposedMessage) -> Bool {
        if lhs._id != rhs._id { return false }
        if lhs.metadata != rhs.metadata { return false }
        if lhs.customMetadata != rhs.customMetadata { return false }
        if lhs.data != rhs.data { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_BatchAppendResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".BatchAppendResp"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "correlation_id"),
        2: .same(proto: "error"),
        3: .same(proto: "success"),
        4: .standard(proto: "stream_identifier"),
        5: .standard(proto: "stream_position"),
        6: .standard(proto: "no_stream"),
        7: .same(proto: "any"),
        8: .standard(proto: "stream_exists"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_correlationID)
            case 2: try {
                    var v: Google_Rpc_Status?
                    var hadOneofValue = false
                    if let current = self.result {
                        hadOneofValue = true
                        if case let .error(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.result = .error(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Streams_BatchAppendResp.Success?
                    var hadOneofValue = false
                    if let current = self.result {
                        hadOneofValue = true
                        if case let .success(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.result = .success(v)
                    }
                }()
            case 4: try decoder.decodeSingularMessageField(value: &_streamIdentifier)
            case 5: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.expectedStreamPosition != nil { try decoder.handleConflictingOneOf() }
                        self.expectedStreamPosition = .streamPosition(v)
                    }
                }()
            case 6: try {
                    var v: SwiftProtobuf.Google_Protobuf_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamPosition {
                        hadOneofValue = true
                        if case let .noStream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamPosition = .noStream(v)
                    }
                }()
            case 7: try {
                    var v: SwiftProtobuf.Google_Protobuf_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamPosition {
                        hadOneofValue = true
                        if case let .any(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamPosition = .any(v)
                    }
                }()
            case 8: try {
                    var v: SwiftProtobuf.Google_Protobuf_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamPosition {
                        hadOneofValue = true
                        if case let .streamExists(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamPosition = .streamExists(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _correlationID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        switch result {
        case .error?: try {
                guard case let .error(v)? = self.result else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .success?: try {
                guard case let .success(v)? = self.result else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        try { if let v = self._streamIdentifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        switch expectedStreamPosition {
        case .streamPosition?: try {
                guard case let .streamPosition(v)? = self.expectedStreamPosition else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
            }()
        case .noStream?: try {
                guard case let .noStream(v)? = self.expectedStreamPosition else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
            }()
        case .any?: try {
                guard case let .any(v)? = self.expectedStreamPosition else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
            }()
        case .streamExists?: try {
                guard case let .streamExists(v)? = self.expectedStreamPosition else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_BatchAppendResp, rhs: EventStore_Client_Streams_BatchAppendResp) -> Bool {
        if lhs._correlationID != rhs._correlationID { return false }
        if lhs.result != rhs.result { return false }
        if lhs._streamIdentifier != rhs._streamIdentifier { return false }
        if lhs.expectedStreamPosition != rhs.expectedStreamPosition { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_BatchAppendResp.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_BatchAppendResp.protoMessageName + ".Success"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "current_revision"),
        2: .standard(proto: "no_stream"),
        3: .same(proto: "position"),
        4: .standard(proto: "no_position"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.currentRevisionOption != nil { try decoder.handleConflictingOneOf() }
                        self.currentRevisionOption = .currentRevision(v)
                    }
                }()
            case 2: try {
                    var v: SwiftProtobuf.Google_Protobuf_Empty?
                    var hadOneofValue = false
                    if let current = self.currentRevisionOption {
                        hadOneofValue = true
                        if case let .noStream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.currentRevisionOption = .noStream(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_AllStreamPosition?
                    var hadOneofValue = false
                    if let current = self.positionOption {
                        hadOneofValue = true
                        if case let .position(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.positionOption = .position(v)
                    }
                }()
            case 4: try {
                    var v: SwiftProtobuf.Google_Protobuf_Empty?
                    var hadOneofValue = false
                    if let current = self.positionOption {
                        hadOneofValue = true
                        if case let .noPosition(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.positionOption = .noPosition(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch currentRevisionOption {
        case .currentRevision?: try {
                guard case let .currentRevision(v)? = self.currentRevisionOption else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
            }()
        case .noStream?: try {
                guard case let .noStream(v)? = self.currentRevisionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        switch positionOption {
        case .position?: try {
                guard case let .position(v)? = self.positionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .noPosition?: try {
                guard case let .noPosition(v)? = self.positionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_BatchAppendResp.Success, rhs: EventStore_Client_Streams_BatchAppendResp.Success) -> Bool {
        if lhs.currentRevisionOption != rhs.currentRevisionOption { return false }
        if lhs.positionOption != rhs.positionOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_DeleteReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DeleteReq"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_DeleteReq, rhs: EventStore_Client_Streams_DeleteReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_DeleteReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_DeleteReq.protoMessageName + ".Options"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        2: .same(proto: "revision"),
        3: .standard(proto: "no_stream"),
        4: .same(proto: "any"),
        5: .standard(proto: "stream_exists"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_streamIdentifier)
            case 2: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.expectedStreamRevision != nil { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .revision(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamRevision {
                        hadOneofValue = true
                        if case let .noStream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .noStream(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamRevision {
                        hadOneofValue = true
                        if case let .any(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .any(v)
                    }
                }()
            case 5: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamRevision {
                        hadOneofValue = true
                        if case let .streamExists(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .streamExists(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _streamIdentifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        switch expectedStreamRevision {
        case .revision?: try {
                guard case let .revision(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
            }()
        case .noStream?: try {
                guard case let .noStream(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .any?: try {
                guard case let .any(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .streamExists?: try {
                guard case let .streamExists(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_DeleteReq.Options, rhs: EventStore_Client_Streams_DeleteReq.Options) -> Bool {
        if lhs._streamIdentifier != rhs._streamIdentifier { return false }
        if lhs.expectedStreamRevision != rhs.expectedStreamRevision { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_DeleteResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DeleteResp"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "position"),
        2: .standard(proto: "no_position"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_Streams_DeleteResp.Position?
                    var hadOneofValue = false
                    if let current = self.positionOption {
                        hadOneofValue = true
                        if case let .position(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.positionOption = .position(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.positionOption {
                        hadOneofValue = true
                        if case let .noPosition(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.positionOption = .noPosition(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch positionOption {
        case .position?: try {
                guard case let .position(v)? = self.positionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .noPosition?: try {
                guard case let .noPosition(v)? = self.positionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_DeleteResp, rhs: EventStore_Client_Streams_DeleteResp) -> Bool {
        if lhs.positionOption != rhs.positionOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_DeleteResp.Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_DeleteResp.protoMessageName + ".Position"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "commit_position"),
        2: .standard(proto: "prepare_position"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt64Field(value: &commitPosition)
            case 2: try decoder.decodeSingularUInt64Field(value: &preparePosition)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if commitPosition != 0 {
            try visitor.visitSingularUInt64Field(value: commitPosition, fieldNumber: 1)
        }
        if preparePosition != 0 {
            try visitor.visitSingularUInt64Field(value: preparePosition, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_DeleteResp.Position, rhs: EventStore_Client_Streams_DeleteResp.Position) -> Bool {
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_TombstoneReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".TombstoneReq"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_TombstoneReq, rhs: EventStore_Client_Streams_TombstoneReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_TombstoneReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_TombstoneReq.protoMessageName + ".Options"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_identifier"),
        2: .same(proto: "revision"),
        3: .standard(proto: "no_stream"),
        4: .same(proto: "any"),
        5: .standard(proto: "stream_exists"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_streamIdentifier)
            case 2: try {
                    var v: UInt64?
                    try decoder.decodeSingularUInt64Field(value: &v)
                    if let v {
                        if self.expectedStreamRevision != nil { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .revision(v)
                    }
                }()
            case 3: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamRevision {
                        hadOneofValue = true
                        if case let .noStream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .noStream(v)
                    }
                }()
            case 4: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamRevision {
                        hadOneofValue = true
                        if case let .any(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .any(v)
                    }
                }()
            case 5: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.expectedStreamRevision {
                        hadOneofValue = true
                        if case let .streamExists(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.expectedStreamRevision = .streamExists(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _streamIdentifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        switch expectedStreamRevision {
        case .revision?: try {
                guard case let .revision(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
            }()
        case .noStream?: try {
                guard case let .noStream(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .any?: try {
                guard case let .any(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .streamExists?: try {
                guard case let .streamExists(v)? = self.expectedStreamRevision else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_TombstoneReq.Options, rhs: EventStore_Client_Streams_TombstoneReq.Options) -> Bool {
        if lhs._streamIdentifier != rhs._streamIdentifier { return false }
        if lhs.expectedStreamRevision != rhs.expectedStreamRevision { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_TombstoneResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".TombstoneResp"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "position"),
        2: .standard(proto: "no_position"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: EventStore_Client_Streams_TombstoneResp.Position?
                    var hadOneofValue = false
                    if let current = self.positionOption {
                        hadOneofValue = true
                        if case let .position(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.positionOption = .position(v)
                    }
                }()
            case 2: try {
                    var v: EventStore_Client_Empty?
                    var hadOneofValue = false
                    if let current = self.positionOption {
                        hadOneofValue = true
                        if case let .noPosition(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.positionOption = .noPosition(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch positionOption {
        case .position?: try {
                guard case let .position(v)? = self.positionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .noPosition?: try {
                guard case let .noPosition(v)? = self.positionOption else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_TombstoneResp, rhs: EventStore_Client_Streams_TombstoneResp) -> Bool {
        if lhs.positionOption != rhs.positionOption { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Streams_TombstoneResp.Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Streams_TombstoneResp.protoMessageName + ".Position"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "commit_position"),
        2: .standard(proto: "prepare_position"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt64Field(value: &commitPosition)
            case 2: try decoder.decodeSingularUInt64Field(value: &preparePosition)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if commitPosition != 0 {
            try visitor.visitSingularUInt64Field(value: commitPosition, fieldNumber: 1)
        }
        if preparePosition != 0 {
            try visitor.visitSingularUInt64Field(value: preparePosition, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Streams_TombstoneResp.Position, rhs: EventStore_Client_Streams_TombstoneResp.Position) -> Bool {
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
