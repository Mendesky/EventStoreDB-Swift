// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protos/ClientMessageDtos.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

public enum EventStoreDB_Client_Messages_OperationResult: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case success // = 0
    case prepareTimeout // = 1
    case commitTimeout // = 2
    case forwardTimeout // = 3
    case wrongExpectedVersion // = 4
    case streamDeleted // = 5
    case invalidTransaction // = 6
    case accessDenied // = 7
    case UNRECOGNIZED(Int)

    public init() {
        self = .success
    }

    public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .success
        case 1: self = .prepareTimeout
        case 2: self = .commitTimeout
        case 3: self = .forwardTimeout
        case 4: self = .wrongExpectedVersion
        case 5: self = .streamDeleted
        case 6: self = .invalidTransaction
        case 7: self = .accessDenied
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    public var rawValue: Int {
        switch self {
        case .success: 0
        case .prepareTimeout: 1
        case .commitTimeout: 2
        case .forwardTimeout: 3
        case .wrongExpectedVersion: 4
        case .streamDeleted: 5
        case .invalidTransaction: 6
        case .accessDenied: 7
        case let .UNRECOGNIZED(i): i
        }
    }
}

#if swift(>=4.2)

    extension EventStoreDB_Client_Messages_OperationResult: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [EventStoreDB_Client_Messages_OperationResult] = [
            .success,
            .prepareTimeout,
            .commitTimeout,
            .forwardTimeout,
            .wrongExpectedVersion,
            .streamDeleted,
            .invalidTransaction,
            .accessDenied,
        ]
    }

#endif // swift(>=4.2)

public struct EventStoreDB_Client_Messages_NewEvent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var eventID: Data = .init()

    public var eventType: String = .init()

    public var dataContentType: Int32 = 0

    public var metadataContentType: Int32 = 0

    public var data: Data = .init()

    public var metadata: Data = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_EventRecord {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var eventStreamID: String = .init()

    public var eventNumber: Int64 = 0

    public var eventID: Data = .init()

    public var eventType: String = .init()

    public var dataContentType: Int32 = 0

    public var metadataContentType: Int32 = 0

    public var data: Data = .init()

    public var metadata: Data = .init()

    public var created: Int64 = 0

    public var createdEpoch: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_ResolvedIndexedEvent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var event: EventStoreDB_Client_Messages_EventRecord {
        get { _storage._event ?? EventStoreDB_Client_Messages_EventRecord() }
        set { _uniqueStorage()._event = newValue }
    }

    /// Returns true if `event` has been explicitly set.
    public var hasEvent: Bool { _storage._event != nil }
    /// Clears the value of `event`. Subsequent reads from it will return its default value.
    public mutating func clearEvent() { _uniqueStorage()._event = nil }

    public var link: EventStoreDB_Client_Messages_EventRecord {
        get { _storage._link ?? EventStoreDB_Client_Messages_EventRecord() }
        set { _uniqueStorage()._link = newValue }
    }

    /// Returns true if `link` has been explicitly set.
    public var hasLink: Bool { _storage._link != nil }
    /// Clears the value of `link`. Subsequent reads from it will return its default value.
    public mutating func clearLink() { _uniqueStorage()._link = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

public struct EventStoreDB_Client_Messages_ResolvedEvent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var event: EventStoreDB_Client_Messages_EventRecord {
        get { _storage._event ?? EventStoreDB_Client_Messages_EventRecord() }
        set { _uniqueStorage()._event = newValue }
    }

    /// Returns true if `event` has been explicitly set.
    public var hasEvent: Bool { _storage._event != nil }
    /// Clears the value of `event`. Subsequent reads from it will return its default value.
    public mutating func clearEvent() { _uniqueStorage()._event = nil }

    public var link: EventStoreDB_Client_Messages_EventRecord {
        get { _storage._link ?? EventStoreDB_Client_Messages_EventRecord() }
        set { _uniqueStorage()._link = newValue }
    }

    /// Returns true if `link` has been explicitly set.
    public var hasLink: Bool { _storage._link != nil }
    /// Clears the value of `link`. Subsequent reads from it will return its default value.
    public mutating func clearLink() { _uniqueStorage()._link = nil }

    public var commitPosition: Int64 {
        get { _storage._commitPosition }
        set { _uniqueStorage()._commitPosition = newValue }
    }

    public var preparePosition: Int64 {
        get { _storage._preparePosition }
        set { _uniqueStorage()._preparePosition = newValue }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

public struct EventStoreDB_Client_Messages_WriteEvents {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var eventStreamID: String = .init()

    public var expectedVersion: Int64 = 0

    public var events: [EventStoreDB_Client_Messages_NewEvent] = []

    public var requireLeader: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_WriteEventsCompleted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var result: EventStoreDB_Client_Messages_OperationResult = .success

    public var message: String = .init()

    public var firstEventNumber: Int64 = 0

    public var lastEventNumber: Int64 = 0

    public var preparePosition: Int64 = 0

    public var commitPosition: Int64 = 0

    public var currentVersion: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_DeleteStream {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var eventStreamID: String = .init()

    public var expectedVersion: Int64 = 0

    public var requireLeader: Bool = false

    public var hardDelete: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_DeleteStreamCompleted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var result: EventStoreDB_Client_Messages_OperationResult = .success

    public var message: String = .init()

    public var preparePosition: Int64 = 0

    public var commitPosition: Int64 = 0

    public var currentVersion: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_TransactionStart {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var eventStreamID: String = .init()

    public var expectedVersion: Int64 = 0

    public var requireLeader: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_TransactionStartCompleted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var transactionID: Int64 = 0

    public var result: EventStoreDB_Client_Messages_OperationResult = .success

    public var message: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_TransactionWrite {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var transactionID: Int64 = 0

    public var events: [EventStoreDB_Client_Messages_NewEvent] = []

    public var requireLeader: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_TransactionWriteCompleted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var transactionID: Int64 = 0

    public var result: EventStoreDB_Client_Messages_OperationResult = .success

    public var message: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_TransactionCommit {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var transactionID: Int64 = 0

    public var requireLeader: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_TransactionCommitCompleted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var transactionID: Int64 = 0

    public var result: EventStoreDB_Client_Messages_OperationResult = .success

    public var message: String = .init()

    public var firstEventNumber: Int64 = 0

    public var lastEventNumber: Int64 = 0

    public var preparePosition: Int64 = 0

    public var commitPosition: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_ReadEvent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var eventStreamID: String = .init()

    public var eventNumber: Int64 = 0

    public var resolveLinkTos: Bool = false

    public var requireLeader: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_ReadEventCompleted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var result: EventStoreDB_Client_Messages_ReadEventCompleted.ReadEventResult = .success

    public var event: EventStoreDB_Client_Messages_ResolvedIndexedEvent {
        get { _event ?? EventStoreDB_Client_Messages_ResolvedIndexedEvent() }
        set { _event = newValue }
    }

    /// Returns true if `event` has been explicitly set.
    public var hasEvent: Bool { _event != nil }
    /// Clears the value of `event`. Subsequent reads from it will return its default value.
    public mutating func clearEvent() { _event = nil }

    public var error: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum ReadEventResult: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case success // = 0
        case notFound // = 1
        case noStream // = 2
        case streamDeleted // = 3
        case error // = 4
        case accessDenied // = 5
        case UNRECOGNIZED(Int)

        public init() {
            self = .success
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .success
            case 1: self = .notFound
            case 2: self = .noStream
            case 3: self = .streamDeleted
            case 4: self = .error
            case 5: self = .accessDenied
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .success: 0
            case .notFound: 1
            case .noStream: 2
            case .streamDeleted: 3
            case .error: 4
            case .accessDenied: 5
            case let .UNRECOGNIZED(i): i
            }
        }
    }

    public init() {}

    fileprivate var _event: EventStoreDB_Client_Messages_ResolvedIndexedEvent?
}

#if swift(>=4.2)

    extension EventStoreDB_Client_Messages_ReadEventCompleted.ReadEventResult: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [EventStoreDB_Client_Messages_ReadEventCompleted.ReadEventResult] = [
            .success,
            .notFound,
            .noStream,
            .streamDeleted,
            .error,
            .accessDenied,
        ]
    }

#endif // swift(>=4.2)

public struct EventStoreDB_Client_Messages_ReadStreamEvents {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var eventStreamID: String = .init()

    public var fromEventNumber: Int64 = 0

    public var maxCount: Int32 = 0

    public var resolveLinkTos: Bool = false

    public var requireLeader: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_ReadStreamEventsCompleted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var events: [EventStoreDB_Client_Messages_ResolvedIndexedEvent] = []

    public var result: EventStoreDB_Client_Messages_ReadStreamEventsCompleted.ReadStreamResult = .success

    public var nextEventNumber: Int64 = 0

    public var lastEventNumber: Int64 = 0

    public var isEndOfStream: Bool = false

    public var lastCommitPosition: Int64 = 0

    public var error: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum ReadStreamResult: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case success // = 0
        case noStream // = 1
        case streamDeleted // = 2
        case notModified // = 3
        case error // = 4
        case accessDenied // = 5
        case UNRECOGNIZED(Int)

        public init() {
            self = .success
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .success
            case 1: self = .noStream
            case 2: self = .streamDeleted
            case 3: self = .notModified
            case 4: self = .error
            case 5: self = .accessDenied
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .success: 0
            case .noStream: 1
            case .streamDeleted: 2
            case .notModified: 3
            case .error: 4
            case .accessDenied: 5
            case let .UNRECOGNIZED(i): i
            }
        }
    }

    public init() {}
}

#if swift(>=4.2)

    extension EventStoreDB_Client_Messages_ReadStreamEventsCompleted.ReadStreamResult: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [EventStoreDB_Client_Messages_ReadStreamEventsCompleted.ReadStreamResult] = [
            .success,
            .noStream,
            .streamDeleted,
            .notModified,
            .error,
            .accessDenied,
        ]
    }

#endif // swift(>=4.2)

public struct EventStoreDB_Client_Messages_ReadAllEvents {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var commitPosition: Int64 = 0

    public var preparePosition: Int64 = 0

    public var maxCount: Int32 = 0

    public var resolveLinkTos: Bool = false

    public var requireLeader: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_ReadAllEventsCompleted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var commitPosition: Int64 = 0

    public var preparePosition: Int64 = 0

    public var events: [EventStoreDB_Client_Messages_ResolvedEvent] = []

    public var nextCommitPosition: Int64 = 0

    public var nextPreparePosition: Int64 = 0

    public var result: EventStoreDB_Client_Messages_ReadAllEventsCompleted.ReadAllResult = .success

    public var error: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum ReadAllResult: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case success // = 0
        case notModified // = 1
        case error // = 2
        case accessDenied // = 3
        case UNRECOGNIZED(Int)

        public init() {
            self = .success
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .success
            case 1: self = .notModified
            case 2: self = .error
            case 3: self = .accessDenied
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .success: 0
            case .notModified: 1
            case .error: 2
            case .accessDenied: 3
            case let .UNRECOGNIZED(i): i
            }
        }
    }

    public init() {}
}

#if swift(>=4.2)

    extension EventStoreDB_Client_Messages_ReadAllEventsCompleted.ReadAllResult: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [EventStoreDB_Client_Messages_ReadAllEventsCompleted.ReadAllResult] = [
            .success,
            .notModified,
            .error,
            .accessDenied,
        ]
    }

#endif // swift(>=4.2)

public struct EventStoreDB_Client_Messages_Filter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var context: EventStoreDB_Client_Messages_Filter.FilterContext = .streamID

    public var type: EventStoreDB_Client_Messages_Filter.FilterType = .regex

    public var data: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum FilterContext: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case streamID // = 0
        case eventType // = 1
        case UNRECOGNIZED(Int)

        public init() {
            self = .streamID
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .streamID
            case 1: self = .eventType
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .streamID: 0
            case .eventType: 1
            case let .UNRECOGNIZED(i): i
            }
        }
    }

    public enum FilterType: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case regex // = 0
        case prefix // = 1
        case UNRECOGNIZED(Int)

        public init() {
            self = .regex
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .regex
            case 1: self = .prefix
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .regex: 0
            case .prefix: 1
            case let .UNRECOGNIZED(i): i
            }
        }
    }

    public init() {}
}

#if swift(>=4.2)

    extension EventStoreDB_Client_Messages_Filter.FilterContext: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [EventStoreDB_Client_Messages_Filter.FilterContext] = [
            .streamID,
            .eventType,
        ]
    }

    extension EventStoreDB_Client_Messages_Filter.FilterType: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [EventStoreDB_Client_Messages_Filter.FilterType] = [
            .regex,
            .prefix,
        ]
    }

#endif // swift(>=4.2)

public struct EventStoreDB_Client_Messages_FilteredReadAllEvents {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var commitPosition: Int64 = 0

    public var preparePosition: Int64 = 0

    public var maxCount: Int32 = 0

    public var maxSearchWindow: Int32 = 0

    public var resolveLinkTos: Bool = false

    public var requireLeader: Bool = false

    public var filter: EventStoreDB_Client_Messages_Filter {
        get { _filter ?? EventStoreDB_Client_Messages_Filter() }
        set { _filter = newValue }
    }

    /// Returns true if `filter` has been explicitly set.
    public var hasFilter: Bool { _filter != nil }
    /// Clears the value of `filter`. Subsequent reads from it will return its default value.
    public mutating func clearFilter() { _filter = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _filter: EventStoreDB_Client_Messages_Filter?
}

public struct EventStoreDB_Client_Messages_FilteredReadAllEventsCompleted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var commitPosition: Int64 = 0

    public var preparePosition: Int64 = 0

    public var events: [EventStoreDB_Client_Messages_ResolvedEvent] = []

    public var nextCommitPosition: Int64 = 0

    public var nextPreparePosition: Int64 = 0

    public var isEndOfStream: Bool = false

    public var result: EventStoreDB_Client_Messages_FilteredReadAllEventsCompleted.FilteredReadAllResult = .success

    public var error: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum FilteredReadAllResult: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case success // = 0
        case notModified // = 1
        case error // = 2
        case accessDenied // = 3
        case UNRECOGNIZED(Int)

        public init() {
            self = .success
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .success
            case 1: self = .notModified
            case 2: self = .error
            case 3: self = .accessDenied
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .success: 0
            case .notModified: 1
            case .error: 2
            case .accessDenied: 3
            case let .UNRECOGNIZED(i): i
            }
        }
    }

    public init() {}
}

#if swift(>=4.2)

    extension EventStoreDB_Client_Messages_FilteredReadAllEventsCompleted.FilteredReadAllResult: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [EventStoreDB_Client_Messages_FilteredReadAllEventsCompleted.FilteredReadAllResult] = [
            .success,
            .notModified,
            .error,
            .accessDenied,
        ]
    }

#endif // swift(>=4.2)

public struct EventStoreDB_Client_Messages_CreatePersistentSubscription {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var subscriptionGroupName: String = .init()

    public var eventStreamID: String = .init()

    public var resolveLinkTos: Bool = false

    public var startFrom: Int64 = 0

    public var messageTimeoutMilliseconds: Int32 = 0

    public var recordStatistics: Bool = false

    public var liveBufferSize: Int32 = 0

    public var readBatchSize: Int32 = 0

    public var bufferSize: Int32 = 0

    public var maxRetryCount: Int32 = 0

    public var preferRoundRobin: Bool = false

    public var checkpointAfterTime: Int32 = 0

    public var checkpointMaxCount: Int32 = 0

    public var checkpointMinCount: Int32 = 0

    public var subscriberMaxCount: Int32 = 0

    public var namedConsumerStrategy: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_DeletePersistentSubscription {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var subscriptionGroupName: String = .init()

    public var eventStreamID: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_UpdatePersistentSubscription {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var subscriptionGroupName: String = .init()

    public var eventStreamID: String = .init()

    public var resolveLinkTos: Bool = false

    public var startFrom: Int64 = 0

    public var messageTimeoutMilliseconds: Int32 = 0

    public var recordStatistics: Bool = false

    public var liveBufferSize: Int32 = 0

    public var readBatchSize: Int32 = 0

    public var bufferSize: Int32 = 0

    public var maxRetryCount: Int32 = 0

    public var preferRoundRobin: Bool = false

    public var checkpointAfterTime: Int32 = 0

    public var checkpointMaxCount: Int32 = 0

    public var checkpointMinCount: Int32 = 0

    public var subscriberMaxCount: Int32 = 0

    public var namedConsumerStrategy: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_UpdatePersistentSubscriptionCompleted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var result: EventStoreDB_Client_Messages_UpdatePersistentSubscriptionCompleted.UpdatePersistentSubscriptionResult = .success

    public var reason: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum UpdatePersistentSubscriptionResult: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case success // = 0
        case doesNotExist // = 1
        case fail // = 2
        case accessDenied // = 3
        case UNRECOGNIZED(Int)

        public init() {
            self = .success
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .success
            case 1: self = .doesNotExist
            case 2: self = .fail
            case 3: self = .accessDenied
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .success: 0
            case .doesNotExist: 1
            case .fail: 2
            case .accessDenied: 3
            case let .UNRECOGNIZED(i): i
            }
        }
    }

    public init() {}
}

#if swift(>=4.2)

    extension EventStoreDB_Client_Messages_UpdatePersistentSubscriptionCompleted.UpdatePersistentSubscriptionResult: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [EventStoreDB_Client_Messages_UpdatePersistentSubscriptionCompleted.UpdatePersistentSubscriptionResult] = [
            .success,
            .doesNotExist,
            .fail,
            .accessDenied,
        ]
    }

#endif // swift(>=4.2)

public struct EventStoreDB_Client_Messages_CreatePersistentSubscriptionCompleted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var result: EventStoreDB_Client_Messages_CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult = .success

    public var reason: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum CreatePersistentSubscriptionResult: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case success // = 0
        case alreadyExists // = 1
        case fail // = 2
        case accessDenied // = 3
        case UNRECOGNIZED(Int)

        public init() {
            self = .success
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .success
            case 1: self = .alreadyExists
            case 2: self = .fail
            case 3: self = .accessDenied
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .success: 0
            case .alreadyExists: 1
            case .fail: 2
            case .accessDenied: 3
            case let .UNRECOGNIZED(i): i
            }
        }
    }

    public init() {}
}

#if swift(>=4.2)

    extension EventStoreDB_Client_Messages_CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [EventStoreDB_Client_Messages_CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult] = [
            .success,
            .alreadyExists,
            .fail,
            .accessDenied,
        ]
    }

#endif // swift(>=4.2)

public struct EventStoreDB_Client_Messages_DeletePersistentSubscriptionCompleted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var result: EventStoreDB_Client_Messages_DeletePersistentSubscriptionCompleted.DeletePersistentSubscriptionResult = .success

    public var reason: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum DeletePersistentSubscriptionResult: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case success // = 0
        case doesNotExist // = 1
        case fail // = 2
        case accessDenied // = 3
        case UNRECOGNIZED(Int)

        public init() {
            self = .success
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .success
            case 1: self = .doesNotExist
            case 2: self = .fail
            case 3: self = .accessDenied
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .success: 0
            case .doesNotExist: 1
            case .fail: 2
            case .accessDenied: 3
            case let .UNRECOGNIZED(i): i
            }
        }
    }

    public init() {}
}

#if swift(>=4.2)

    extension EventStoreDB_Client_Messages_DeletePersistentSubscriptionCompleted.DeletePersistentSubscriptionResult: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [EventStoreDB_Client_Messages_DeletePersistentSubscriptionCompleted.DeletePersistentSubscriptionResult] = [
            .success,
            .doesNotExist,
            .fail,
            .accessDenied,
        ]
    }

#endif // swift(>=4.2)

public struct EventStoreDB_Client_Messages_ConnectToPersistentSubscription {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var subscriptionID: String = .init()

    public var eventStreamID: String = .init()

    public var allowedInFlightMessages: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_PersistentSubscriptionAckEvents {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var subscriptionID: String = .init()

    public var processedEventIds: [Data] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_PersistentSubscriptionNakEvents {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var subscriptionID: String = .init()

    public var processedEventIds: [Data] = []

    public var message: String = .init()

    public var action: EventStoreDB_Client_Messages_PersistentSubscriptionNakEvents.NakAction = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum NakAction: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case unknown // = 0
        case park // = 1
        case retry // = 2
        case skip // = 3
        case stop // = 4
        case UNRECOGNIZED(Int)

        public init() {
            self = .unknown
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .park
            case 2: self = .retry
            case 3: self = .skip
            case 4: self = .stop
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .unknown: 0
            case .park: 1
            case .retry: 2
            case .skip: 3
            case .stop: 4
            case let .UNRECOGNIZED(i): i
            }
        }
    }

    public init() {}
}

#if swift(>=4.2)

    extension EventStoreDB_Client_Messages_PersistentSubscriptionNakEvents.NakAction: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [EventStoreDB_Client_Messages_PersistentSubscriptionNakEvents.NakAction] = [
            .unknown,
            .park,
            .retry,
            .skip,
            .stop,
        ]
    }

#endif // swift(>=4.2)

public struct EventStoreDB_Client_Messages_PersistentSubscriptionConfirmation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var lastCommitPosition: Int64 = 0

    public var subscriptionID: String = .init()

    public var lastEventNumber: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_PersistentSubscriptionStreamEventAppeared {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var event: EventStoreDB_Client_Messages_ResolvedIndexedEvent {
        get { _event ?? EventStoreDB_Client_Messages_ResolvedIndexedEvent() }
        set { _event = newValue }
    }

    /// Returns true if `event` has been explicitly set.
    public var hasEvent: Bool { _event != nil }
    /// Clears the value of `event`. Subsequent reads from it will return its default value.
    public mutating func clearEvent() { _event = nil }

    public var retryCount: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _event: EventStoreDB_Client_Messages_ResolvedIndexedEvent?
}

public struct EventStoreDB_Client_Messages_SubscribeToStream {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var eventStreamID: String = .init()

    public var resolveLinkTos: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_FilteredSubscribeToStream {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var eventStreamID: String = .init()

    public var resolveLinkTos: Bool = false

    public var filter: EventStoreDB_Client_Messages_Filter {
        get { _filter ?? EventStoreDB_Client_Messages_Filter() }
        set { _filter = newValue }
    }

    /// Returns true if `filter` has been explicitly set.
    public var hasFilter: Bool { _filter != nil }
    /// Clears the value of `filter`. Subsequent reads from it will return its default value.
    public mutating func clearFilter() { _filter = nil }

    public var checkpointInterval: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _filter: EventStoreDB_Client_Messages_Filter?
}

public struct EventStoreDB_Client_Messages_CheckpointReached {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var commitPosition: Int64 = 0

    public var preparePosition: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_SubscriptionConfirmation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var lastCommitPosition: Int64 = 0

    public var lastEventNumber: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_StreamEventAppeared {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var event: EventStoreDB_Client_Messages_ResolvedEvent {
        get { _event ?? EventStoreDB_Client_Messages_ResolvedEvent() }
        set { _event = newValue }
    }

    /// Returns true if `event` has been explicitly set.
    public var hasEvent: Bool { _event != nil }
    /// Clears the value of `event`. Subsequent reads from it will return its default value.
    public mutating func clearEvent() { _event = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _event: EventStoreDB_Client_Messages_ResolvedEvent?
}

public struct EventStoreDB_Client_Messages_UnsubscribeFromStream {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_SubscriptionDropped {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var reason: EventStoreDB_Client_Messages_SubscriptionDropped.SubscriptionDropReason = .unsubscribed

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum SubscriptionDropReason: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case unsubscribed // = 0
        case accessDenied // = 1
        case notFound // = 2
        case persistentSubscriptionDeleted // = 3
        case subscriberMaxCountReached // = 4
        case UNRECOGNIZED(Int)

        public init() {
            self = .unsubscribed
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unsubscribed
            case 1: self = .accessDenied
            case 2: self = .notFound
            case 3: self = .persistentSubscriptionDeleted
            case 4: self = .subscriberMaxCountReached
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .unsubscribed: 0
            case .accessDenied: 1
            case .notFound: 2
            case .persistentSubscriptionDeleted: 3
            case .subscriberMaxCountReached: 4
            case let .UNRECOGNIZED(i): i
            }
        }
    }

    public init() {}
}

#if swift(>=4.2)

    extension EventStoreDB_Client_Messages_SubscriptionDropped.SubscriptionDropReason: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [EventStoreDB_Client_Messages_SubscriptionDropped.SubscriptionDropReason] = [
            .unsubscribed,
            .accessDenied,
            .notFound,
            .persistentSubscriptionDeleted,
            .subscriberMaxCountReached,
        ]
    }

#endif // swift(>=4.2)

public struct EventStoreDB_Client_Messages_NotHandled {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var reason: EventStoreDB_Client_Messages_NotHandled.NotHandledReason = .notReady

    public var additionalInfo: Data = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum NotHandledReason: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case notReady // = 0
        case tooBusy // = 1
        case notLeader // = 2
        case isReadOnly // = 3
        case UNRECOGNIZED(Int)

        public init() {
            self = .notReady
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .notReady
            case 1: self = .tooBusy
            case 2: self = .notLeader
            case 3: self = .isReadOnly
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .notReady: 0
            case .tooBusy: 1
            case .notLeader: 2
            case .isReadOnly: 3
            case let .UNRECOGNIZED(i): i
            }
        }
    }

    public struct LeaderInfo {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var externalTcpAddress: String = .init()

        public var externalTcpPort: Int32 = 0

        public var httpAddress: String = .init()

        public var httpPort: Int32 = 0

        public var externalSecureTcpAddress: String = .init()

        public var externalSecureTcpPort: Int32 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public init() {}
}

#if swift(>=4.2)

    extension EventStoreDB_Client_Messages_NotHandled.NotHandledReason: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [EventStoreDB_Client_Messages_NotHandled.NotHandledReason] = [
            .notReady,
            .tooBusy,
            .notLeader,
            .isReadOnly,
        ]
    }

#endif // swift(>=4.2)

public struct EventStoreDB_Client_Messages_ScavengeDatabase {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_ScavengeDatabaseResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var result: EventStoreDB_Client_Messages_ScavengeDatabaseResponse.ScavengeResult = .started

    public var scavengeID: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum ScavengeResult: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case started // = 0
        case inProgress // = 1
        case unauthorized // = 2
        case UNRECOGNIZED(Int)

        public init() {
            self = .started
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .started
            case 1: self = .inProgress
            case 2: self = .unauthorized
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .started: 0
            case .inProgress: 1
            case .unauthorized: 2
            case let .UNRECOGNIZED(i): i
            }
        }
    }

    public init() {}
}

#if swift(>=4.2)

    extension EventStoreDB_Client_Messages_ScavengeDatabaseResponse.ScavengeResult: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [EventStoreDB_Client_Messages_ScavengeDatabaseResponse.ScavengeResult] = [
            .started,
            .inProgress,
            .unauthorized,
        ]
    }

#endif // swift(>=4.2)

public struct EventStoreDB_Client_Messages_IdentifyClient {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var version: Int32 = 0

    public var connectionName: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStoreDB_Client_Messages_ClientIdentified {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
    extension EventStoreDB_Client_Messages_OperationResult: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_NewEvent: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_EventRecord: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_ResolvedIndexedEvent: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_ResolvedEvent: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_WriteEvents: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_WriteEventsCompleted: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_DeleteStream: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_DeleteStreamCompleted: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_TransactionStart: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_TransactionStartCompleted: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_TransactionWrite: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_TransactionWriteCompleted: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_TransactionCommit: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_TransactionCommitCompleted: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_ReadEvent: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_ReadEventCompleted: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_ReadEventCompleted.ReadEventResult: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_ReadStreamEvents: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_ReadStreamEventsCompleted: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_ReadStreamEventsCompleted.ReadStreamResult: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_ReadAllEvents: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_ReadAllEventsCompleted: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_ReadAllEventsCompleted.ReadAllResult: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_Filter: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_Filter.FilterContext: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_Filter.FilterType: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_FilteredReadAllEvents: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_FilteredReadAllEventsCompleted: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_FilteredReadAllEventsCompleted.FilteredReadAllResult: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_CreatePersistentSubscription: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_DeletePersistentSubscription: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_UpdatePersistentSubscription: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_UpdatePersistentSubscriptionCompleted: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_UpdatePersistentSubscriptionCompleted.UpdatePersistentSubscriptionResult: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_CreatePersistentSubscriptionCompleted: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_DeletePersistentSubscriptionCompleted: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_DeletePersistentSubscriptionCompleted.DeletePersistentSubscriptionResult: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_ConnectToPersistentSubscription: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_PersistentSubscriptionAckEvents: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_PersistentSubscriptionNakEvents: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_PersistentSubscriptionNakEvents.NakAction: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_PersistentSubscriptionConfirmation: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_PersistentSubscriptionStreamEventAppeared: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_SubscribeToStream: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_FilteredSubscribeToStream: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_CheckpointReached: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_SubscriptionConfirmation: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_StreamEventAppeared: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_UnsubscribeFromStream: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_SubscriptionDropped: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_SubscriptionDropped.SubscriptionDropReason: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_NotHandled: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_NotHandled.NotHandledReason: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_NotHandled.LeaderInfo: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_ScavengeDatabase: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_ScavengeDatabaseResponse: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_ScavengeDatabaseResponse.ScavengeResult: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_IdentifyClient: @unchecked Sendable {}
    extension EventStoreDB_Client_Messages_ClientIdentified: @unchecked Sendable {}
#endif // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "EventStoreDB.Client.Messages"

extension EventStoreDB_Client_Messages_OperationResult: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Success"),
        1: .same(proto: "PrepareTimeout"),
        2: .same(proto: "CommitTimeout"),
        3: .same(proto: "ForwardTimeout"),
        4: .same(proto: "WrongExpectedVersion"),
        5: .same(proto: "StreamDeleted"),
        6: .same(proto: "InvalidTransaction"),
        7: .same(proto: "AccessDenied"),
    ]
}

extension EventStoreDB_Client_Messages_NewEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".NewEvent"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "event_id"),
        2: .standard(proto: "event_type"),
        3: .standard(proto: "data_content_type"),
        4: .standard(proto: "metadata_content_type"),
        5: .same(proto: "data"),
        6: .same(proto: "metadata"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &eventID)
            case 2: try decoder.decodeSingularStringField(value: &eventType)
            case 3: try decoder.decodeSingularInt32Field(value: &dataContentType)
            case 4: try decoder.decodeSingularInt32Field(value: &metadataContentType)
            case 5: try decoder.decodeSingularBytesField(value: &data)
            case 6: try decoder.decodeSingularBytesField(value: &metadata)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !eventID.isEmpty {
            try visitor.visitSingularBytesField(value: eventID, fieldNumber: 1)
        }
        if !eventType.isEmpty {
            try visitor.visitSingularStringField(value: eventType, fieldNumber: 2)
        }
        if dataContentType != 0 {
            try visitor.visitSingularInt32Field(value: dataContentType, fieldNumber: 3)
        }
        if metadataContentType != 0 {
            try visitor.visitSingularInt32Field(value: metadataContentType, fieldNumber: 4)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 5)
        }
        if !metadata.isEmpty {
            try visitor.visitSingularBytesField(value: metadata, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_NewEvent, rhs: EventStoreDB_Client_Messages_NewEvent) -> Bool {
        if lhs.eventID != rhs.eventID { return false }
        if lhs.eventType != rhs.eventType { return false }
        if lhs.dataContentType != rhs.dataContentType { return false }
        if lhs.metadataContentType != rhs.metadataContentType { return false }
        if lhs.data != rhs.data { return false }
        if lhs.metadata != rhs.metadata { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_EventRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".EventRecord"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "event_stream_id"),
        2: .standard(proto: "event_number"),
        3: .standard(proto: "event_id"),
        4: .standard(proto: "event_type"),
        5: .standard(proto: "data_content_type"),
        6: .standard(proto: "metadata_content_type"),
        7: .same(proto: "data"),
        8: .same(proto: "metadata"),
        9: .same(proto: "created"),
        10: .standard(proto: "created_epoch"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &eventStreamID)
            case 2: try decoder.decodeSingularInt64Field(value: &eventNumber)
            case 3: try decoder.decodeSingularBytesField(value: &eventID)
            case 4: try decoder.decodeSingularStringField(value: &eventType)
            case 5: try decoder.decodeSingularInt32Field(value: &dataContentType)
            case 6: try decoder.decodeSingularInt32Field(value: &metadataContentType)
            case 7: try decoder.decodeSingularBytesField(value: &data)
            case 8: try decoder.decodeSingularBytesField(value: &metadata)
            case 9: try decoder.decodeSingularInt64Field(value: &created)
            case 10: try decoder.decodeSingularInt64Field(value: &createdEpoch)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !eventStreamID.isEmpty {
            try visitor.visitSingularStringField(value: eventStreamID, fieldNumber: 1)
        }
        if eventNumber != 0 {
            try visitor.visitSingularInt64Field(value: eventNumber, fieldNumber: 2)
        }
        if !eventID.isEmpty {
            try visitor.visitSingularBytesField(value: eventID, fieldNumber: 3)
        }
        if !eventType.isEmpty {
            try visitor.visitSingularStringField(value: eventType, fieldNumber: 4)
        }
        if dataContentType != 0 {
            try visitor.visitSingularInt32Field(value: dataContentType, fieldNumber: 5)
        }
        if metadataContentType != 0 {
            try visitor.visitSingularInt32Field(value: metadataContentType, fieldNumber: 6)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 7)
        }
        if !metadata.isEmpty {
            try visitor.visitSingularBytesField(value: metadata, fieldNumber: 8)
        }
        if created != 0 {
            try visitor.visitSingularInt64Field(value: created, fieldNumber: 9)
        }
        if createdEpoch != 0 {
            try visitor.visitSingularInt64Field(value: createdEpoch, fieldNumber: 10)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_EventRecord, rhs: EventStoreDB_Client_Messages_EventRecord) -> Bool {
        if lhs.eventStreamID != rhs.eventStreamID { return false }
        if lhs.eventNumber != rhs.eventNumber { return false }
        if lhs.eventID != rhs.eventID { return false }
        if lhs.eventType != rhs.eventType { return false }
        if lhs.dataContentType != rhs.dataContentType { return false }
        if lhs.metadataContentType != rhs.metadataContentType { return false }
        if lhs.data != rhs.data { return false }
        if lhs.metadata != rhs.metadata { return false }
        if lhs.created != rhs.created { return false }
        if lhs.createdEpoch != rhs.createdEpoch { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_ResolvedIndexedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ResolvedIndexedEvent"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "event"),
        2: .same(proto: "link"),
    ]

    fileprivate class _StorageClass {
        var _event: EventStoreDB_Client_Messages_EventRecord?
        var _link: EventStoreDB_Client_Messages_EventRecord?

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _event = source._event
            _link = source._link
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularMessageField(value: &_storage._event)
                case 2: try decoder.decodeSingularMessageField(value: &_storage._link)
                default: break
                }
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._event {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            try { if let v = _storage._link {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            } }()
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_ResolvedIndexedEvent, rhs: EventStoreDB_Client_Messages_ResolvedIndexedEvent) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._event != rhs_storage._event { return false }
                if _storage._link != rhs_storage._link { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_ResolvedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ResolvedEvent"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "event"),
        2: .same(proto: "link"),
        3: .standard(proto: "commit_position"),
        4: .standard(proto: "prepare_position"),
    ]

    fileprivate class _StorageClass {
        var _event: EventStoreDB_Client_Messages_EventRecord?
        var _link: EventStoreDB_Client_Messages_EventRecord?
        var _commitPosition: Int64 = 0
        var _preparePosition: Int64 = 0

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _event = source._event
            _link = source._link
            _commitPosition = source._commitPosition
            _preparePosition = source._preparePosition
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularMessageField(value: &_storage._event)
                case 2: try decoder.decodeSingularMessageField(value: &_storage._link)
                case 3: try decoder.decodeSingularInt64Field(value: &_storage._commitPosition)
                case 4: try decoder.decodeSingularInt64Field(value: &_storage._preparePosition)
                default: break
                }
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._event {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            try { if let v = _storage._link {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            } }()
            if _storage._commitPosition != 0 {
                try visitor.visitSingularInt64Field(value: _storage._commitPosition, fieldNumber: 3)
            }
            if _storage._preparePosition != 0 {
                try visitor.visitSingularInt64Field(value: _storage._preparePosition, fieldNumber: 4)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_ResolvedEvent, rhs: EventStoreDB_Client_Messages_ResolvedEvent) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._event != rhs_storage._event { return false }
                if _storage._link != rhs_storage._link { return false }
                if _storage._commitPosition != rhs_storage._commitPosition { return false }
                if _storage._preparePosition != rhs_storage._preparePosition { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_WriteEvents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".WriteEvents"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "event_stream_id"),
        2: .standard(proto: "expected_version"),
        3: .same(proto: "events"),
        4: .standard(proto: "require_leader"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &eventStreamID)
            case 2: try decoder.decodeSingularInt64Field(value: &expectedVersion)
            case 3: try decoder.decodeRepeatedMessageField(value: &events)
            case 4: try decoder.decodeSingularBoolField(value: &requireLeader)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !eventStreamID.isEmpty {
            try visitor.visitSingularStringField(value: eventStreamID, fieldNumber: 1)
        }
        if expectedVersion != 0 {
            try visitor.visitSingularInt64Field(value: expectedVersion, fieldNumber: 2)
        }
        if !events.isEmpty {
            try visitor.visitRepeatedMessageField(value: events, fieldNumber: 3)
        }
        if requireLeader != false {
            try visitor.visitSingularBoolField(value: requireLeader, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_WriteEvents, rhs: EventStoreDB_Client_Messages_WriteEvents) -> Bool {
        if lhs.eventStreamID != rhs.eventStreamID { return false }
        if lhs.expectedVersion != rhs.expectedVersion { return false }
        if lhs.events != rhs.events { return false }
        if lhs.requireLeader != rhs.requireLeader { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_WriteEventsCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".WriteEventsCompleted"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "result"),
        2: .same(proto: "message"),
        3: .standard(proto: "first_event_number"),
        4: .standard(proto: "last_event_number"),
        5: .standard(proto: "prepare_position"),
        6: .standard(proto: "commit_position"),
        7: .standard(proto: "current_version"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &result)
            case 2: try decoder.decodeSingularStringField(value: &message)
            case 3: try decoder.decodeSingularInt64Field(value: &firstEventNumber)
            case 4: try decoder.decodeSingularInt64Field(value: &lastEventNumber)
            case 5: try decoder.decodeSingularInt64Field(value: &preparePosition)
            case 6: try decoder.decodeSingularInt64Field(value: &commitPosition)
            case 7: try decoder.decodeSingularInt64Field(value: &currentVersion)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if result != .success {
            try visitor.visitSingularEnumField(value: result, fieldNumber: 1)
        }
        if !message.isEmpty {
            try visitor.visitSingularStringField(value: message, fieldNumber: 2)
        }
        if firstEventNumber != 0 {
            try visitor.visitSingularInt64Field(value: firstEventNumber, fieldNumber: 3)
        }
        if lastEventNumber != 0 {
            try visitor.visitSingularInt64Field(value: lastEventNumber, fieldNumber: 4)
        }
        if preparePosition != 0 {
            try visitor.visitSingularInt64Field(value: preparePosition, fieldNumber: 5)
        }
        if commitPosition != 0 {
            try visitor.visitSingularInt64Field(value: commitPosition, fieldNumber: 6)
        }
        if currentVersion != 0 {
            try visitor.visitSingularInt64Field(value: currentVersion, fieldNumber: 7)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_WriteEventsCompleted, rhs: EventStoreDB_Client_Messages_WriteEventsCompleted) -> Bool {
        if lhs.result != rhs.result { return false }
        if lhs.message != rhs.message { return false }
        if lhs.firstEventNumber != rhs.firstEventNumber { return false }
        if lhs.lastEventNumber != rhs.lastEventNumber { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.currentVersion != rhs.currentVersion { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_DeleteStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DeleteStream"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "event_stream_id"),
        2: .standard(proto: "expected_version"),
        3: .standard(proto: "require_leader"),
        4: .standard(proto: "hard_delete"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &eventStreamID)
            case 2: try decoder.decodeSingularInt64Field(value: &expectedVersion)
            case 3: try decoder.decodeSingularBoolField(value: &requireLeader)
            case 4: try decoder.decodeSingularBoolField(value: &hardDelete)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !eventStreamID.isEmpty {
            try visitor.visitSingularStringField(value: eventStreamID, fieldNumber: 1)
        }
        if expectedVersion != 0 {
            try visitor.visitSingularInt64Field(value: expectedVersion, fieldNumber: 2)
        }
        if requireLeader != false {
            try visitor.visitSingularBoolField(value: requireLeader, fieldNumber: 3)
        }
        if hardDelete != false {
            try visitor.visitSingularBoolField(value: hardDelete, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_DeleteStream, rhs: EventStoreDB_Client_Messages_DeleteStream) -> Bool {
        if lhs.eventStreamID != rhs.eventStreamID { return false }
        if lhs.expectedVersion != rhs.expectedVersion { return false }
        if lhs.requireLeader != rhs.requireLeader { return false }
        if lhs.hardDelete != rhs.hardDelete { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_DeleteStreamCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DeleteStreamCompleted"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "result"),
        2: .same(proto: "message"),
        3: .standard(proto: "prepare_position"),
        4: .standard(proto: "commit_position"),
        5: .standard(proto: "current_version"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &result)
            case 2: try decoder.decodeSingularStringField(value: &message)
            case 3: try decoder.decodeSingularInt64Field(value: &preparePosition)
            case 4: try decoder.decodeSingularInt64Field(value: &commitPosition)
            case 5: try decoder.decodeSingularInt64Field(value: &currentVersion)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if result != .success {
            try visitor.visitSingularEnumField(value: result, fieldNumber: 1)
        }
        if !message.isEmpty {
            try visitor.visitSingularStringField(value: message, fieldNumber: 2)
        }
        if preparePosition != 0 {
            try visitor.visitSingularInt64Field(value: preparePosition, fieldNumber: 3)
        }
        if commitPosition != 0 {
            try visitor.visitSingularInt64Field(value: commitPosition, fieldNumber: 4)
        }
        if currentVersion != 0 {
            try visitor.visitSingularInt64Field(value: currentVersion, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_DeleteStreamCompleted, rhs: EventStoreDB_Client_Messages_DeleteStreamCompleted) -> Bool {
        if lhs.result != rhs.result { return false }
        if lhs.message != rhs.message { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.currentVersion != rhs.currentVersion { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_TransactionStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".TransactionStart"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "event_stream_id"),
        2: .standard(proto: "expected_version"),
        3: .standard(proto: "require_leader"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &eventStreamID)
            case 2: try decoder.decodeSingularInt64Field(value: &expectedVersion)
            case 3: try decoder.decodeSingularBoolField(value: &requireLeader)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !eventStreamID.isEmpty {
            try visitor.visitSingularStringField(value: eventStreamID, fieldNumber: 1)
        }
        if expectedVersion != 0 {
            try visitor.visitSingularInt64Field(value: expectedVersion, fieldNumber: 2)
        }
        if requireLeader != false {
            try visitor.visitSingularBoolField(value: requireLeader, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_TransactionStart, rhs: EventStoreDB_Client_Messages_TransactionStart) -> Bool {
        if lhs.eventStreamID != rhs.eventStreamID { return false }
        if lhs.expectedVersion != rhs.expectedVersion { return false }
        if lhs.requireLeader != rhs.requireLeader { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_TransactionStartCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".TransactionStartCompleted"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "transaction_id"),
        2: .same(proto: "result"),
        3: .same(proto: "message"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &transactionID)
            case 2: try decoder.decodeSingularEnumField(value: &result)
            case 3: try decoder.decodeSingularStringField(value: &message)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if transactionID != 0 {
            try visitor.visitSingularInt64Field(value: transactionID, fieldNumber: 1)
        }
        if result != .success {
            try visitor.visitSingularEnumField(value: result, fieldNumber: 2)
        }
        if !message.isEmpty {
            try visitor.visitSingularStringField(value: message, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_TransactionStartCompleted, rhs: EventStoreDB_Client_Messages_TransactionStartCompleted) -> Bool {
        if lhs.transactionID != rhs.transactionID { return false }
        if lhs.result != rhs.result { return false }
        if lhs.message != rhs.message { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_TransactionWrite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".TransactionWrite"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "transaction_id"),
        2: .same(proto: "events"),
        3: .standard(proto: "require_leader"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &transactionID)
            case 2: try decoder.decodeRepeatedMessageField(value: &events)
            case 3: try decoder.decodeSingularBoolField(value: &requireLeader)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if transactionID != 0 {
            try visitor.visitSingularInt64Field(value: transactionID, fieldNumber: 1)
        }
        if !events.isEmpty {
            try visitor.visitRepeatedMessageField(value: events, fieldNumber: 2)
        }
        if requireLeader != false {
            try visitor.visitSingularBoolField(value: requireLeader, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_TransactionWrite, rhs: EventStoreDB_Client_Messages_TransactionWrite) -> Bool {
        if lhs.transactionID != rhs.transactionID { return false }
        if lhs.events != rhs.events { return false }
        if lhs.requireLeader != rhs.requireLeader { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_TransactionWriteCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".TransactionWriteCompleted"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "transaction_id"),
        2: .same(proto: "result"),
        3: .same(proto: "message"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &transactionID)
            case 2: try decoder.decodeSingularEnumField(value: &result)
            case 3: try decoder.decodeSingularStringField(value: &message)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if transactionID != 0 {
            try visitor.visitSingularInt64Field(value: transactionID, fieldNumber: 1)
        }
        if result != .success {
            try visitor.visitSingularEnumField(value: result, fieldNumber: 2)
        }
        if !message.isEmpty {
            try visitor.visitSingularStringField(value: message, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_TransactionWriteCompleted, rhs: EventStoreDB_Client_Messages_TransactionWriteCompleted) -> Bool {
        if lhs.transactionID != rhs.transactionID { return false }
        if lhs.result != rhs.result { return false }
        if lhs.message != rhs.message { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_TransactionCommit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".TransactionCommit"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "transaction_id"),
        2: .standard(proto: "require_leader"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &transactionID)
            case 2: try decoder.decodeSingularBoolField(value: &requireLeader)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if transactionID != 0 {
            try visitor.visitSingularInt64Field(value: transactionID, fieldNumber: 1)
        }
        if requireLeader != false {
            try visitor.visitSingularBoolField(value: requireLeader, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_TransactionCommit, rhs: EventStoreDB_Client_Messages_TransactionCommit) -> Bool {
        if lhs.transactionID != rhs.transactionID { return false }
        if lhs.requireLeader != rhs.requireLeader { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_TransactionCommitCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".TransactionCommitCompleted"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "transaction_id"),
        2: .same(proto: "result"),
        3: .same(proto: "message"),
        4: .standard(proto: "first_event_number"),
        5: .standard(proto: "last_event_number"),
        6: .standard(proto: "prepare_position"),
        7: .standard(proto: "commit_position"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &transactionID)
            case 2: try decoder.decodeSingularEnumField(value: &result)
            case 3: try decoder.decodeSingularStringField(value: &message)
            case 4: try decoder.decodeSingularInt64Field(value: &firstEventNumber)
            case 5: try decoder.decodeSingularInt64Field(value: &lastEventNumber)
            case 6: try decoder.decodeSingularInt64Field(value: &preparePosition)
            case 7: try decoder.decodeSingularInt64Field(value: &commitPosition)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if transactionID != 0 {
            try visitor.visitSingularInt64Field(value: transactionID, fieldNumber: 1)
        }
        if result != .success {
            try visitor.visitSingularEnumField(value: result, fieldNumber: 2)
        }
        if !message.isEmpty {
            try visitor.visitSingularStringField(value: message, fieldNumber: 3)
        }
        if firstEventNumber != 0 {
            try visitor.visitSingularInt64Field(value: firstEventNumber, fieldNumber: 4)
        }
        if lastEventNumber != 0 {
            try visitor.visitSingularInt64Field(value: lastEventNumber, fieldNumber: 5)
        }
        if preparePosition != 0 {
            try visitor.visitSingularInt64Field(value: preparePosition, fieldNumber: 6)
        }
        if commitPosition != 0 {
            try visitor.visitSingularInt64Field(value: commitPosition, fieldNumber: 7)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_TransactionCommitCompleted, rhs: EventStoreDB_Client_Messages_TransactionCommitCompleted) -> Bool {
        if lhs.transactionID != rhs.transactionID { return false }
        if lhs.result != rhs.result { return false }
        if lhs.message != rhs.message { return false }
        if lhs.firstEventNumber != rhs.firstEventNumber { return false }
        if lhs.lastEventNumber != rhs.lastEventNumber { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_ReadEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ReadEvent"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "event_stream_id"),
        2: .standard(proto: "event_number"),
        3: .standard(proto: "resolve_link_tos"),
        4: .standard(proto: "require_leader"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &eventStreamID)
            case 2: try decoder.decodeSingularInt64Field(value: &eventNumber)
            case 3: try decoder.decodeSingularBoolField(value: &resolveLinkTos)
            case 4: try decoder.decodeSingularBoolField(value: &requireLeader)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !eventStreamID.isEmpty {
            try visitor.visitSingularStringField(value: eventStreamID, fieldNumber: 1)
        }
        if eventNumber != 0 {
            try visitor.visitSingularInt64Field(value: eventNumber, fieldNumber: 2)
        }
        if resolveLinkTos != false {
            try visitor.visitSingularBoolField(value: resolveLinkTos, fieldNumber: 3)
        }
        if requireLeader != false {
            try visitor.visitSingularBoolField(value: requireLeader, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_ReadEvent, rhs: EventStoreDB_Client_Messages_ReadEvent) -> Bool {
        if lhs.eventStreamID != rhs.eventStreamID { return false }
        if lhs.eventNumber != rhs.eventNumber { return false }
        if lhs.resolveLinkTos != rhs.resolveLinkTos { return false }
        if lhs.requireLeader != rhs.requireLeader { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_ReadEventCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ReadEventCompleted"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "result"),
        2: .same(proto: "event"),
        3: .same(proto: "error"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &result)
            case 2: try decoder.decodeSingularMessageField(value: &_event)
            case 3: try decoder.decodeSingularStringField(value: &error)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if result != .success {
            try visitor.visitSingularEnumField(value: result, fieldNumber: 1)
        }
        try { if let v = self._event {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if !error.isEmpty {
            try visitor.visitSingularStringField(value: error, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_ReadEventCompleted, rhs: EventStoreDB_Client_Messages_ReadEventCompleted) -> Bool {
        if lhs.result != rhs.result { return false }
        if lhs._event != rhs._event { return false }
        if lhs.error != rhs.error { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_ReadEventCompleted.ReadEventResult: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Success"),
        1: .same(proto: "NotFound"),
        2: .same(proto: "NoStream"),
        3: .same(proto: "StreamDeleted"),
        4: .same(proto: "Error"),
        5: .same(proto: "AccessDenied"),
    ]
}

extension EventStoreDB_Client_Messages_ReadStreamEvents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ReadStreamEvents"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "event_stream_id"),
        2: .standard(proto: "from_event_number"),
        3: .standard(proto: "max_count"),
        4: .standard(proto: "resolve_link_tos"),
        5: .standard(proto: "require_leader"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &eventStreamID)
            case 2: try decoder.decodeSingularInt64Field(value: &fromEventNumber)
            case 3: try decoder.decodeSingularInt32Field(value: &maxCount)
            case 4: try decoder.decodeSingularBoolField(value: &resolveLinkTos)
            case 5: try decoder.decodeSingularBoolField(value: &requireLeader)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !eventStreamID.isEmpty {
            try visitor.visitSingularStringField(value: eventStreamID, fieldNumber: 1)
        }
        if fromEventNumber != 0 {
            try visitor.visitSingularInt64Field(value: fromEventNumber, fieldNumber: 2)
        }
        if maxCount != 0 {
            try visitor.visitSingularInt32Field(value: maxCount, fieldNumber: 3)
        }
        if resolveLinkTos != false {
            try visitor.visitSingularBoolField(value: resolveLinkTos, fieldNumber: 4)
        }
        if requireLeader != false {
            try visitor.visitSingularBoolField(value: requireLeader, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_ReadStreamEvents, rhs: EventStoreDB_Client_Messages_ReadStreamEvents) -> Bool {
        if lhs.eventStreamID != rhs.eventStreamID { return false }
        if lhs.fromEventNumber != rhs.fromEventNumber { return false }
        if lhs.maxCount != rhs.maxCount { return false }
        if lhs.resolveLinkTos != rhs.resolveLinkTos { return false }
        if lhs.requireLeader != rhs.requireLeader { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_ReadStreamEventsCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ReadStreamEventsCompleted"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "events"),
        2: .same(proto: "result"),
        3: .standard(proto: "next_event_number"),
        4: .standard(proto: "last_event_number"),
        5: .standard(proto: "is_end_of_stream"),
        6: .standard(proto: "last_commit_position"),
        7: .same(proto: "error"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &events)
            case 2: try decoder.decodeSingularEnumField(value: &result)
            case 3: try decoder.decodeSingularInt64Field(value: &nextEventNumber)
            case 4: try decoder.decodeSingularInt64Field(value: &lastEventNumber)
            case 5: try decoder.decodeSingularBoolField(value: &isEndOfStream)
            case 6: try decoder.decodeSingularInt64Field(value: &lastCommitPosition)
            case 7: try decoder.decodeSingularStringField(value: &error)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !events.isEmpty {
            try visitor.visitRepeatedMessageField(value: events, fieldNumber: 1)
        }
        if result != .success {
            try visitor.visitSingularEnumField(value: result, fieldNumber: 2)
        }
        if nextEventNumber != 0 {
            try visitor.visitSingularInt64Field(value: nextEventNumber, fieldNumber: 3)
        }
        if lastEventNumber != 0 {
            try visitor.visitSingularInt64Field(value: lastEventNumber, fieldNumber: 4)
        }
        if isEndOfStream != false {
            try visitor.visitSingularBoolField(value: isEndOfStream, fieldNumber: 5)
        }
        if lastCommitPosition != 0 {
            try visitor.visitSingularInt64Field(value: lastCommitPosition, fieldNumber: 6)
        }
        if !error.isEmpty {
            try visitor.visitSingularStringField(value: error, fieldNumber: 7)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_ReadStreamEventsCompleted, rhs: EventStoreDB_Client_Messages_ReadStreamEventsCompleted) -> Bool {
        if lhs.events != rhs.events { return false }
        if lhs.result != rhs.result { return false }
        if lhs.nextEventNumber != rhs.nextEventNumber { return false }
        if lhs.lastEventNumber != rhs.lastEventNumber { return false }
        if lhs.isEndOfStream != rhs.isEndOfStream { return false }
        if lhs.lastCommitPosition != rhs.lastCommitPosition { return false }
        if lhs.error != rhs.error { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_ReadStreamEventsCompleted.ReadStreamResult: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Success"),
        1: .same(proto: "NoStream"),
        2: .same(proto: "StreamDeleted"),
        3: .same(proto: "NotModified"),
        4: .same(proto: "Error"),
        5: .same(proto: "AccessDenied"),
    ]
}

extension EventStoreDB_Client_Messages_ReadAllEvents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ReadAllEvents"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "commit_position"),
        2: .standard(proto: "prepare_position"),
        3: .standard(proto: "max_count"),
        4: .standard(proto: "resolve_link_tos"),
        5: .standard(proto: "require_leader"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &commitPosition)
            case 2: try decoder.decodeSingularInt64Field(value: &preparePosition)
            case 3: try decoder.decodeSingularInt32Field(value: &maxCount)
            case 4: try decoder.decodeSingularBoolField(value: &resolveLinkTos)
            case 5: try decoder.decodeSingularBoolField(value: &requireLeader)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if commitPosition != 0 {
            try visitor.visitSingularInt64Field(value: commitPosition, fieldNumber: 1)
        }
        if preparePosition != 0 {
            try visitor.visitSingularInt64Field(value: preparePosition, fieldNumber: 2)
        }
        if maxCount != 0 {
            try visitor.visitSingularInt32Field(value: maxCount, fieldNumber: 3)
        }
        if resolveLinkTos != false {
            try visitor.visitSingularBoolField(value: resolveLinkTos, fieldNumber: 4)
        }
        if requireLeader != false {
            try visitor.visitSingularBoolField(value: requireLeader, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_ReadAllEvents, rhs: EventStoreDB_Client_Messages_ReadAllEvents) -> Bool {
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.maxCount != rhs.maxCount { return false }
        if lhs.resolveLinkTos != rhs.resolveLinkTos { return false }
        if lhs.requireLeader != rhs.requireLeader { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_ReadAllEventsCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ReadAllEventsCompleted"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "commit_position"),
        2: .standard(proto: "prepare_position"),
        3: .same(proto: "events"),
        4: .standard(proto: "next_commit_position"),
        5: .standard(proto: "next_prepare_position"),
        6: .same(proto: "result"),
        7: .same(proto: "error"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &commitPosition)
            case 2: try decoder.decodeSingularInt64Field(value: &preparePosition)
            case 3: try decoder.decodeRepeatedMessageField(value: &events)
            case 4: try decoder.decodeSingularInt64Field(value: &nextCommitPosition)
            case 5: try decoder.decodeSingularInt64Field(value: &nextPreparePosition)
            case 6: try decoder.decodeSingularEnumField(value: &result)
            case 7: try decoder.decodeSingularStringField(value: &error)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if commitPosition != 0 {
            try visitor.visitSingularInt64Field(value: commitPosition, fieldNumber: 1)
        }
        if preparePosition != 0 {
            try visitor.visitSingularInt64Field(value: preparePosition, fieldNumber: 2)
        }
        if !events.isEmpty {
            try visitor.visitRepeatedMessageField(value: events, fieldNumber: 3)
        }
        if nextCommitPosition != 0 {
            try visitor.visitSingularInt64Field(value: nextCommitPosition, fieldNumber: 4)
        }
        if nextPreparePosition != 0 {
            try visitor.visitSingularInt64Field(value: nextPreparePosition, fieldNumber: 5)
        }
        if result != .success {
            try visitor.visitSingularEnumField(value: result, fieldNumber: 6)
        }
        if !error.isEmpty {
            try visitor.visitSingularStringField(value: error, fieldNumber: 7)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_ReadAllEventsCompleted, rhs: EventStoreDB_Client_Messages_ReadAllEventsCompleted) -> Bool {
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.events != rhs.events { return false }
        if lhs.nextCommitPosition != rhs.nextCommitPosition { return false }
        if lhs.nextPreparePosition != rhs.nextPreparePosition { return false }
        if lhs.result != rhs.result { return false }
        if lhs.error != rhs.error { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_ReadAllEventsCompleted.ReadAllResult: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Success"),
        1: .same(proto: "NotModified"),
        2: .same(proto: "Error"),
        3: .same(proto: "AccessDenied"),
    ]
}

extension EventStoreDB_Client_Messages_Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Filter"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "context"),
        2: .same(proto: "type"),
        3: .same(proto: "data"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &context)
            case 2: try decoder.decodeSingularEnumField(value: &type)
            case 3: try decoder.decodeRepeatedStringField(value: &data)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if context != .streamID {
            try visitor.visitSingularEnumField(value: context, fieldNumber: 1)
        }
        if type != .regex {
            try visitor.visitSingularEnumField(value: type, fieldNumber: 2)
        }
        if !data.isEmpty {
            try visitor.visitRepeatedStringField(value: data, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_Filter, rhs: EventStoreDB_Client_Messages_Filter) -> Bool {
        if lhs.context != rhs.context { return false }
        if lhs.type != rhs.type { return false }
        if lhs.data != rhs.data { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_Filter.FilterContext: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "StreamId"),
        1: .same(proto: "EventType"),
    ]
}

extension EventStoreDB_Client_Messages_Filter.FilterType: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Regex"),
        1: .same(proto: "Prefix"),
    ]
}

extension EventStoreDB_Client_Messages_FilteredReadAllEvents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".FilteredReadAllEvents"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "commit_position"),
        2: .standard(proto: "prepare_position"),
        3: .standard(proto: "max_count"),
        4: .standard(proto: "max_search_window"),
        5: .standard(proto: "resolve_link_tos"),
        6: .standard(proto: "require_leader"),
        7: .same(proto: "filter"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &commitPosition)
            case 2: try decoder.decodeSingularInt64Field(value: &preparePosition)
            case 3: try decoder.decodeSingularInt32Field(value: &maxCount)
            case 4: try decoder.decodeSingularInt32Field(value: &maxSearchWindow)
            case 5: try decoder.decodeSingularBoolField(value: &resolveLinkTos)
            case 6: try decoder.decodeSingularBoolField(value: &requireLeader)
            case 7: try decoder.decodeSingularMessageField(value: &_filter)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if commitPosition != 0 {
            try visitor.visitSingularInt64Field(value: commitPosition, fieldNumber: 1)
        }
        if preparePosition != 0 {
            try visitor.visitSingularInt64Field(value: preparePosition, fieldNumber: 2)
        }
        if maxCount != 0 {
            try visitor.visitSingularInt32Field(value: maxCount, fieldNumber: 3)
        }
        if maxSearchWindow != 0 {
            try visitor.visitSingularInt32Field(value: maxSearchWindow, fieldNumber: 4)
        }
        if resolveLinkTos != false {
            try visitor.visitSingularBoolField(value: resolveLinkTos, fieldNumber: 5)
        }
        if requireLeader != false {
            try visitor.visitSingularBoolField(value: requireLeader, fieldNumber: 6)
        }
        try { if let v = self._filter {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_FilteredReadAllEvents, rhs: EventStoreDB_Client_Messages_FilteredReadAllEvents) -> Bool {
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.maxCount != rhs.maxCount { return false }
        if lhs.maxSearchWindow != rhs.maxSearchWindow { return false }
        if lhs.resolveLinkTos != rhs.resolveLinkTos { return false }
        if lhs.requireLeader != rhs.requireLeader { return false }
        if lhs._filter != rhs._filter { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_FilteredReadAllEventsCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".FilteredReadAllEventsCompleted"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "commit_position"),
        2: .standard(proto: "prepare_position"),
        3: .same(proto: "events"),
        4: .standard(proto: "next_commit_position"),
        5: .standard(proto: "next_prepare_position"),
        6: .standard(proto: "is_end_of_stream"),
        7: .same(proto: "result"),
        8: .same(proto: "error"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &commitPosition)
            case 2: try decoder.decodeSingularInt64Field(value: &preparePosition)
            case 3: try decoder.decodeRepeatedMessageField(value: &events)
            case 4: try decoder.decodeSingularInt64Field(value: &nextCommitPosition)
            case 5: try decoder.decodeSingularInt64Field(value: &nextPreparePosition)
            case 6: try decoder.decodeSingularBoolField(value: &isEndOfStream)
            case 7: try decoder.decodeSingularEnumField(value: &result)
            case 8: try decoder.decodeSingularStringField(value: &error)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if commitPosition != 0 {
            try visitor.visitSingularInt64Field(value: commitPosition, fieldNumber: 1)
        }
        if preparePosition != 0 {
            try visitor.visitSingularInt64Field(value: preparePosition, fieldNumber: 2)
        }
        if !events.isEmpty {
            try visitor.visitRepeatedMessageField(value: events, fieldNumber: 3)
        }
        if nextCommitPosition != 0 {
            try visitor.visitSingularInt64Field(value: nextCommitPosition, fieldNumber: 4)
        }
        if nextPreparePosition != 0 {
            try visitor.visitSingularInt64Field(value: nextPreparePosition, fieldNumber: 5)
        }
        if isEndOfStream != false {
            try visitor.visitSingularBoolField(value: isEndOfStream, fieldNumber: 6)
        }
        if result != .success {
            try visitor.visitSingularEnumField(value: result, fieldNumber: 7)
        }
        if !error.isEmpty {
            try visitor.visitSingularStringField(value: error, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_FilteredReadAllEventsCompleted, rhs: EventStoreDB_Client_Messages_FilteredReadAllEventsCompleted) -> Bool {
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.events != rhs.events { return false }
        if lhs.nextCommitPosition != rhs.nextCommitPosition { return false }
        if lhs.nextPreparePosition != rhs.nextPreparePosition { return false }
        if lhs.isEndOfStream != rhs.isEndOfStream { return false }
        if lhs.result != rhs.result { return false }
        if lhs.error != rhs.error { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_FilteredReadAllEventsCompleted.FilteredReadAllResult: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Success"),
        1: .same(proto: "NotModified"),
        2: .same(proto: "Error"),
        3: .same(proto: "AccessDenied"),
    ]
}

extension EventStoreDB_Client_Messages_CreatePersistentSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreatePersistentSubscription"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "subscription_group_name"),
        2: .standard(proto: "event_stream_id"),
        3: .standard(proto: "resolve_link_tos"),
        4: .standard(proto: "start_from"),
        5: .standard(proto: "message_timeout_milliseconds"),
        6: .standard(proto: "record_statistics"),
        7: .standard(proto: "live_buffer_size"),
        8: .standard(proto: "read_batch_size"),
        9: .standard(proto: "buffer_size"),
        10: .standard(proto: "max_retry_count"),
        11: .standard(proto: "prefer_round_robin"),
        12: .standard(proto: "checkpoint_after_time"),
        13: .standard(proto: "checkpoint_max_count"),
        14: .standard(proto: "checkpoint_min_count"),
        15: .standard(proto: "subscriber_max_count"),
        16: .standard(proto: "named_consumer_strategy"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &subscriptionGroupName)
            case 2: try decoder.decodeSingularStringField(value: &eventStreamID)
            case 3: try decoder.decodeSingularBoolField(value: &resolveLinkTos)
            case 4: try decoder.decodeSingularInt64Field(value: &startFrom)
            case 5: try decoder.decodeSingularInt32Field(value: &messageTimeoutMilliseconds)
            case 6: try decoder.decodeSingularBoolField(value: &recordStatistics)
            case 7: try decoder.decodeSingularInt32Field(value: &liveBufferSize)
            case 8: try decoder.decodeSingularInt32Field(value: &readBatchSize)
            case 9: try decoder.decodeSingularInt32Field(value: &bufferSize)
            case 10: try decoder.decodeSingularInt32Field(value: &maxRetryCount)
            case 11: try decoder.decodeSingularBoolField(value: &preferRoundRobin)
            case 12: try decoder.decodeSingularInt32Field(value: &checkpointAfterTime)
            case 13: try decoder.decodeSingularInt32Field(value: &checkpointMaxCount)
            case 14: try decoder.decodeSingularInt32Field(value: &checkpointMinCount)
            case 15: try decoder.decodeSingularInt32Field(value: &subscriberMaxCount)
            case 16: try decoder.decodeSingularStringField(value: &namedConsumerStrategy)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !subscriptionGroupName.isEmpty {
            try visitor.visitSingularStringField(value: subscriptionGroupName, fieldNumber: 1)
        }
        if !eventStreamID.isEmpty {
            try visitor.visitSingularStringField(value: eventStreamID, fieldNumber: 2)
        }
        if resolveLinkTos != false {
            try visitor.visitSingularBoolField(value: resolveLinkTos, fieldNumber: 3)
        }
        if startFrom != 0 {
            try visitor.visitSingularInt64Field(value: startFrom, fieldNumber: 4)
        }
        if messageTimeoutMilliseconds != 0 {
            try visitor.visitSingularInt32Field(value: messageTimeoutMilliseconds, fieldNumber: 5)
        }
        if recordStatistics != false {
            try visitor.visitSingularBoolField(value: recordStatistics, fieldNumber: 6)
        }
        if liveBufferSize != 0 {
            try visitor.visitSingularInt32Field(value: liveBufferSize, fieldNumber: 7)
        }
        if readBatchSize != 0 {
            try visitor.visitSingularInt32Field(value: readBatchSize, fieldNumber: 8)
        }
        if bufferSize != 0 {
            try visitor.visitSingularInt32Field(value: bufferSize, fieldNumber: 9)
        }
        if maxRetryCount != 0 {
            try visitor.visitSingularInt32Field(value: maxRetryCount, fieldNumber: 10)
        }
        if preferRoundRobin != false {
            try visitor.visitSingularBoolField(value: preferRoundRobin, fieldNumber: 11)
        }
        if checkpointAfterTime != 0 {
            try visitor.visitSingularInt32Field(value: checkpointAfterTime, fieldNumber: 12)
        }
        if checkpointMaxCount != 0 {
            try visitor.visitSingularInt32Field(value: checkpointMaxCount, fieldNumber: 13)
        }
        if checkpointMinCount != 0 {
            try visitor.visitSingularInt32Field(value: checkpointMinCount, fieldNumber: 14)
        }
        if subscriberMaxCount != 0 {
            try visitor.visitSingularInt32Field(value: subscriberMaxCount, fieldNumber: 15)
        }
        if !namedConsumerStrategy.isEmpty {
            try visitor.visitSingularStringField(value: namedConsumerStrategy, fieldNumber: 16)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_CreatePersistentSubscription, rhs: EventStoreDB_Client_Messages_CreatePersistentSubscription) -> Bool {
        if lhs.subscriptionGroupName != rhs.subscriptionGroupName { return false }
        if lhs.eventStreamID != rhs.eventStreamID { return false }
        if lhs.resolveLinkTos != rhs.resolveLinkTos { return false }
        if lhs.startFrom != rhs.startFrom { return false }
        if lhs.messageTimeoutMilliseconds != rhs.messageTimeoutMilliseconds { return false }
        if lhs.recordStatistics != rhs.recordStatistics { return false }
        if lhs.liveBufferSize != rhs.liveBufferSize { return false }
        if lhs.readBatchSize != rhs.readBatchSize { return false }
        if lhs.bufferSize != rhs.bufferSize { return false }
        if lhs.maxRetryCount != rhs.maxRetryCount { return false }
        if lhs.preferRoundRobin != rhs.preferRoundRobin { return false }
        if lhs.checkpointAfterTime != rhs.checkpointAfterTime { return false }
        if lhs.checkpointMaxCount != rhs.checkpointMaxCount { return false }
        if lhs.checkpointMinCount != rhs.checkpointMinCount { return false }
        if lhs.subscriberMaxCount != rhs.subscriberMaxCount { return false }
        if lhs.namedConsumerStrategy != rhs.namedConsumerStrategy { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_DeletePersistentSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DeletePersistentSubscription"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "subscription_group_name"),
        2: .standard(proto: "event_stream_id"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &subscriptionGroupName)
            case 2: try decoder.decodeSingularStringField(value: &eventStreamID)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !subscriptionGroupName.isEmpty {
            try visitor.visitSingularStringField(value: subscriptionGroupName, fieldNumber: 1)
        }
        if !eventStreamID.isEmpty {
            try visitor.visitSingularStringField(value: eventStreamID, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_DeletePersistentSubscription, rhs: EventStoreDB_Client_Messages_DeletePersistentSubscription) -> Bool {
        if lhs.subscriptionGroupName != rhs.subscriptionGroupName { return false }
        if lhs.eventStreamID != rhs.eventStreamID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_UpdatePersistentSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".UpdatePersistentSubscription"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "subscription_group_name"),
        2: .standard(proto: "event_stream_id"),
        3: .standard(proto: "resolve_link_tos"),
        4: .standard(proto: "start_from"),
        5: .standard(proto: "message_timeout_milliseconds"),
        6: .standard(proto: "record_statistics"),
        7: .standard(proto: "live_buffer_size"),
        8: .standard(proto: "read_batch_size"),
        9: .standard(proto: "buffer_size"),
        10: .standard(proto: "max_retry_count"),
        11: .standard(proto: "prefer_round_robin"),
        12: .standard(proto: "checkpoint_after_time"),
        13: .standard(proto: "checkpoint_max_count"),
        14: .standard(proto: "checkpoint_min_count"),
        15: .standard(proto: "subscriber_max_count"),
        16: .standard(proto: "named_consumer_strategy"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &subscriptionGroupName)
            case 2: try decoder.decodeSingularStringField(value: &eventStreamID)
            case 3: try decoder.decodeSingularBoolField(value: &resolveLinkTos)
            case 4: try decoder.decodeSingularInt64Field(value: &startFrom)
            case 5: try decoder.decodeSingularInt32Field(value: &messageTimeoutMilliseconds)
            case 6: try decoder.decodeSingularBoolField(value: &recordStatistics)
            case 7: try decoder.decodeSingularInt32Field(value: &liveBufferSize)
            case 8: try decoder.decodeSingularInt32Field(value: &readBatchSize)
            case 9: try decoder.decodeSingularInt32Field(value: &bufferSize)
            case 10: try decoder.decodeSingularInt32Field(value: &maxRetryCount)
            case 11: try decoder.decodeSingularBoolField(value: &preferRoundRobin)
            case 12: try decoder.decodeSingularInt32Field(value: &checkpointAfterTime)
            case 13: try decoder.decodeSingularInt32Field(value: &checkpointMaxCount)
            case 14: try decoder.decodeSingularInt32Field(value: &checkpointMinCount)
            case 15: try decoder.decodeSingularInt32Field(value: &subscriberMaxCount)
            case 16: try decoder.decodeSingularStringField(value: &namedConsumerStrategy)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !subscriptionGroupName.isEmpty {
            try visitor.visitSingularStringField(value: subscriptionGroupName, fieldNumber: 1)
        }
        if !eventStreamID.isEmpty {
            try visitor.visitSingularStringField(value: eventStreamID, fieldNumber: 2)
        }
        if resolveLinkTos != false {
            try visitor.visitSingularBoolField(value: resolveLinkTos, fieldNumber: 3)
        }
        if startFrom != 0 {
            try visitor.visitSingularInt64Field(value: startFrom, fieldNumber: 4)
        }
        if messageTimeoutMilliseconds != 0 {
            try visitor.visitSingularInt32Field(value: messageTimeoutMilliseconds, fieldNumber: 5)
        }
        if recordStatistics != false {
            try visitor.visitSingularBoolField(value: recordStatistics, fieldNumber: 6)
        }
        if liveBufferSize != 0 {
            try visitor.visitSingularInt32Field(value: liveBufferSize, fieldNumber: 7)
        }
        if readBatchSize != 0 {
            try visitor.visitSingularInt32Field(value: readBatchSize, fieldNumber: 8)
        }
        if bufferSize != 0 {
            try visitor.visitSingularInt32Field(value: bufferSize, fieldNumber: 9)
        }
        if maxRetryCount != 0 {
            try visitor.visitSingularInt32Field(value: maxRetryCount, fieldNumber: 10)
        }
        if preferRoundRobin != false {
            try visitor.visitSingularBoolField(value: preferRoundRobin, fieldNumber: 11)
        }
        if checkpointAfterTime != 0 {
            try visitor.visitSingularInt32Field(value: checkpointAfterTime, fieldNumber: 12)
        }
        if checkpointMaxCount != 0 {
            try visitor.visitSingularInt32Field(value: checkpointMaxCount, fieldNumber: 13)
        }
        if checkpointMinCount != 0 {
            try visitor.visitSingularInt32Field(value: checkpointMinCount, fieldNumber: 14)
        }
        if subscriberMaxCount != 0 {
            try visitor.visitSingularInt32Field(value: subscriberMaxCount, fieldNumber: 15)
        }
        if !namedConsumerStrategy.isEmpty {
            try visitor.visitSingularStringField(value: namedConsumerStrategy, fieldNumber: 16)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_UpdatePersistentSubscription, rhs: EventStoreDB_Client_Messages_UpdatePersistentSubscription) -> Bool {
        if lhs.subscriptionGroupName != rhs.subscriptionGroupName { return false }
        if lhs.eventStreamID != rhs.eventStreamID { return false }
        if lhs.resolveLinkTos != rhs.resolveLinkTos { return false }
        if lhs.startFrom != rhs.startFrom { return false }
        if lhs.messageTimeoutMilliseconds != rhs.messageTimeoutMilliseconds { return false }
        if lhs.recordStatistics != rhs.recordStatistics { return false }
        if lhs.liveBufferSize != rhs.liveBufferSize { return false }
        if lhs.readBatchSize != rhs.readBatchSize { return false }
        if lhs.bufferSize != rhs.bufferSize { return false }
        if lhs.maxRetryCount != rhs.maxRetryCount { return false }
        if lhs.preferRoundRobin != rhs.preferRoundRobin { return false }
        if lhs.checkpointAfterTime != rhs.checkpointAfterTime { return false }
        if lhs.checkpointMaxCount != rhs.checkpointMaxCount { return false }
        if lhs.checkpointMinCount != rhs.checkpointMinCount { return false }
        if lhs.subscriberMaxCount != rhs.subscriberMaxCount { return false }
        if lhs.namedConsumerStrategy != rhs.namedConsumerStrategy { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_UpdatePersistentSubscriptionCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".UpdatePersistentSubscriptionCompleted"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "result"),
        2: .same(proto: "reason"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &result)
            case 2: try decoder.decodeSingularStringField(value: &reason)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if result != .success {
            try visitor.visitSingularEnumField(value: result, fieldNumber: 1)
        }
        if !reason.isEmpty {
            try visitor.visitSingularStringField(value: reason, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_UpdatePersistentSubscriptionCompleted, rhs: EventStoreDB_Client_Messages_UpdatePersistentSubscriptionCompleted) -> Bool {
        if lhs.result != rhs.result { return false }
        if lhs.reason != rhs.reason { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_UpdatePersistentSubscriptionCompleted.UpdatePersistentSubscriptionResult: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Success"),
        1: .same(proto: "DoesNotExist"),
        2: .same(proto: "Fail"),
        3: .same(proto: "AccessDenied"),
    ]
}

extension EventStoreDB_Client_Messages_CreatePersistentSubscriptionCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreatePersistentSubscriptionCompleted"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "result"),
        2: .same(proto: "reason"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &result)
            case 2: try decoder.decodeSingularStringField(value: &reason)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if result != .success {
            try visitor.visitSingularEnumField(value: result, fieldNumber: 1)
        }
        if !reason.isEmpty {
            try visitor.visitSingularStringField(value: reason, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_CreatePersistentSubscriptionCompleted, rhs: EventStoreDB_Client_Messages_CreatePersistentSubscriptionCompleted) -> Bool {
        if lhs.result != rhs.result { return false }
        if lhs.reason != rhs.reason { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Success"),
        1: .same(proto: "AlreadyExists"),
        2: .same(proto: "Fail"),
        3: .same(proto: "AccessDenied"),
    ]
}

extension EventStoreDB_Client_Messages_DeletePersistentSubscriptionCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DeletePersistentSubscriptionCompleted"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "result"),
        2: .same(proto: "reason"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &result)
            case 2: try decoder.decodeSingularStringField(value: &reason)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if result != .success {
            try visitor.visitSingularEnumField(value: result, fieldNumber: 1)
        }
        if !reason.isEmpty {
            try visitor.visitSingularStringField(value: reason, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_DeletePersistentSubscriptionCompleted, rhs: EventStoreDB_Client_Messages_DeletePersistentSubscriptionCompleted) -> Bool {
        if lhs.result != rhs.result { return false }
        if lhs.reason != rhs.reason { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_DeletePersistentSubscriptionCompleted.DeletePersistentSubscriptionResult: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Success"),
        1: .same(proto: "DoesNotExist"),
        2: .same(proto: "Fail"),
        3: .same(proto: "AccessDenied"),
    ]
}

extension EventStoreDB_Client_Messages_ConnectToPersistentSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ConnectToPersistentSubscription"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "subscription_id"),
        2: .standard(proto: "event_stream_id"),
        3: .standard(proto: "allowed_in_flight_messages"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &subscriptionID)
            case 2: try decoder.decodeSingularStringField(value: &eventStreamID)
            case 3: try decoder.decodeSingularInt32Field(value: &allowedInFlightMessages)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !subscriptionID.isEmpty {
            try visitor.visitSingularStringField(value: subscriptionID, fieldNumber: 1)
        }
        if !eventStreamID.isEmpty {
            try visitor.visitSingularStringField(value: eventStreamID, fieldNumber: 2)
        }
        if allowedInFlightMessages != 0 {
            try visitor.visitSingularInt32Field(value: allowedInFlightMessages, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_ConnectToPersistentSubscription, rhs: EventStoreDB_Client_Messages_ConnectToPersistentSubscription) -> Bool {
        if lhs.subscriptionID != rhs.subscriptionID { return false }
        if lhs.eventStreamID != rhs.eventStreamID { return false }
        if lhs.allowedInFlightMessages != rhs.allowedInFlightMessages { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_PersistentSubscriptionAckEvents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".PersistentSubscriptionAckEvents"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "subscription_id"),
        2: .standard(proto: "processed_event_ids"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &subscriptionID)
            case 2: try decoder.decodeRepeatedBytesField(value: &processedEventIds)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !subscriptionID.isEmpty {
            try visitor.visitSingularStringField(value: subscriptionID, fieldNumber: 1)
        }
        if !processedEventIds.isEmpty {
            try visitor.visitRepeatedBytesField(value: processedEventIds, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_PersistentSubscriptionAckEvents, rhs: EventStoreDB_Client_Messages_PersistentSubscriptionAckEvents) -> Bool {
        if lhs.subscriptionID != rhs.subscriptionID { return false }
        if lhs.processedEventIds != rhs.processedEventIds { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_PersistentSubscriptionNakEvents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".PersistentSubscriptionNakEvents"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "subscription_id"),
        2: .standard(proto: "processed_event_ids"),
        3: .same(proto: "message"),
        4: .same(proto: "action"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &subscriptionID)
            case 2: try decoder.decodeRepeatedBytesField(value: &processedEventIds)
            case 3: try decoder.decodeSingularStringField(value: &message)
            case 4: try decoder.decodeSingularEnumField(value: &action)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !subscriptionID.isEmpty {
            try visitor.visitSingularStringField(value: subscriptionID, fieldNumber: 1)
        }
        if !processedEventIds.isEmpty {
            try visitor.visitRepeatedBytesField(value: processedEventIds, fieldNumber: 2)
        }
        if !message.isEmpty {
            try visitor.visitSingularStringField(value: message, fieldNumber: 3)
        }
        if action != .unknown {
            try visitor.visitSingularEnumField(value: action, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_PersistentSubscriptionNakEvents, rhs: EventStoreDB_Client_Messages_PersistentSubscriptionNakEvents) -> Bool {
        if lhs.subscriptionID != rhs.subscriptionID { return false }
        if lhs.processedEventIds != rhs.processedEventIds { return false }
        if lhs.message != rhs.message { return false }
        if lhs.action != rhs.action { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_PersistentSubscriptionNakEvents.NakAction: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Unknown"),
        1: .same(proto: "Park"),
        2: .same(proto: "Retry"),
        3: .same(proto: "Skip"),
        4: .same(proto: "Stop"),
    ]
}

extension EventStoreDB_Client_Messages_PersistentSubscriptionConfirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".PersistentSubscriptionConfirmation"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "last_commit_position"),
        2: .standard(proto: "subscription_id"),
        3: .standard(proto: "last_event_number"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &lastCommitPosition)
            case 2: try decoder.decodeSingularStringField(value: &subscriptionID)
            case 3: try decoder.decodeSingularInt64Field(value: &lastEventNumber)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if lastCommitPosition != 0 {
            try visitor.visitSingularInt64Field(value: lastCommitPosition, fieldNumber: 1)
        }
        if !subscriptionID.isEmpty {
            try visitor.visitSingularStringField(value: subscriptionID, fieldNumber: 2)
        }
        if lastEventNumber != 0 {
            try visitor.visitSingularInt64Field(value: lastEventNumber, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_PersistentSubscriptionConfirmation, rhs: EventStoreDB_Client_Messages_PersistentSubscriptionConfirmation) -> Bool {
        if lhs.lastCommitPosition != rhs.lastCommitPosition { return false }
        if lhs.subscriptionID != rhs.subscriptionID { return false }
        if lhs.lastEventNumber != rhs.lastEventNumber { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_PersistentSubscriptionStreamEventAppeared: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".PersistentSubscriptionStreamEventAppeared"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "event"),
        2: .same(proto: "retryCount"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_event)
            case 2: try decoder.decodeSingularInt32Field(value: &retryCount)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _event {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if retryCount != 0 {
            try visitor.visitSingularInt32Field(value: retryCount, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_PersistentSubscriptionStreamEventAppeared, rhs: EventStoreDB_Client_Messages_PersistentSubscriptionStreamEventAppeared) -> Bool {
        if lhs._event != rhs._event { return false }
        if lhs.retryCount != rhs.retryCount { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_SubscribeToStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".SubscribeToStream"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "event_stream_id"),
        2: .standard(proto: "resolve_link_tos"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &eventStreamID)
            case 2: try decoder.decodeSingularBoolField(value: &resolveLinkTos)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !eventStreamID.isEmpty {
            try visitor.visitSingularStringField(value: eventStreamID, fieldNumber: 1)
        }
        if resolveLinkTos != false {
            try visitor.visitSingularBoolField(value: resolveLinkTos, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_SubscribeToStream, rhs: EventStoreDB_Client_Messages_SubscribeToStream) -> Bool {
        if lhs.eventStreamID != rhs.eventStreamID { return false }
        if lhs.resolveLinkTos != rhs.resolveLinkTos { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_FilteredSubscribeToStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".FilteredSubscribeToStream"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "event_stream_id"),
        2: .standard(proto: "resolve_link_tos"),
        3: .same(proto: "filter"),
        4: .standard(proto: "checkpoint_interval"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &eventStreamID)
            case 2: try decoder.decodeSingularBoolField(value: &resolveLinkTos)
            case 3: try decoder.decodeSingularMessageField(value: &_filter)
            case 4: try decoder.decodeSingularInt32Field(value: &checkpointInterval)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !eventStreamID.isEmpty {
            try visitor.visitSingularStringField(value: eventStreamID, fieldNumber: 1)
        }
        if resolveLinkTos != false {
            try visitor.visitSingularBoolField(value: resolveLinkTos, fieldNumber: 2)
        }
        try { if let v = self._filter {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        if checkpointInterval != 0 {
            try visitor.visitSingularInt32Field(value: checkpointInterval, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_FilteredSubscribeToStream, rhs: EventStoreDB_Client_Messages_FilteredSubscribeToStream) -> Bool {
        if lhs.eventStreamID != rhs.eventStreamID { return false }
        if lhs.resolveLinkTos != rhs.resolveLinkTos { return false }
        if lhs._filter != rhs._filter { return false }
        if lhs.checkpointInterval != rhs.checkpointInterval { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_CheckpointReached: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CheckpointReached"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "commit_position"),
        2: .standard(proto: "prepare_position"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &commitPosition)
            case 2: try decoder.decodeSingularInt64Field(value: &preparePosition)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if commitPosition != 0 {
            try visitor.visitSingularInt64Field(value: commitPosition, fieldNumber: 1)
        }
        if preparePosition != 0 {
            try visitor.visitSingularInt64Field(value: preparePosition, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_CheckpointReached, rhs: EventStoreDB_Client_Messages_CheckpointReached) -> Bool {
        if lhs.commitPosition != rhs.commitPosition { return false }
        if lhs.preparePosition != rhs.preparePosition { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_SubscriptionConfirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".SubscriptionConfirmation"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "last_commit_position"),
        2: .standard(proto: "last_event_number"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &lastCommitPosition)
            case 2: try decoder.decodeSingularInt64Field(value: &lastEventNumber)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if lastCommitPosition != 0 {
            try visitor.visitSingularInt64Field(value: lastCommitPosition, fieldNumber: 1)
        }
        if lastEventNumber != 0 {
            try visitor.visitSingularInt64Field(value: lastEventNumber, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_SubscriptionConfirmation, rhs: EventStoreDB_Client_Messages_SubscriptionConfirmation) -> Bool {
        if lhs.lastCommitPosition != rhs.lastCommitPosition { return false }
        if lhs.lastEventNumber != rhs.lastEventNumber { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_StreamEventAppeared: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".StreamEventAppeared"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "event"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_event)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _event {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_StreamEventAppeared, rhs: EventStoreDB_Client_Messages_StreamEventAppeared) -> Bool {
        if lhs._event != rhs._event { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_UnsubscribeFromStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".UnsubscribeFromStream"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_UnsubscribeFromStream, rhs: EventStoreDB_Client_Messages_UnsubscribeFromStream) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_SubscriptionDropped: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".SubscriptionDropped"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "reason"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &reason)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if reason != .unsubscribed {
            try visitor.visitSingularEnumField(value: reason, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_SubscriptionDropped, rhs: EventStoreDB_Client_Messages_SubscriptionDropped) -> Bool {
        if lhs.reason != rhs.reason { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_SubscriptionDropped.SubscriptionDropReason: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Unsubscribed"),
        1: .same(proto: "AccessDenied"),
        2: .same(proto: "NotFound"),
        3: .same(proto: "PersistentSubscriptionDeleted"),
        4: .same(proto: "SubscriberMaxCountReached"),
    ]
}

extension EventStoreDB_Client_Messages_NotHandled: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".NotHandled"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "reason"),
        2: .standard(proto: "additional_info"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &reason)
            case 2: try decoder.decodeSingularBytesField(value: &additionalInfo)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if reason != .notReady {
            try visitor.visitSingularEnumField(value: reason, fieldNumber: 1)
        }
        if !additionalInfo.isEmpty {
            try visitor.visitSingularBytesField(value: additionalInfo, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_NotHandled, rhs: EventStoreDB_Client_Messages_NotHandled) -> Bool {
        if lhs.reason != rhs.reason { return false }
        if lhs.additionalInfo != rhs.additionalInfo { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_NotHandled.NotHandledReason: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "NotReady"),
        1: .same(proto: "TooBusy"),
        2: .same(proto: "NotLeader"),
        3: .same(proto: "IsReadOnly"),
    ]
}

extension EventStoreDB_Client_Messages_NotHandled.LeaderInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStoreDB_Client_Messages_NotHandled.protoMessageName + ".LeaderInfo"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "external_tcp_address"),
        2: .standard(proto: "external_tcp_port"),
        3: .standard(proto: "http_address"),
        4: .standard(proto: "http_port"),
        5: .standard(proto: "external_secure_tcp_address"),
        6: .standard(proto: "external_secure_tcp_port"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &externalTcpAddress)
            case 2: try decoder.decodeSingularInt32Field(value: &externalTcpPort)
            case 3: try decoder.decodeSingularStringField(value: &httpAddress)
            case 4: try decoder.decodeSingularInt32Field(value: &httpPort)
            case 5: try decoder.decodeSingularStringField(value: &externalSecureTcpAddress)
            case 6: try decoder.decodeSingularInt32Field(value: &externalSecureTcpPort)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !externalTcpAddress.isEmpty {
            try visitor.visitSingularStringField(value: externalTcpAddress, fieldNumber: 1)
        }
        if externalTcpPort != 0 {
            try visitor.visitSingularInt32Field(value: externalTcpPort, fieldNumber: 2)
        }
        if !httpAddress.isEmpty {
            try visitor.visitSingularStringField(value: httpAddress, fieldNumber: 3)
        }
        if httpPort != 0 {
            try visitor.visitSingularInt32Field(value: httpPort, fieldNumber: 4)
        }
        if !externalSecureTcpAddress.isEmpty {
            try visitor.visitSingularStringField(value: externalSecureTcpAddress, fieldNumber: 5)
        }
        if externalSecureTcpPort != 0 {
            try visitor.visitSingularInt32Field(value: externalSecureTcpPort, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_NotHandled.LeaderInfo, rhs: EventStoreDB_Client_Messages_NotHandled.LeaderInfo) -> Bool {
        if lhs.externalTcpAddress != rhs.externalTcpAddress { return false }
        if lhs.externalTcpPort != rhs.externalTcpPort { return false }
        if lhs.httpAddress != rhs.httpAddress { return false }
        if lhs.httpPort != rhs.httpPort { return false }
        if lhs.externalSecureTcpAddress != rhs.externalSecureTcpAddress { return false }
        if lhs.externalSecureTcpPort != rhs.externalSecureTcpPort { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_ScavengeDatabase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ScavengeDatabase"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_ScavengeDatabase, rhs: EventStoreDB_Client_Messages_ScavengeDatabase) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_ScavengeDatabaseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ScavengeDatabaseResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "result"),
        2: .same(proto: "scavengeId"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &result)
            case 2: try decoder.decodeSingularStringField(value: &scavengeID)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if result != .started {
            try visitor.visitSingularEnumField(value: result, fieldNumber: 1)
        }
        if !scavengeID.isEmpty {
            try visitor.visitSingularStringField(value: scavengeID, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_ScavengeDatabaseResponse, rhs: EventStoreDB_Client_Messages_ScavengeDatabaseResponse) -> Bool {
        if lhs.result != rhs.result { return false }
        if lhs.scavengeID != rhs.scavengeID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_ScavengeDatabaseResponse.ScavengeResult: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Started"),
        1: .same(proto: "InProgress"),
        2: .same(proto: "Unauthorized"),
    ]
}

extension EventStoreDB_Client_Messages_IdentifyClient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".IdentifyClient"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "version"),
        2: .standard(proto: "connection_name"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt32Field(value: &version)
            case 2: try decoder.decodeSingularStringField(value: &connectionName)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if version != 0 {
            try visitor.visitSingularInt32Field(value: version, fieldNumber: 1)
        }
        if !connectionName.isEmpty {
            try visitor.visitSingularStringField(value: connectionName, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_IdentifyClient, rhs: EventStoreDB_Client_Messages_IdentifyClient) -> Bool {
        if lhs.version != rhs.version { return false }
        if lhs.connectionName != rhs.connectionName { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStoreDB_Client_Messages_ClientIdentified: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ClientIdentified"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStoreDB_Client_Messages_ClientIdentified, rhs: EventStoreDB_Client_Messages_ClientIdentified) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
