// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protos/ClientMessageDtos.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum EventStoreDB_Client_Messages_OperationResult: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case success // = 0
  case prepareTimeout // = 1
  case commitTimeout // = 2
  case forwardTimeout // = 3
  case wrongExpectedVersion // = 4
  case streamDeleted // = 5
  case invalidTransaction // = 6
  case accessDenied // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .success
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .success
    case 1: self = .prepareTimeout
    case 2: self = .commitTimeout
    case 3: self = .forwardTimeout
    case 4: self = .wrongExpectedVersion
    case 5: self = .streamDeleted
    case 6: self = .invalidTransaction
    case 7: self = .accessDenied
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .success: return 0
    case .prepareTimeout: return 1
    case .commitTimeout: return 2
    case .forwardTimeout: return 3
    case .wrongExpectedVersion: return 4
    case .streamDeleted: return 5
    case .invalidTransaction: return 6
    case .accessDenied: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension EventStoreDB_Client_Messages_OperationResult: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [EventStoreDB_Client_Messages_OperationResult] = [
    .success,
    .prepareTimeout,
    .commitTimeout,
    .forwardTimeout,
    .wrongExpectedVersion,
    .streamDeleted,
    .invalidTransaction,
    .accessDenied,
  ]
}

#endif  // swift(>=4.2)

public struct EventStoreDB_Client_Messages_NewEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventID: Data = Data()

  public var eventType: String = String()

  public var dataContentType: Int32 = 0

  public var metadataContentType: Int32 = 0

  public var data: Data = Data()

  public var metadata: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_EventRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventStreamID: String = String()

  public var eventNumber: Int64 = 0

  public var eventID: Data = Data()

  public var eventType: String = String()

  public var dataContentType: Int32 = 0

  public var metadataContentType: Int32 = 0

  public var data: Data = Data()

  public var metadata: Data = Data()

  public var created: Int64 = 0

  public var createdEpoch: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_ResolvedIndexedEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var event: EventStoreDB_Client_Messages_EventRecord {
    get {return _storage._event ?? EventStoreDB_Client_Messages_EventRecord()}
    set {_uniqueStorage()._event = newValue}
  }
  /// Returns true if `event` has been explicitly set.
  public var hasEvent: Bool {return _storage._event != nil}
  /// Clears the value of `event`. Subsequent reads from it will return its default value.
  public mutating func clearEvent() {_uniqueStorage()._event = nil}

  public var link: EventStoreDB_Client_Messages_EventRecord {
    get {return _storage._link ?? EventStoreDB_Client_Messages_EventRecord()}
    set {_uniqueStorage()._link = newValue}
  }
  /// Returns true if `link` has been explicitly set.
  public var hasLink: Bool {return _storage._link != nil}
  /// Clears the value of `link`. Subsequent reads from it will return its default value.
  public mutating func clearLink() {_uniqueStorage()._link = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct EventStoreDB_Client_Messages_ResolvedEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var event: EventStoreDB_Client_Messages_EventRecord {
    get {return _storage._event ?? EventStoreDB_Client_Messages_EventRecord()}
    set {_uniqueStorage()._event = newValue}
  }
  /// Returns true if `event` has been explicitly set.
  public var hasEvent: Bool {return _storage._event != nil}
  /// Clears the value of `event`. Subsequent reads from it will return its default value.
  public mutating func clearEvent() {_uniqueStorage()._event = nil}

  public var link: EventStoreDB_Client_Messages_EventRecord {
    get {return _storage._link ?? EventStoreDB_Client_Messages_EventRecord()}
    set {_uniqueStorage()._link = newValue}
  }
  /// Returns true if `link` has been explicitly set.
  public var hasLink: Bool {return _storage._link != nil}
  /// Clears the value of `link`. Subsequent reads from it will return its default value.
  public mutating func clearLink() {_uniqueStorage()._link = nil}

  public var commitPosition: Int64 {
    get {return _storage._commitPosition}
    set {_uniqueStorage()._commitPosition = newValue}
  }

  public var preparePosition: Int64 {
    get {return _storage._preparePosition}
    set {_uniqueStorage()._preparePosition = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct EventStoreDB_Client_Messages_WriteEvents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventStreamID: String = String()

  public var expectedVersion: Int64 = 0

  public var events: [EventStoreDB_Client_Messages_NewEvent] = []

  public var requireLeader: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_WriteEventsCompleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: EventStoreDB_Client_Messages_OperationResult = .success

  public var message: String = String()

  public var firstEventNumber: Int64 = 0

  public var lastEventNumber: Int64 = 0

  public var preparePosition: Int64 = 0

  public var commitPosition: Int64 = 0

  public var currentVersion: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_DeleteStream {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventStreamID: String = String()

  public var expectedVersion: Int64 = 0

  public var requireLeader: Bool = false

  public var hardDelete: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_DeleteStreamCompleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: EventStoreDB_Client_Messages_OperationResult = .success

  public var message: String = String()

  public var preparePosition: Int64 = 0

  public var commitPosition: Int64 = 0

  public var currentVersion: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_TransactionStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventStreamID: String = String()

  public var expectedVersion: Int64 = 0

  public var requireLeader: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_TransactionStartCompleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transactionID: Int64 = 0

  public var result: EventStoreDB_Client_Messages_OperationResult = .success

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_TransactionWrite {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transactionID: Int64 = 0

  public var events: [EventStoreDB_Client_Messages_NewEvent] = []

  public var requireLeader: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_TransactionWriteCompleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transactionID: Int64 = 0

  public var result: EventStoreDB_Client_Messages_OperationResult = .success

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_TransactionCommit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transactionID: Int64 = 0

  public var requireLeader: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_TransactionCommitCompleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transactionID: Int64 = 0

  public var result: EventStoreDB_Client_Messages_OperationResult = .success

  public var message: String = String()

  public var firstEventNumber: Int64 = 0

  public var lastEventNumber: Int64 = 0

  public var preparePosition: Int64 = 0

  public var commitPosition: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_ReadEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventStreamID: String = String()

  public var eventNumber: Int64 = 0

  public var resolveLinkTos: Bool = false

  public var requireLeader: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_ReadEventCompleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: EventStoreDB_Client_Messages_ReadEventCompleted.ReadEventResult = .success

  public var event: EventStoreDB_Client_Messages_ResolvedIndexedEvent {
    get {return _event ?? EventStoreDB_Client_Messages_ResolvedIndexedEvent()}
    set {_event = newValue}
  }
  /// Returns true if `event` has been explicitly set.
  public var hasEvent: Bool {return self._event != nil}
  /// Clears the value of `event`. Subsequent reads from it will return its default value.
  public mutating func clearEvent() {self._event = nil}

  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ReadEventResult: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case success // = 0
    case notFound // = 1
    case noStream // = 2
    case streamDeleted // = 3
    case error // = 4
    case accessDenied // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .success
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .success
      case 1: self = .notFound
      case 2: self = .noStream
      case 3: self = .streamDeleted
      case 4: self = .error
      case 5: self = .accessDenied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .success: return 0
      case .notFound: return 1
      case .noStream: return 2
      case .streamDeleted: return 3
      case .error: return 4
      case .accessDenied: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _event: EventStoreDB_Client_Messages_ResolvedIndexedEvent? = nil
}

#if swift(>=4.2)

extension EventStoreDB_Client_Messages_ReadEventCompleted.ReadEventResult: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [EventStoreDB_Client_Messages_ReadEventCompleted.ReadEventResult] = [
    .success,
    .notFound,
    .noStream,
    .streamDeleted,
    .error,
    .accessDenied,
  ]
}

#endif  // swift(>=4.2)

public struct EventStoreDB_Client_Messages_ReadStreamEvents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventStreamID: String = String()

  public var fromEventNumber: Int64 = 0

  public var maxCount: Int32 = 0

  public var resolveLinkTos: Bool = false

  public var requireLeader: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_ReadStreamEventsCompleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var events: [EventStoreDB_Client_Messages_ResolvedIndexedEvent] = []

  public var result: EventStoreDB_Client_Messages_ReadStreamEventsCompleted.ReadStreamResult = .success

  public var nextEventNumber: Int64 = 0

  public var lastEventNumber: Int64 = 0

  public var isEndOfStream: Bool = false

  public var lastCommitPosition: Int64 = 0

  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ReadStreamResult: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case success // = 0
    case noStream // = 1
    case streamDeleted // = 2
    case notModified // = 3
    case error // = 4
    case accessDenied // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .success
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .success
      case 1: self = .noStream
      case 2: self = .streamDeleted
      case 3: self = .notModified
      case 4: self = .error
      case 5: self = .accessDenied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .success: return 0
      case .noStream: return 1
      case .streamDeleted: return 2
      case .notModified: return 3
      case .error: return 4
      case .accessDenied: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension EventStoreDB_Client_Messages_ReadStreamEventsCompleted.ReadStreamResult: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [EventStoreDB_Client_Messages_ReadStreamEventsCompleted.ReadStreamResult] = [
    .success,
    .noStream,
    .streamDeleted,
    .notModified,
    .error,
    .accessDenied,
  ]
}

#endif  // swift(>=4.2)

public struct EventStoreDB_Client_Messages_ReadAllEvents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var commitPosition: Int64 = 0

  public var preparePosition: Int64 = 0

  public var maxCount: Int32 = 0

  public var resolveLinkTos: Bool = false

  public var requireLeader: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_ReadAllEventsCompleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var commitPosition: Int64 = 0

  public var preparePosition: Int64 = 0

  public var events: [EventStoreDB_Client_Messages_ResolvedEvent] = []

  public var nextCommitPosition: Int64 = 0

  public var nextPreparePosition: Int64 = 0

  public var result: EventStoreDB_Client_Messages_ReadAllEventsCompleted.ReadAllResult = .success

  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ReadAllResult: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case success // = 0
    case notModified // = 1
    case error // = 2
    case accessDenied // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .success
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .success
      case 1: self = .notModified
      case 2: self = .error
      case 3: self = .accessDenied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .success: return 0
      case .notModified: return 1
      case .error: return 2
      case .accessDenied: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension EventStoreDB_Client_Messages_ReadAllEventsCompleted.ReadAllResult: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [EventStoreDB_Client_Messages_ReadAllEventsCompleted.ReadAllResult] = [
    .success,
    .notModified,
    .error,
    .accessDenied,
  ]
}

#endif  // swift(>=4.2)

public struct EventStoreDB_Client_Messages_Filter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var context: EventStoreDB_Client_Messages_Filter.FilterContext = .streamID

  public var type: EventStoreDB_Client_Messages_Filter.FilterType = .regex

  public var data: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum FilterContext: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case streamID // = 0
    case eventType // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .streamID
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .streamID
      case 1: self = .eventType
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .streamID: return 0
      case .eventType: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum FilterType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case regex // = 0
    case prefix // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .regex
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .regex
      case 1: self = .prefix
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .regex: return 0
      case .prefix: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension EventStoreDB_Client_Messages_Filter.FilterContext: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [EventStoreDB_Client_Messages_Filter.FilterContext] = [
    .streamID,
    .eventType,
  ]
}

extension EventStoreDB_Client_Messages_Filter.FilterType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [EventStoreDB_Client_Messages_Filter.FilterType] = [
    .regex,
    .prefix,
  ]
}

#endif  // swift(>=4.2)

public struct EventStoreDB_Client_Messages_FilteredReadAllEvents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var commitPosition: Int64 = 0

  public var preparePosition: Int64 = 0

  public var maxCount: Int32 = 0

  public var maxSearchWindow: Int32 = 0

  public var resolveLinkTos: Bool = false

  public var requireLeader: Bool = false

  public var filter: EventStoreDB_Client_Messages_Filter {
    get {return _filter ?? EventStoreDB_Client_Messages_Filter()}
    set {_filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  public var hasFilter: Bool {return self._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  public mutating func clearFilter() {self._filter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _filter: EventStoreDB_Client_Messages_Filter? = nil
}

public struct EventStoreDB_Client_Messages_FilteredReadAllEventsCompleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var commitPosition: Int64 = 0

  public var preparePosition: Int64 = 0

  public var events: [EventStoreDB_Client_Messages_ResolvedEvent] = []

  public var nextCommitPosition: Int64 = 0

  public var nextPreparePosition: Int64 = 0

  public var isEndOfStream: Bool = false

  public var result: EventStoreDB_Client_Messages_FilteredReadAllEventsCompleted.FilteredReadAllResult = .success

  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum FilteredReadAllResult: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case success // = 0
    case notModified // = 1
    case error // = 2
    case accessDenied // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .success
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .success
      case 1: self = .notModified
      case 2: self = .error
      case 3: self = .accessDenied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .success: return 0
      case .notModified: return 1
      case .error: return 2
      case .accessDenied: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension EventStoreDB_Client_Messages_FilteredReadAllEventsCompleted.FilteredReadAllResult: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [EventStoreDB_Client_Messages_FilteredReadAllEventsCompleted.FilteredReadAllResult] = [
    .success,
    .notModified,
    .error,
    .accessDenied,
  ]
}

#endif  // swift(>=4.2)

public struct EventStoreDB_Client_Messages_CreatePersistentSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subscriptionGroupName: String = String()

  public var eventStreamID: String = String()

  public var resolveLinkTos: Bool = false

  public var startFrom: Int64 = 0

  public var messageTimeoutMilliseconds: Int32 = 0

  public var recordStatistics: Bool = false

  public var liveBufferSize: Int32 = 0

  public var readBatchSize: Int32 = 0

  public var bufferSize: Int32 = 0

  public var maxRetryCount: Int32 = 0

  public var preferRoundRobin: Bool = false

  public var checkpointAfterTime: Int32 = 0

  public var checkpointMaxCount: Int32 = 0

  public var checkpointMinCount: Int32 = 0

  public var subscriberMaxCount: Int32 = 0

  public var namedConsumerStrategy: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_DeletePersistentSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subscriptionGroupName: String = String()

  public var eventStreamID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_UpdatePersistentSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subscriptionGroupName: String = String()

  public var eventStreamID: String = String()

  public var resolveLinkTos: Bool = false

  public var startFrom: Int64 = 0

  public var messageTimeoutMilliseconds: Int32 = 0

  public var recordStatistics: Bool = false

  public var liveBufferSize: Int32 = 0

  public var readBatchSize: Int32 = 0

  public var bufferSize: Int32 = 0

  public var maxRetryCount: Int32 = 0

  public var preferRoundRobin: Bool = false

  public var checkpointAfterTime: Int32 = 0

  public var checkpointMaxCount: Int32 = 0

  public var checkpointMinCount: Int32 = 0

  public var subscriberMaxCount: Int32 = 0

  public var namedConsumerStrategy: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_UpdatePersistentSubscriptionCompleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: EventStoreDB_Client_Messages_UpdatePersistentSubscriptionCompleted.UpdatePersistentSubscriptionResult = .success

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum UpdatePersistentSubscriptionResult: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case success // = 0
    case doesNotExist // = 1
    case fail // = 2
    case accessDenied // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .success
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .success
      case 1: self = .doesNotExist
      case 2: self = .fail
      case 3: self = .accessDenied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .success: return 0
      case .doesNotExist: return 1
      case .fail: return 2
      case .accessDenied: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension EventStoreDB_Client_Messages_UpdatePersistentSubscriptionCompleted.UpdatePersistentSubscriptionResult: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [EventStoreDB_Client_Messages_UpdatePersistentSubscriptionCompleted.UpdatePersistentSubscriptionResult] = [
    .success,
    .doesNotExist,
    .fail,
    .accessDenied,
  ]
}

#endif  // swift(>=4.2)

public struct EventStoreDB_Client_Messages_CreatePersistentSubscriptionCompleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: EventStoreDB_Client_Messages_CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult = .success

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum CreatePersistentSubscriptionResult: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case success // = 0
    case alreadyExists // = 1
    case fail // = 2
    case accessDenied // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .success
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .success
      case 1: self = .alreadyExists
      case 2: self = .fail
      case 3: self = .accessDenied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .success: return 0
      case .alreadyExists: return 1
      case .fail: return 2
      case .accessDenied: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension EventStoreDB_Client_Messages_CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [EventStoreDB_Client_Messages_CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult] = [
    .success,
    .alreadyExists,
    .fail,
    .accessDenied,
  ]
}

#endif  // swift(>=4.2)

public struct EventStoreDB_Client_Messages_DeletePersistentSubscriptionCompleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: EventStoreDB_Client_Messages_DeletePersistentSubscriptionCompleted.DeletePersistentSubscriptionResult = .success

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum DeletePersistentSubscriptionResult: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case success // = 0
    case doesNotExist // = 1
    case fail // = 2
    case accessDenied // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .success
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .success
      case 1: self = .doesNotExist
      case 2: self = .fail
      case 3: self = .accessDenied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .success: return 0
      case .doesNotExist: return 1
      case .fail: return 2
      case .accessDenied: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension EventStoreDB_Client_Messages_DeletePersistentSubscriptionCompleted.DeletePersistentSubscriptionResult: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [EventStoreDB_Client_Messages_DeletePersistentSubscriptionCompleted.DeletePersistentSubscriptionResult] = [
    .success,
    .doesNotExist,
    .fail,
    .accessDenied,
  ]
}

#endif  // swift(>=4.2)

public struct EventStoreDB_Client_Messages_ConnectToPersistentSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subscriptionID: String = String()

  public var eventStreamID: String = String()

  public var allowedInFlightMessages: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_PersistentSubscriptionAckEvents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subscriptionID: String = String()

  public var processedEventIds: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_PersistentSubscriptionNakEvents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subscriptionID: String = String()

  public var processedEventIds: [Data] = []

  public var message: String = String()

  public var action: EventStoreDB_Client_Messages_PersistentSubscriptionNakEvents.NakAction = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum NakAction: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case park // = 1
    case retry // = 2
    case skip // = 3
    case stop // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .park
      case 2: self = .retry
      case 3: self = .skip
      case 4: self = .stop
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .park: return 1
      case .retry: return 2
      case .skip: return 3
      case .stop: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension EventStoreDB_Client_Messages_PersistentSubscriptionNakEvents.NakAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [EventStoreDB_Client_Messages_PersistentSubscriptionNakEvents.NakAction] = [
    .unknown,
    .park,
    .retry,
    .skip,
    .stop,
  ]
}

#endif  // swift(>=4.2)

public struct EventStoreDB_Client_Messages_PersistentSubscriptionConfirmation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lastCommitPosition: Int64 = 0

  public var subscriptionID: String = String()

  public var lastEventNumber: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_PersistentSubscriptionStreamEventAppeared {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var event: EventStoreDB_Client_Messages_ResolvedIndexedEvent {
    get {return _event ?? EventStoreDB_Client_Messages_ResolvedIndexedEvent()}
    set {_event = newValue}
  }
  /// Returns true if `event` has been explicitly set.
  public var hasEvent: Bool {return self._event != nil}
  /// Clears the value of `event`. Subsequent reads from it will return its default value.
  public mutating func clearEvent() {self._event = nil}

  public var retryCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _event: EventStoreDB_Client_Messages_ResolvedIndexedEvent? = nil
}

public struct EventStoreDB_Client_Messages_SubscribeToStream {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventStreamID: String = String()

  public var resolveLinkTos: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_FilteredSubscribeToStream {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventStreamID: String = String()

  public var resolveLinkTos: Bool = false

  public var filter: EventStoreDB_Client_Messages_Filter {
    get {return _filter ?? EventStoreDB_Client_Messages_Filter()}
    set {_filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  public var hasFilter: Bool {return self._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  public mutating func clearFilter() {self._filter = nil}

  public var checkpointInterval: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _filter: EventStoreDB_Client_Messages_Filter? = nil
}

public struct EventStoreDB_Client_Messages_CheckpointReached {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var commitPosition: Int64 = 0

  public var preparePosition: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_SubscriptionConfirmation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lastCommitPosition: Int64 = 0

  public var lastEventNumber: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_StreamEventAppeared {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var event: EventStoreDB_Client_Messages_ResolvedEvent {
    get {return _event ?? EventStoreDB_Client_Messages_ResolvedEvent()}
    set {_event = newValue}
  }
  /// Returns true if `event` has been explicitly set.
  public var hasEvent: Bool {return self._event != nil}
  /// Clears the value of `event`. Subsequent reads from it will return its default value.
  public mutating func clearEvent() {self._event = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _event: EventStoreDB_Client_Messages_ResolvedEvent? = nil
}

public struct EventStoreDB_Client_Messages_UnsubscribeFromStream {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_SubscriptionDropped {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reason: EventStoreDB_Client_Messages_SubscriptionDropped.SubscriptionDropReason = .unsubscribed

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum SubscriptionDropReason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unsubscribed // = 0
    case accessDenied // = 1
    case notFound // = 2
    case persistentSubscriptionDeleted // = 3
    case subscriberMaxCountReached // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unsubscribed
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unsubscribed
      case 1: self = .accessDenied
      case 2: self = .notFound
      case 3: self = .persistentSubscriptionDeleted
      case 4: self = .subscriberMaxCountReached
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unsubscribed: return 0
      case .accessDenied: return 1
      case .notFound: return 2
      case .persistentSubscriptionDeleted: return 3
      case .subscriberMaxCountReached: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension EventStoreDB_Client_Messages_SubscriptionDropped.SubscriptionDropReason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [EventStoreDB_Client_Messages_SubscriptionDropped.SubscriptionDropReason] = [
    .unsubscribed,
    .accessDenied,
    .notFound,
    .persistentSubscriptionDeleted,
    .subscriberMaxCountReached,
  ]
}

#endif  // swift(>=4.2)

public struct EventStoreDB_Client_Messages_NotHandled {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reason: EventStoreDB_Client_Messages_NotHandled.NotHandledReason = .notReady

  public var additionalInfo: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum NotHandledReason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case notReady // = 0
    case tooBusy // = 1
    case notLeader // = 2
    case isReadOnly // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .notReady
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notReady
      case 1: self = .tooBusy
      case 2: self = .notLeader
      case 3: self = .isReadOnly
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .notReady: return 0
      case .tooBusy: return 1
      case .notLeader: return 2
      case .isReadOnly: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct LeaderInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var externalTcpAddress: String = String()

    public var externalTcpPort: Int32 = 0

    public var httpAddress: String = String()

    public var httpPort: Int32 = 0

    public var externalSecureTcpAddress: String = String()

    public var externalSecureTcpPort: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension EventStoreDB_Client_Messages_NotHandled.NotHandledReason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [EventStoreDB_Client_Messages_NotHandled.NotHandledReason] = [
    .notReady,
    .tooBusy,
    .notLeader,
    .isReadOnly,
  ]
}

#endif  // swift(>=4.2)

public struct EventStoreDB_Client_Messages_ScavengeDatabase {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_ScavengeDatabaseResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: EventStoreDB_Client_Messages_ScavengeDatabaseResponse.ScavengeResult = .started

  public var scavengeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ScavengeResult: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case started // = 0
    case inProgress // = 1
    case unauthorized // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .started
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .started
      case 1: self = .inProgress
      case 2: self = .unauthorized
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .started: return 0
      case .inProgress: return 1
      case .unauthorized: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension EventStoreDB_Client_Messages_ScavengeDatabaseResponse.ScavengeResult: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [EventStoreDB_Client_Messages_ScavengeDatabaseResponse.ScavengeResult] = [
    .started,
    .inProgress,
    .unauthorized,
  ]
}

#endif  // swift(>=4.2)

public struct EventStoreDB_Client_Messages_IdentifyClient {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: Int32 = 0

  public var connectionName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStoreDB_Client_Messages_ClientIdentified {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension EventStoreDB_Client_Messages_OperationResult: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_NewEvent: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_EventRecord: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_ResolvedIndexedEvent: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_ResolvedEvent: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_WriteEvents: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_WriteEventsCompleted: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_DeleteStream: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_DeleteStreamCompleted: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_TransactionStart: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_TransactionStartCompleted: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_TransactionWrite: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_TransactionWriteCompleted: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_TransactionCommit: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_TransactionCommitCompleted: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_ReadEvent: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_ReadEventCompleted: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_ReadEventCompleted.ReadEventResult: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_ReadStreamEvents: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_ReadStreamEventsCompleted: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_ReadStreamEventsCompleted.ReadStreamResult: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_ReadAllEvents: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_ReadAllEventsCompleted: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_ReadAllEventsCompleted.ReadAllResult: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_Filter: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_Filter.FilterContext: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_Filter.FilterType: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_FilteredReadAllEvents: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_FilteredReadAllEventsCompleted: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_FilteredReadAllEventsCompleted.FilteredReadAllResult: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_CreatePersistentSubscription: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_DeletePersistentSubscription: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_UpdatePersistentSubscription: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_UpdatePersistentSubscriptionCompleted: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_UpdatePersistentSubscriptionCompleted.UpdatePersistentSubscriptionResult: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_CreatePersistentSubscriptionCompleted: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_DeletePersistentSubscriptionCompleted: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_DeletePersistentSubscriptionCompleted.DeletePersistentSubscriptionResult: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_ConnectToPersistentSubscription: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_PersistentSubscriptionAckEvents: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_PersistentSubscriptionNakEvents: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_PersistentSubscriptionNakEvents.NakAction: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_PersistentSubscriptionConfirmation: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_PersistentSubscriptionStreamEventAppeared: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_SubscribeToStream: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_FilteredSubscribeToStream: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_CheckpointReached: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_SubscriptionConfirmation: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_StreamEventAppeared: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_UnsubscribeFromStream: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_SubscriptionDropped: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_SubscriptionDropped.SubscriptionDropReason: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_NotHandled: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_NotHandled.NotHandledReason: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_NotHandled.LeaderInfo: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_ScavengeDatabase: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_ScavengeDatabaseResponse: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_ScavengeDatabaseResponse.ScavengeResult: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_IdentifyClient: @unchecked Sendable {}
extension EventStoreDB_Client_Messages_ClientIdentified: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "EventStoreDB.Client.Messages"

extension EventStoreDB_Client_Messages_OperationResult: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Success"),
    1: .same(proto: "PrepareTimeout"),
    2: .same(proto: "CommitTimeout"),
    3: .same(proto: "ForwardTimeout"),
    4: .same(proto: "WrongExpectedVersion"),
    5: .same(proto: "StreamDeleted"),
    6: .same(proto: "InvalidTransaction"),
    7: .same(proto: "AccessDenied"),
  ]
}

extension EventStoreDB_Client_Messages_NewEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NewEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_id"),
    2: .standard(proto: "event_type"),
    3: .standard(proto: "data_content_type"),
    4: .standard(proto: "metadata_content_type"),
    5: .same(proto: "data"),
    6: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.eventID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventType) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.dataContentType) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.metadataContentType) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitSingularBytesField(value: self.eventID, fieldNumber: 1)
    }
    if !self.eventType.isEmpty {
      try visitor.visitSingularStringField(value: self.eventType, fieldNumber: 2)
    }
    if self.dataContentType != 0 {
      try visitor.visitSingularInt32Field(value: self.dataContentType, fieldNumber: 3)
    }
    if self.metadataContentType != 0 {
      try visitor.visitSingularInt32Field(value: self.metadataContentType, fieldNumber: 4)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 5)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.metadata, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_NewEvent, rhs: EventStoreDB_Client_Messages_NewEvent) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.eventType != rhs.eventType {return false}
    if lhs.dataContentType != rhs.dataContentType {return false}
    if lhs.metadataContentType != rhs.metadataContentType {return false}
    if lhs.data != rhs.data {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_EventRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventRecord"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_stream_id"),
    2: .standard(proto: "event_number"),
    3: .standard(proto: "event_id"),
    4: .standard(proto: "event_type"),
    5: .standard(proto: "data_content_type"),
    6: .standard(proto: "metadata_content_type"),
    7: .same(proto: "data"),
    8: .same(proto: "metadata"),
    9: .same(proto: "created"),
    10: .standard(proto: "created_epoch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventStreamID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.eventNumber) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.eventID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.eventType) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.dataContentType) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.metadataContentType) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.metadata) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.created) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.createdEpoch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventStreamID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventStreamID, fieldNumber: 1)
    }
    if self.eventNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.eventNumber, fieldNumber: 2)
    }
    if !self.eventID.isEmpty {
      try visitor.visitSingularBytesField(value: self.eventID, fieldNumber: 3)
    }
    if !self.eventType.isEmpty {
      try visitor.visitSingularStringField(value: self.eventType, fieldNumber: 4)
    }
    if self.dataContentType != 0 {
      try visitor.visitSingularInt32Field(value: self.dataContentType, fieldNumber: 5)
    }
    if self.metadataContentType != 0 {
      try visitor.visitSingularInt32Field(value: self.metadataContentType, fieldNumber: 6)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 7)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.metadata, fieldNumber: 8)
    }
    if self.created != 0 {
      try visitor.visitSingularInt64Field(value: self.created, fieldNumber: 9)
    }
    if self.createdEpoch != 0 {
      try visitor.visitSingularInt64Field(value: self.createdEpoch, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_EventRecord, rhs: EventStoreDB_Client_Messages_EventRecord) -> Bool {
    if lhs.eventStreamID != rhs.eventStreamID {return false}
    if lhs.eventNumber != rhs.eventNumber {return false}
    if lhs.eventID != rhs.eventID {return false}
    if lhs.eventType != rhs.eventType {return false}
    if lhs.dataContentType != rhs.dataContentType {return false}
    if lhs.metadataContentType != rhs.metadataContentType {return false}
    if lhs.data != rhs.data {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.created != rhs.created {return false}
    if lhs.createdEpoch != rhs.createdEpoch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_ResolvedIndexedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResolvedIndexedEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "event"),
    2: .same(proto: "link"),
  ]

  fileprivate class _StorageClass {
    var _event: EventStoreDB_Client_Messages_EventRecord? = nil
    var _link: EventStoreDB_Client_Messages_EventRecord? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _event = source._event
      _link = source._link
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._event) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._link) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._event {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._link {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_ResolvedIndexedEvent, rhs: EventStoreDB_Client_Messages_ResolvedIndexedEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._event != rhs_storage._event {return false}
        if _storage._link != rhs_storage._link {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_ResolvedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResolvedEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "event"),
    2: .same(proto: "link"),
    3: .standard(proto: "commit_position"),
    4: .standard(proto: "prepare_position"),
  ]

  fileprivate class _StorageClass {
    var _event: EventStoreDB_Client_Messages_EventRecord? = nil
    var _link: EventStoreDB_Client_Messages_EventRecord? = nil
    var _commitPosition: Int64 = 0
    var _preparePosition: Int64 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _event = source._event
      _link = source._link
      _commitPosition = source._commitPosition
      _preparePosition = source._preparePosition
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._event) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._link) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._commitPosition) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._preparePosition) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._event {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._link {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._commitPosition != 0 {
        try visitor.visitSingularInt64Field(value: _storage._commitPosition, fieldNumber: 3)
      }
      if _storage._preparePosition != 0 {
        try visitor.visitSingularInt64Field(value: _storage._preparePosition, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_ResolvedEvent, rhs: EventStoreDB_Client_Messages_ResolvedEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._event != rhs_storage._event {return false}
        if _storage._link != rhs_storage._link {return false}
        if _storage._commitPosition != rhs_storage._commitPosition {return false}
        if _storage._preparePosition != rhs_storage._preparePosition {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_WriteEvents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WriteEvents"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_stream_id"),
    2: .standard(proto: "expected_version"),
    3: .same(proto: "events"),
    4: .standard(proto: "require_leader"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventStreamID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.expectedVersion) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.requireLeader) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventStreamID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventStreamID, fieldNumber: 1)
    }
    if self.expectedVersion != 0 {
      try visitor.visitSingularInt64Field(value: self.expectedVersion, fieldNumber: 2)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 3)
    }
    if self.requireLeader != false {
      try visitor.visitSingularBoolField(value: self.requireLeader, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_WriteEvents, rhs: EventStoreDB_Client_Messages_WriteEvents) -> Bool {
    if lhs.eventStreamID != rhs.eventStreamID {return false}
    if lhs.expectedVersion != rhs.expectedVersion {return false}
    if lhs.events != rhs.events {return false}
    if lhs.requireLeader != rhs.requireLeader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_WriteEventsCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WriteEventsCompleted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "message"),
    3: .standard(proto: "first_event_number"),
    4: .standard(proto: "last_event_number"),
    5: .standard(proto: "prepare_position"),
    6: .standard(proto: "commit_position"),
    7: .standard(proto: "current_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.firstEventNumber) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.lastEventNumber) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.preparePosition) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.commitPosition) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.currentVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .success {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.firstEventNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.firstEventNumber, fieldNumber: 3)
    }
    if self.lastEventNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.lastEventNumber, fieldNumber: 4)
    }
    if self.preparePosition != 0 {
      try visitor.visitSingularInt64Field(value: self.preparePosition, fieldNumber: 5)
    }
    if self.commitPosition != 0 {
      try visitor.visitSingularInt64Field(value: self.commitPosition, fieldNumber: 6)
    }
    if self.currentVersion != 0 {
      try visitor.visitSingularInt64Field(value: self.currentVersion, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_WriteEventsCompleted, rhs: EventStoreDB_Client_Messages_WriteEventsCompleted) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.message != rhs.message {return false}
    if lhs.firstEventNumber != rhs.firstEventNumber {return false}
    if lhs.lastEventNumber != rhs.lastEventNumber {return false}
    if lhs.preparePosition != rhs.preparePosition {return false}
    if lhs.commitPosition != rhs.commitPosition {return false}
    if lhs.currentVersion != rhs.currentVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_DeleteStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteStream"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_stream_id"),
    2: .standard(proto: "expected_version"),
    3: .standard(proto: "require_leader"),
    4: .standard(proto: "hard_delete"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventStreamID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.expectedVersion) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.requireLeader) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.hardDelete) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventStreamID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventStreamID, fieldNumber: 1)
    }
    if self.expectedVersion != 0 {
      try visitor.visitSingularInt64Field(value: self.expectedVersion, fieldNumber: 2)
    }
    if self.requireLeader != false {
      try visitor.visitSingularBoolField(value: self.requireLeader, fieldNumber: 3)
    }
    if self.hardDelete != false {
      try visitor.visitSingularBoolField(value: self.hardDelete, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_DeleteStream, rhs: EventStoreDB_Client_Messages_DeleteStream) -> Bool {
    if lhs.eventStreamID != rhs.eventStreamID {return false}
    if lhs.expectedVersion != rhs.expectedVersion {return false}
    if lhs.requireLeader != rhs.requireLeader {return false}
    if lhs.hardDelete != rhs.hardDelete {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_DeleteStreamCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteStreamCompleted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "message"),
    3: .standard(proto: "prepare_position"),
    4: .standard(proto: "commit_position"),
    5: .standard(proto: "current_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.preparePosition) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.commitPosition) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.currentVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .success {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.preparePosition != 0 {
      try visitor.visitSingularInt64Field(value: self.preparePosition, fieldNumber: 3)
    }
    if self.commitPosition != 0 {
      try visitor.visitSingularInt64Field(value: self.commitPosition, fieldNumber: 4)
    }
    if self.currentVersion != 0 {
      try visitor.visitSingularInt64Field(value: self.currentVersion, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_DeleteStreamCompleted, rhs: EventStoreDB_Client_Messages_DeleteStreamCompleted) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.message != rhs.message {return false}
    if lhs.preparePosition != rhs.preparePosition {return false}
    if lhs.commitPosition != rhs.commitPosition {return false}
    if lhs.currentVersion != rhs.currentVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_TransactionStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionStart"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_stream_id"),
    2: .standard(proto: "expected_version"),
    3: .standard(proto: "require_leader"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventStreamID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.expectedVersion) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.requireLeader) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventStreamID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventStreamID, fieldNumber: 1)
    }
    if self.expectedVersion != 0 {
      try visitor.visitSingularInt64Field(value: self.expectedVersion, fieldNumber: 2)
    }
    if self.requireLeader != false {
      try visitor.visitSingularBoolField(value: self.requireLeader, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_TransactionStart, rhs: EventStoreDB_Client_Messages_TransactionStart) -> Bool {
    if lhs.eventStreamID != rhs.eventStreamID {return false}
    if lhs.expectedVersion != rhs.expectedVersion {return false}
    if lhs.requireLeader != rhs.requireLeader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_TransactionStartCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionStartCompleted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_id"),
    2: .same(proto: "result"),
    3: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.transactionID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.transactionID != 0 {
      try visitor.visitSingularInt64Field(value: self.transactionID, fieldNumber: 1)
    }
    if self.result != .success {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_TransactionStartCompleted, rhs: EventStoreDB_Client_Messages_TransactionStartCompleted) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.result != rhs.result {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_TransactionWrite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionWrite"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_id"),
    2: .same(proto: "events"),
    3: .standard(proto: "require_leader"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.transactionID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.requireLeader) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.transactionID != 0 {
      try visitor.visitSingularInt64Field(value: self.transactionID, fieldNumber: 1)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 2)
    }
    if self.requireLeader != false {
      try visitor.visitSingularBoolField(value: self.requireLeader, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_TransactionWrite, rhs: EventStoreDB_Client_Messages_TransactionWrite) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.events != rhs.events {return false}
    if lhs.requireLeader != rhs.requireLeader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_TransactionWriteCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionWriteCompleted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_id"),
    2: .same(proto: "result"),
    3: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.transactionID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.transactionID != 0 {
      try visitor.visitSingularInt64Field(value: self.transactionID, fieldNumber: 1)
    }
    if self.result != .success {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_TransactionWriteCompleted, rhs: EventStoreDB_Client_Messages_TransactionWriteCompleted) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.result != rhs.result {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_TransactionCommit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionCommit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_id"),
    2: .standard(proto: "require_leader"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.transactionID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.requireLeader) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.transactionID != 0 {
      try visitor.visitSingularInt64Field(value: self.transactionID, fieldNumber: 1)
    }
    if self.requireLeader != false {
      try visitor.visitSingularBoolField(value: self.requireLeader, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_TransactionCommit, rhs: EventStoreDB_Client_Messages_TransactionCommit) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.requireLeader != rhs.requireLeader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_TransactionCommitCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionCommitCompleted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_id"),
    2: .same(proto: "result"),
    3: .same(proto: "message"),
    4: .standard(proto: "first_event_number"),
    5: .standard(proto: "last_event_number"),
    6: .standard(proto: "prepare_position"),
    7: .standard(proto: "commit_position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.transactionID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.firstEventNumber) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.lastEventNumber) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.preparePosition) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.commitPosition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.transactionID != 0 {
      try visitor.visitSingularInt64Field(value: self.transactionID, fieldNumber: 1)
    }
    if self.result != .success {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    if self.firstEventNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.firstEventNumber, fieldNumber: 4)
    }
    if self.lastEventNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.lastEventNumber, fieldNumber: 5)
    }
    if self.preparePosition != 0 {
      try visitor.visitSingularInt64Field(value: self.preparePosition, fieldNumber: 6)
    }
    if self.commitPosition != 0 {
      try visitor.visitSingularInt64Field(value: self.commitPosition, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_TransactionCommitCompleted, rhs: EventStoreDB_Client_Messages_TransactionCommitCompleted) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.result != rhs.result {return false}
    if lhs.message != rhs.message {return false}
    if lhs.firstEventNumber != rhs.firstEventNumber {return false}
    if lhs.lastEventNumber != rhs.lastEventNumber {return false}
    if lhs.preparePosition != rhs.preparePosition {return false}
    if lhs.commitPosition != rhs.commitPosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_ReadEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_stream_id"),
    2: .standard(proto: "event_number"),
    3: .standard(proto: "resolve_link_tos"),
    4: .standard(proto: "require_leader"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventStreamID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.eventNumber) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.resolveLinkTos) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.requireLeader) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventStreamID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventStreamID, fieldNumber: 1)
    }
    if self.eventNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.eventNumber, fieldNumber: 2)
    }
    if self.resolveLinkTos != false {
      try visitor.visitSingularBoolField(value: self.resolveLinkTos, fieldNumber: 3)
    }
    if self.requireLeader != false {
      try visitor.visitSingularBoolField(value: self.requireLeader, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_ReadEvent, rhs: EventStoreDB_Client_Messages_ReadEvent) -> Bool {
    if lhs.eventStreamID != rhs.eventStreamID {return false}
    if lhs.eventNumber != rhs.eventNumber {return false}
    if lhs.resolveLinkTos != rhs.resolveLinkTos {return false}
    if lhs.requireLeader != rhs.requireLeader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_ReadEventCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadEventCompleted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "event"),
    3: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .success {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_ReadEventCompleted, rhs: EventStoreDB_Client_Messages_ReadEventCompleted) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._event != rhs._event {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_ReadEventCompleted.ReadEventResult: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Success"),
    1: .same(proto: "NotFound"),
    2: .same(proto: "NoStream"),
    3: .same(proto: "StreamDeleted"),
    4: .same(proto: "Error"),
    5: .same(proto: "AccessDenied"),
  ]
}

extension EventStoreDB_Client_Messages_ReadStreamEvents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadStreamEvents"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_stream_id"),
    2: .standard(proto: "from_event_number"),
    3: .standard(proto: "max_count"),
    4: .standard(proto: "resolve_link_tos"),
    5: .standard(proto: "require_leader"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventStreamID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.fromEventNumber) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxCount) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.resolveLinkTos) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.requireLeader) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventStreamID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventStreamID, fieldNumber: 1)
    }
    if self.fromEventNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.fromEventNumber, fieldNumber: 2)
    }
    if self.maxCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxCount, fieldNumber: 3)
    }
    if self.resolveLinkTos != false {
      try visitor.visitSingularBoolField(value: self.resolveLinkTos, fieldNumber: 4)
    }
    if self.requireLeader != false {
      try visitor.visitSingularBoolField(value: self.requireLeader, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_ReadStreamEvents, rhs: EventStoreDB_Client_Messages_ReadStreamEvents) -> Bool {
    if lhs.eventStreamID != rhs.eventStreamID {return false}
    if lhs.fromEventNumber != rhs.fromEventNumber {return false}
    if lhs.maxCount != rhs.maxCount {return false}
    if lhs.resolveLinkTos != rhs.resolveLinkTos {return false}
    if lhs.requireLeader != rhs.requireLeader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_ReadStreamEventsCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadStreamEventsCompleted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
    2: .same(proto: "result"),
    3: .standard(proto: "next_event_number"),
    4: .standard(proto: "last_event_number"),
    5: .standard(proto: "is_end_of_stream"),
    6: .standard(proto: "last_commit_position"),
    7: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.nextEventNumber) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.lastEventNumber) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isEndOfStream) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.lastCommitPosition) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    if self.result != .success {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 2)
    }
    if self.nextEventNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.nextEventNumber, fieldNumber: 3)
    }
    if self.lastEventNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.lastEventNumber, fieldNumber: 4)
    }
    if self.isEndOfStream != false {
      try visitor.visitSingularBoolField(value: self.isEndOfStream, fieldNumber: 5)
    }
    if self.lastCommitPosition != 0 {
      try visitor.visitSingularInt64Field(value: self.lastCommitPosition, fieldNumber: 6)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_ReadStreamEventsCompleted, rhs: EventStoreDB_Client_Messages_ReadStreamEventsCompleted) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.result != rhs.result {return false}
    if lhs.nextEventNumber != rhs.nextEventNumber {return false}
    if lhs.lastEventNumber != rhs.lastEventNumber {return false}
    if lhs.isEndOfStream != rhs.isEndOfStream {return false}
    if lhs.lastCommitPosition != rhs.lastCommitPosition {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_ReadStreamEventsCompleted.ReadStreamResult: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Success"),
    1: .same(proto: "NoStream"),
    2: .same(proto: "StreamDeleted"),
    3: .same(proto: "NotModified"),
    4: .same(proto: "Error"),
    5: .same(proto: "AccessDenied"),
  ]
}

extension EventStoreDB_Client_Messages_ReadAllEvents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadAllEvents"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "commit_position"),
    2: .standard(proto: "prepare_position"),
    3: .standard(proto: "max_count"),
    4: .standard(proto: "resolve_link_tos"),
    5: .standard(proto: "require_leader"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.commitPosition) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.preparePosition) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxCount) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.resolveLinkTos) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.requireLeader) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commitPosition != 0 {
      try visitor.visitSingularInt64Field(value: self.commitPosition, fieldNumber: 1)
    }
    if self.preparePosition != 0 {
      try visitor.visitSingularInt64Field(value: self.preparePosition, fieldNumber: 2)
    }
    if self.maxCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxCount, fieldNumber: 3)
    }
    if self.resolveLinkTos != false {
      try visitor.visitSingularBoolField(value: self.resolveLinkTos, fieldNumber: 4)
    }
    if self.requireLeader != false {
      try visitor.visitSingularBoolField(value: self.requireLeader, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_ReadAllEvents, rhs: EventStoreDB_Client_Messages_ReadAllEvents) -> Bool {
    if lhs.commitPosition != rhs.commitPosition {return false}
    if lhs.preparePosition != rhs.preparePosition {return false}
    if lhs.maxCount != rhs.maxCount {return false}
    if lhs.resolveLinkTos != rhs.resolveLinkTos {return false}
    if lhs.requireLeader != rhs.requireLeader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_ReadAllEventsCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadAllEventsCompleted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "commit_position"),
    2: .standard(proto: "prepare_position"),
    3: .same(proto: "events"),
    4: .standard(proto: "next_commit_position"),
    5: .standard(proto: "next_prepare_position"),
    6: .same(proto: "result"),
    7: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.commitPosition) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.preparePosition) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.nextCommitPosition) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.nextPreparePosition) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commitPosition != 0 {
      try visitor.visitSingularInt64Field(value: self.commitPosition, fieldNumber: 1)
    }
    if self.preparePosition != 0 {
      try visitor.visitSingularInt64Field(value: self.preparePosition, fieldNumber: 2)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 3)
    }
    if self.nextCommitPosition != 0 {
      try visitor.visitSingularInt64Field(value: self.nextCommitPosition, fieldNumber: 4)
    }
    if self.nextPreparePosition != 0 {
      try visitor.visitSingularInt64Field(value: self.nextPreparePosition, fieldNumber: 5)
    }
    if self.result != .success {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 6)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_ReadAllEventsCompleted, rhs: EventStoreDB_Client_Messages_ReadAllEventsCompleted) -> Bool {
    if lhs.commitPosition != rhs.commitPosition {return false}
    if lhs.preparePosition != rhs.preparePosition {return false}
    if lhs.events != rhs.events {return false}
    if lhs.nextCommitPosition != rhs.nextCommitPosition {return false}
    if lhs.nextPreparePosition != rhs.nextPreparePosition {return false}
    if lhs.result != rhs.result {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_ReadAllEventsCompleted.ReadAllResult: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Success"),
    1: .same(proto: "NotModified"),
    2: .same(proto: "Error"),
    3: .same(proto: "AccessDenied"),
  ]
}

extension EventStoreDB_Client_Messages_Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Filter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .same(proto: "type"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.context) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.context != .streamID {
      try visitor.visitSingularEnumField(value: self.context, fieldNumber: 1)
    }
    if self.type != .regex {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedStringField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_Filter, rhs: EventStoreDB_Client_Messages_Filter) -> Bool {
    if lhs.context != rhs.context {return false}
    if lhs.type != rhs.type {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_Filter.FilterContext: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "StreamId"),
    1: .same(proto: "EventType"),
  ]
}

extension EventStoreDB_Client_Messages_Filter.FilterType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Regex"),
    1: .same(proto: "Prefix"),
  ]
}

extension EventStoreDB_Client_Messages_FilteredReadAllEvents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FilteredReadAllEvents"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "commit_position"),
    2: .standard(proto: "prepare_position"),
    3: .standard(proto: "max_count"),
    4: .standard(proto: "max_search_window"),
    5: .standard(proto: "resolve_link_tos"),
    6: .standard(proto: "require_leader"),
    7: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.commitPosition) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.preparePosition) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxCount) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.maxSearchWindow) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.resolveLinkTos) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.requireLeader) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.commitPosition != 0 {
      try visitor.visitSingularInt64Field(value: self.commitPosition, fieldNumber: 1)
    }
    if self.preparePosition != 0 {
      try visitor.visitSingularInt64Field(value: self.preparePosition, fieldNumber: 2)
    }
    if self.maxCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxCount, fieldNumber: 3)
    }
    if self.maxSearchWindow != 0 {
      try visitor.visitSingularInt32Field(value: self.maxSearchWindow, fieldNumber: 4)
    }
    if self.resolveLinkTos != false {
      try visitor.visitSingularBoolField(value: self.resolveLinkTos, fieldNumber: 5)
    }
    if self.requireLeader != false {
      try visitor.visitSingularBoolField(value: self.requireLeader, fieldNumber: 6)
    }
    try { if let v = self._filter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_FilteredReadAllEvents, rhs: EventStoreDB_Client_Messages_FilteredReadAllEvents) -> Bool {
    if lhs.commitPosition != rhs.commitPosition {return false}
    if lhs.preparePosition != rhs.preparePosition {return false}
    if lhs.maxCount != rhs.maxCount {return false}
    if lhs.maxSearchWindow != rhs.maxSearchWindow {return false}
    if lhs.resolveLinkTos != rhs.resolveLinkTos {return false}
    if lhs.requireLeader != rhs.requireLeader {return false}
    if lhs._filter != rhs._filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_FilteredReadAllEventsCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FilteredReadAllEventsCompleted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "commit_position"),
    2: .standard(proto: "prepare_position"),
    3: .same(proto: "events"),
    4: .standard(proto: "next_commit_position"),
    5: .standard(proto: "next_prepare_position"),
    6: .standard(proto: "is_end_of_stream"),
    7: .same(proto: "result"),
    8: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.commitPosition) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.preparePosition) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.nextCommitPosition) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.nextPreparePosition) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isEndOfStream) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commitPosition != 0 {
      try visitor.visitSingularInt64Field(value: self.commitPosition, fieldNumber: 1)
    }
    if self.preparePosition != 0 {
      try visitor.visitSingularInt64Field(value: self.preparePosition, fieldNumber: 2)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 3)
    }
    if self.nextCommitPosition != 0 {
      try visitor.visitSingularInt64Field(value: self.nextCommitPosition, fieldNumber: 4)
    }
    if self.nextPreparePosition != 0 {
      try visitor.visitSingularInt64Field(value: self.nextPreparePosition, fieldNumber: 5)
    }
    if self.isEndOfStream != false {
      try visitor.visitSingularBoolField(value: self.isEndOfStream, fieldNumber: 6)
    }
    if self.result != .success {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 7)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_FilteredReadAllEventsCompleted, rhs: EventStoreDB_Client_Messages_FilteredReadAllEventsCompleted) -> Bool {
    if lhs.commitPosition != rhs.commitPosition {return false}
    if lhs.preparePosition != rhs.preparePosition {return false}
    if lhs.events != rhs.events {return false}
    if lhs.nextCommitPosition != rhs.nextCommitPosition {return false}
    if lhs.nextPreparePosition != rhs.nextPreparePosition {return false}
    if lhs.isEndOfStream != rhs.isEndOfStream {return false}
    if lhs.result != rhs.result {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_FilteredReadAllEventsCompleted.FilteredReadAllResult: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Success"),
    1: .same(proto: "NotModified"),
    2: .same(proto: "Error"),
    3: .same(proto: "AccessDenied"),
  ]
}

extension EventStoreDB_Client_Messages_CreatePersistentSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreatePersistentSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_group_name"),
    2: .standard(proto: "event_stream_id"),
    3: .standard(proto: "resolve_link_tos"),
    4: .standard(proto: "start_from"),
    5: .standard(proto: "message_timeout_milliseconds"),
    6: .standard(proto: "record_statistics"),
    7: .standard(proto: "live_buffer_size"),
    8: .standard(proto: "read_batch_size"),
    9: .standard(proto: "buffer_size"),
    10: .standard(proto: "max_retry_count"),
    11: .standard(proto: "prefer_round_robin"),
    12: .standard(proto: "checkpoint_after_time"),
    13: .standard(proto: "checkpoint_max_count"),
    14: .standard(proto: "checkpoint_min_count"),
    15: .standard(proto: "subscriber_max_count"),
    16: .standard(proto: "named_consumer_strategy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscriptionGroupName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventStreamID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.resolveLinkTos) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.startFrom) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.messageTimeoutMilliseconds) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.recordStatistics) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.liveBufferSize) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.readBatchSize) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.bufferSize) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.maxRetryCount) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.preferRoundRobin) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.checkpointAfterTime) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.checkpointMaxCount) }()
      case 14: try { try decoder.decodeSingularInt32Field(value: &self.checkpointMinCount) }()
      case 15: try { try decoder.decodeSingularInt32Field(value: &self.subscriberMaxCount) }()
      case 16: try { try decoder.decodeSingularStringField(value: &self.namedConsumerStrategy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriptionGroupName.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionGroupName, fieldNumber: 1)
    }
    if !self.eventStreamID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventStreamID, fieldNumber: 2)
    }
    if self.resolveLinkTos != false {
      try visitor.visitSingularBoolField(value: self.resolveLinkTos, fieldNumber: 3)
    }
    if self.startFrom != 0 {
      try visitor.visitSingularInt64Field(value: self.startFrom, fieldNumber: 4)
    }
    if self.messageTimeoutMilliseconds != 0 {
      try visitor.visitSingularInt32Field(value: self.messageTimeoutMilliseconds, fieldNumber: 5)
    }
    if self.recordStatistics != false {
      try visitor.visitSingularBoolField(value: self.recordStatistics, fieldNumber: 6)
    }
    if self.liveBufferSize != 0 {
      try visitor.visitSingularInt32Field(value: self.liveBufferSize, fieldNumber: 7)
    }
    if self.readBatchSize != 0 {
      try visitor.visitSingularInt32Field(value: self.readBatchSize, fieldNumber: 8)
    }
    if self.bufferSize != 0 {
      try visitor.visitSingularInt32Field(value: self.bufferSize, fieldNumber: 9)
    }
    if self.maxRetryCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxRetryCount, fieldNumber: 10)
    }
    if self.preferRoundRobin != false {
      try visitor.visitSingularBoolField(value: self.preferRoundRobin, fieldNumber: 11)
    }
    if self.checkpointAfterTime != 0 {
      try visitor.visitSingularInt32Field(value: self.checkpointAfterTime, fieldNumber: 12)
    }
    if self.checkpointMaxCount != 0 {
      try visitor.visitSingularInt32Field(value: self.checkpointMaxCount, fieldNumber: 13)
    }
    if self.checkpointMinCount != 0 {
      try visitor.visitSingularInt32Field(value: self.checkpointMinCount, fieldNumber: 14)
    }
    if self.subscriberMaxCount != 0 {
      try visitor.visitSingularInt32Field(value: self.subscriberMaxCount, fieldNumber: 15)
    }
    if !self.namedConsumerStrategy.isEmpty {
      try visitor.visitSingularStringField(value: self.namedConsumerStrategy, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_CreatePersistentSubscription, rhs: EventStoreDB_Client_Messages_CreatePersistentSubscription) -> Bool {
    if lhs.subscriptionGroupName != rhs.subscriptionGroupName {return false}
    if lhs.eventStreamID != rhs.eventStreamID {return false}
    if lhs.resolveLinkTos != rhs.resolveLinkTos {return false}
    if lhs.startFrom != rhs.startFrom {return false}
    if lhs.messageTimeoutMilliseconds != rhs.messageTimeoutMilliseconds {return false}
    if lhs.recordStatistics != rhs.recordStatistics {return false}
    if lhs.liveBufferSize != rhs.liveBufferSize {return false}
    if lhs.readBatchSize != rhs.readBatchSize {return false}
    if lhs.bufferSize != rhs.bufferSize {return false}
    if lhs.maxRetryCount != rhs.maxRetryCount {return false}
    if lhs.preferRoundRobin != rhs.preferRoundRobin {return false}
    if lhs.checkpointAfterTime != rhs.checkpointAfterTime {return false}
    if lhs.checkpointMaxCount != rhs.checkpointMaxCount {return false}
    if lhs.checkpointMinCount != rhs.checkpointMinCount {return false}
    if lhs.subscriberMaxCount != rhs.subscriberMaxCount {return false}
    if lhs.namedConsumerStrategy != rhs.namedConsumerStrategy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_DeletePersistentSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletePersistentSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_group_name"),
    2: .standard(proto: "event_stream_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscriptionGroupName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventStreamID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriptionGroupName.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionGroupName, fieldNumber: 1)
    }
    if !self.eventStreamID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventStreamID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_DeletePersistentSubscription, rhs: EventStoreDB_Client_Messages_DeletePersistentSubscription) -> Bool {
    if lhs.subscriptionGroupName != rhs.subscriptionGroupName {return false}
    if lhs.eventStreamID != rhs.eventStreamID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_UpdatePersistentSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdatePersistentSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_group_name"),
    2: .standard(proto: "event_stream_id"),
    3: .standard(proto: "resolve_link_tos"),
    4: .standard(proto: "start_from"),
    5: .standard(proto: "message_timeout_milliseconds"),
    6: .standard(proto: "record_statistics"),
    7: .standard(proto: "live_buffer_size"),
    8: .standard(proto: "read_batch_size"),
    9: .standard(proto: "buffer_size"),
    10: .standard(proto: "max_retry_count"),
    11: .standard(proto: "prefer_round_robin"),
    12: .standard(proto: "checkpoint_after_time"),
    13: .standard(proto: "checkpoint_max_count"),
    14: .standard(proto: "checkpoint_min_count"),
    15: .standard(proto: "subscriber_max_count"),
    16: .standard(proto: "named_consumer_strategy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscriptionGroupName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventStreamID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.resolveLinkTos) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.startFrom) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.messageTimeoutMilliseconds) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.recordStatistics) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.liveBufferSize) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.readBatchSize) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.bufferSize) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.maxRetryCount) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.preferRoundRobin) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.checkpointAfterTime) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.checkpointMaxCount) }()
      case 14: try { try decoder.decodeSingularInt32Field(value: &self.checkpointMinCount) }()
      case 15: try { try decoder.decodeSingularInt32Field(value: &self.subscriberMaxCount) }()
      case 16: try { try decoder.decodeSingularStringField(value: &self.namedConsumerStrategy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriptionGroupName.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionGroupName, fieldNumber: 1)
    }
    if !self.eventStreamID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventStreamID, fieldNumber: 2)
    }
    if self.resolveLinkTos != false {
      try visitor.visitSingularBoolField(value: self.resolveLinkTos, fieldNumber: 3)
    }
    if self.startFrom != 0 {
      try visitor.visitSingularInt64Field(value: self.startFrom, fieldNumber: 4)
    }
    if self.messageTimeoutMilliseconds != 0 {
      try visitor.visitSingularInt32Field(value: self.messageTimeoutMilliseconds, fieldNumber: 5)
    }
    if self.recordStatistics != false {
      try visitor.visitSingularBoolField(value: self.recordStatistics, fieldNumber: 6)
    }
    if self.liveBufferSize != 0 {
      try visitor.visitSingularInt32Field(value: self.liveBufferSize, fieldNumber: 7)
    }
    if self.readBatchSize != 0 {
      try visitor.visitSingularInt32Field(value: self.readBatchSize, fieldNumber: 8)
    }
    if self.bufferSize != 0 {
      try visitor.visitSingularInt32Field(value: self.bufferSize, fieldNumber: 9)
    }
    if self.maxRetryCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxRetryCount, fieldNumber: 10)
    }
    if self.preferRoundRobin != false {
      try visitor.visitSingularBoolField(value: self.preferRoundRobin, fieldNumber: 11)
    }
    if self.checkpointAfterTime != 0 {
      try visitor.visitSingularInt32Field(value: self.checkpointAfterTime, fieldNumber: 12)
    }
    if self.checkpointMaxCount != 0 {
      try visitor.visitSingularInt32Field(value: self.checkpointMaxCount, fieldNumber: 13)
    }
    if self.checkpointMinCount != 0 {
      try visitor.visitSingularInt32Field(value: self.checkpointMinCount, fieldNumber: 14)
    }
    if self.subscriberMaxCount != 0 {
      try visitor.visitSingularInt32Field(value: self.subscriberMaxCount, fieldNumber: 15)
    }
    if !self.namedConsumerStrategy.isEmpty {
      try visitor.visitSingularStringField(value: self.namedConsumerStrategy, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_UpdatePersistentSubscription, rhs: EventStoreDB_Client_Messages_UpdatePersistentSubscription) -> Bool {
    if lhs.subscriptionGroupName != rhs.subscriptionGroupName {return false}
    if lhs.eventStreamID != rhs.eventStreamID {return false}
    if lhs.resolveLinkTos != rhs.resolveLinkTos {return false}
    if lhs.startFrom != rhs.startFrom {return false}
    if lhs.messageTimeoutMilliseconds != rhs.messageTimeoutMilliseconds {return false}
    if lhs.recordStatistics != rhs.recordStatistics {return false}
    if lhs.liveBufferSize != rhs.liveBufferSize {return false}
    if lhs.readBatchSize != rhs.readBatchSize {return false}
    if lhs.bufferSize != rhs.bufferSize {return false}
    if lhs.maxRetryCount != rhs.maxRetryCount {return false}
    if lhs.preferRoundRobin != rhs.preferRoundRobin {return false}
    if lhs.checkpointAfterTime != rhs.checkpointAfterTime {return false}
    if lhs.checkpointMaxCount != rhs.checkpointMaxCount {return false}
    if lhs.checkpointMinCount != rhs.checkpointMinCount {return false}
    if lhs.subscriberMaxCount != rhs.subscriberMaxCount {return false}
    if lhs.namedConsumerStrategy != rhs.namedConsumerStrategy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_UpdatePersistentSubscriptionCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdatePersistentSubscriptionCompleted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .success {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_UpdatePersistentSubscriptionCompleted, rhs: EventStoreDB_Client_Messages_UpdatePersistentSubscriptionCompleted) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_UpdatePersistentSubscriptionCompleted.UpdatePersistentSubscriptionResult: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Success"),
    1: .same(proto: "DoesNotExist"),
    2: .same(proto: "Fail"),
    3: .same(proto: "AccessDenied"),
  ]
}

extension EventStoreDB_Client_Messages_CreatePersistentSubscriptionCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreatePersistentSubscriptionCompleted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .success {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_CreatePersistentSubscriptionCompleted, rhs: EventStoreDB_Client_Messages_CreatePersistentSubscriptionCompleted) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Success"),
    1: .same(proto: "AlreadyExists"),
    2: .same(proto: "Fail"),
    3: .same(proto: "AccessDenied"),
  ]
}

extension EventStoreDB_Client_Messages_DeletePersistentSubscriptionCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletePersistentSubscriptionCompleted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .success {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_DeletePersistentSubscriptionCompleted, rhs: EventStoreDB_Client_Messages_DeletePersistentSubscriptionCompleted) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_DeletePersistentSubscriptionCompleted.DeletePersistentSubscriptionResult: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Success"),
    1: .same(proto: "DoesNotExist"),
    2: .same(proto: "Fail"),
    3: .same(proto: "AccessDenied"),
  ]
}

extension EventStoreDB_Client_Messages_ConnectToPersistentSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectToPersistentSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_id"),
    2: .standard(proto: "event_stream_id"),
    3: .standard(proto: "allowed_in_flight_messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscriptionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventStreamID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.allowedInFlightMessages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionID, fieldNumber: 1)
    }
    if !self.eventStreamID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventStreamID, fieldNumber: 2)
    }
    if self.allowedInFlightMessages != 0 {
      try visitor.visitSingularInt32Field(value: self.allowedInFlightMessages, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_ConnectToPersistentSubscription, rhs: EventStoreDB_Client_Messages_ConnectToPersistentSubscription) -> Bool {
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.eventStreamID != rhs.eventStreamID {return false}
    if lhs.allowedInFlightMessages != rhs.allowedInFlightMessages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_PersistentSubscriptionAckEvents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PersistentSubscriptionAckEvents"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_id"),
    2: .standard(proto: "processed_event_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscriptionID) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.processedEventIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionID, fieldNumber: 1)
    }
    if !self.processedEventIds.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.processedEventIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_PersistentSubscriptionAckEvents, rhs: EventStoreDB_Client_Messages_PersistentSubscriptionAckEvents) -> Bool {
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.processedEventIds != rhs.processedEventIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_PersistentSubscriptionNakEvents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PersistentSubscriptionNakEvents"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_id"),
    2: .standard(proto: "processed_event_ids"),
    3: .same(proto: "message"),
    4: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscriptionID) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.processedEventIds) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionID, fieldNumber: 1)
    }
    if !self.processedEventIds.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.processedEventIds, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    if self.action != .unknown {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_PersistentSubscriptionNakEvents, rhs: EventStoreDB_Client_Messages_PersistentSubscriptionNakEvents) -> Bool {
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.processedEventIds != rhs.processedEventIds {return false}
    if lhs.message != rhs.message {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_PersistentSubscriptionNakEvents.NakAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unknown"),
    1: .same(proto: "Park"),
    2: .same(proto: "Retry"),
    3: .same(proto: "Skip"),
    4: .same(proto: "Stop"),
  ]
}

extension EventStoreDB_Client_Messages_PersistentSubscriptionConfirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PersistentSubscriptionConfirmation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_commit_position"),
    2: .standard(proto: "subscription_id"),
    3: .standard(proto: "last_event_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.lastCommitPosition) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subscriptionID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.lastEventNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lastCommitPosition != 0 {
      try visitor.visitSingularInt64Field(value: self.lastCommitPosition, fieldNumber: 1)
    }
    if !self.subscriptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionID, fieldNumber: 2)
    }
    if self.lastEventNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.lastEventNumber, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_PersistentSubscriptionConfirmation, rhs: EventStoreDB_Client_Messages_PersistentSubscriptionConfirmation) -> Bool {
    if lhs.lastCommitPosition != rhs.lastCommitPosition {return false}
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.lastEventNumber != rhs.lastEventNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_PersistentSubscriptionStreamEventAppeared: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PersistentSubscriptionStreamEventAppeared"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "event"),
    2: .same(proto: "retryCount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.retryCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.retryCount != 0 {
      try visitor.visitSingularInt32Field(value: self.retryCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_PersistentSubscriptionStreamEventAppeared, rhs: EventStoreDB_Client_Messages_PersistentSubscriptionStreamEventAppeared) -> Bool {
    if lhs._event != rhs._event {return false}
    if lhs.retryCount != rhs.retryCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_SubscribeToStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeToStream"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_stream_id"),
    2: .standard(proto: "resolve_link_tos"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventStreamID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.resolveLinkTos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventStreamID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventStreamID, fieldNumber: 1)
    }
    if self.resolveLinkTos != false {
      try visitor.visitSingularBoolField(value: self.resolveLinkTos, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_SubscribeToStream, rhs: EventStoreDB_Client_Messages_SubscribeToStream) -> Bool {
    if lhs.eventStreamID != rhs.eventStreamID {return false}
    if lhs.resolveLinkTos != rhs.resolveLinkTos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_FilteredSubscribeToStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FilteredSubscribeToStream"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_stream_id"),
    2: .standard(proto: "resolve_link_tos"),
    3: .same(proto: "filter"),
    4: .standard(proto: "checkpoint_interval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventStreamID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.resolveLinkTos) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._filter) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.checkpointInterval) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.eventStreamID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventStreamID, fieldNumber: 1)
    }
    if self.resolveLinkTos != false {
      try visitor.visitSingularBoolField(value: self.resolveLinkTos, fieldNumber: 2)
    }
    try { if let v = self._filter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.checkpointInterval != 0 {
      try visitor.visitSingularInt32Field(value: self.checkpointInterval, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_FilteredSubscribeToStream, rhs: EventStoreDB_Client_Messages_FilteredSubscribeToStream) -> Bool {
    if lhs.eventStreamID != rhs.eventStreamID {return false}
    if lhs.resolveLinkTos != rhs.resolveLinkTos {return false}
    if lhs._filter != rhs._filter {return false}
    if lhs.checkpointInterval != rhs.checkpointInterval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_CheckpointReached: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckpointReached"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "commit_position"),
    2: .standard(proto: "prepare_position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.commitPosition) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.preparePosition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commitPosition != 0 {
      try visitor.visitSingularInt64Field(value: self.commitPosition, fieldNumber: 1)
    }
    if self.preparePosition != 0 {
      try visitor.visitSingularInt64Field(value: self.preparePosition, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_CheckpointReached, rhs: EventStoreDB_Client_Messages_CheckpointReached) -> Bool {
    if lhs.commitPosition != rhs.commitPosition {return false}
    if lhs.preparePosition != rhs.preparePosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_SubscriptionConfirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscriptionConfirmation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_commit_position"),
    2: .standard(proto: "last_event_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.lastCommitPosition) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.lastEventNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lastCommitPosition != 0 {
      try visitor.visitSingularInt64Field(value: self.lastCommitPosition, fieldNumber: 1)
    }
    if self.lastEventNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.lastEventNumber, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_SubscriptionConfirmation, rhs: EventStoreDB_Client_Messages_SubscriptionConfirmation) -> Bool {
    if lhs.lastCommitPosition != rhs.lastCommitPosition {return false}
    if lhs.lastEventNumber != rhs.lastEventNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_StreamEventAppeared: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamEventAppeared"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_StreamEventAppeared, rhs: EventStoreDB_Client_Messages_StreamEventAppeared) -> Bool {
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_UnsubscribeFromStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnsubscribeFromStream"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_UnsubscribeFromStream, rhs: EventStoreDB_Client_Messages_UnsubscribeFromStream) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_SubscriptionDropped: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscriptionDropped"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .unsubscribed {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_SubscriptionDropped, rhs: EventStoreDB_Client_Messages_SubscriptionDropped) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_SubscriptionDropped.SubscriptionDropReason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unsubscribed"),
    1: .same(proto: "AccessDenied"),
    2: .same(proto: "NotFound"),
    3: .same(proto: "PersistentSubscriptionDeleted"),
    4: .same(proto: "SubscriberMaxCountReached"),
  ]
}

extension EventStoreDB_Client_Messages_NotHandled: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotHandled"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
    2: .standard(proto: "additional_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.additionalInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .notReady {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    if !self.additionalInfo.isEmpty {
      try visitor.visitSingularBytesField(value: self.additionalInfo, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_NotHandled, rhs: EventStoreDB_Client_Messages_NotHandled) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.additionalInfo != rhs.additionalInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_NotHandled.NotHandledReason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NotReady"),
    1: .same(proto: "TooBusy"),
    2: .same(proto: "NotLeader"),
    3: .same(proto: "IsReadOnly"),
  ]
}

extension EventStoreDB_Client_Messages_NotHandled.LeaderInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStoreDB_Client_Messages_NotHandled.protoMessageName + ".LeaderInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "external_tcp_address"),
    2: .standard(proto: "external_tcp_port"),
    3: .standard(proto: "http_address"),
    4: .standard(proto: "http_port"),
    5: .standard(proto: "external_secure_tcp_address"),
    6: .standard(proto: "external_secure_tcp_port"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.externalTcpAddress) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.externalTcpPort) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.httpAddress) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.httpPort) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.externalSecureTcpAddress) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.externalSecureTcpPort) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.externalTcpAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.externalTcpAddress, fieldNumber: 1)
    }
    if self.externalTcpPort != 0 {
      try visitor.visitSingularInt32Field(value: self.externalTcpPort, fieldNumber: 2)
    }
    if !self.httpAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.httpAddress, fieldNumber: 3)
    }
    if self.httpPort != 0 {
      try visitor.visitSingularInt32Field(value: self.httpPort, fieldNumber: 4)
    }
    if !self.externalSecureTcpAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.externalSecureTcpAddress, fieldNumber: 5)
    }
    if self.externalSecureTcpPort != 0 {
      try visitor.visitSingularInt32Field(value: self.externalSecureTcpPort, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_NotHandled.LeaderInfo, rhs: EventStoreDB_Client_Messages_NotHandled.LeaderInfo) -> Bool {
    if lhs.externalTcpAddress != rhs.externalTcpAddress {return false}
    if lhs.externalTcpPort != rhs.externalTcpPort {return false}
    if lhs.httpAddress != rhs.httpAddress {return false}
    if lhs.httpPort != rhs.httpPort {return false}
    if lhs.externalSecureTcpAddress != rhs.externalSecureTcpAddress {return false}
    if lhs.externalSecureTcpPort != rhs.externalSecureTcpPort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_ScavengeDatabase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScavengeDatabase"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_ScavengeDatabase, rhs: EventStoreDB_Client_Messages_ScavengeDatabase) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_ScavengeDatabaseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScavengeDatabaseResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "scavengeId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scavengeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .started {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.scavengeID.isEmpty {
      try visitor.visitSingularStringField(value: self.scavengeID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_ScavengeDatabaseResponse, rhs: EventStoreDB_Client_Messages_ScavengeDatabaseResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.scavengeID != rhs.scavengeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_ScavengeDatabaseResponse.ScavengeResult: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Started"),
    1: .same(proto: "InProgress"),
    2: .same(proto: "Unauthorized"),
  ]
}

extension EventStoreDB_Client_Messages_IdentifyClient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdentifyClient"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "connection_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.connectionName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 1)
    }
    if !self.connectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_IdentifyClient, rhs: EventStoreDB_Client_Messages_IdentifyClient) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.connectionName != rhs.connectionName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStoreDB_Client_Messages_ClientIdentified: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientIdentified"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStoreDB_Client_Messages_ClientIdentified, rhs: EventStoreDB_Client_Messages_ClientIdentified) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
