// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protos/users.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

public struct EventStore_Client_Users_CreateReq {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var options: EventStore_Client_Users_CreateReq.Options {
        get { _options ?? EventStore_Client_Users_CreateReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    public var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    public mutating func clearOptions() { _options = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Options {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var loginName: String = .init()

        public var password: String = .init()

        public var fullName: String = .init()

        public var groups: [String] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public init() {}

    fileprivate var _options: EventStore_Client_Users_CreateReq.Options?
}

public struct EventStore_Client_Users_CreateResp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStore_Client_Users_UpdateReq {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var options: EventStore_Client_Users_UpdateReq.Options {
        get { _options ?? EventStore_Client_Users_UpdateReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    public var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    public mutating func clearOptions() { _options = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Options {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var loginName: String = .init()

        public var password: String = .init()

        public var fullName: String = .init()

        public var groups: [String] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public init() {}

    fileprivate var _options: EventStore_Client_Users_UpdateReq.Options?
}

public struct EventStore_Client_Users_UpdateResp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStore_Client_Users_DeleteReq {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var options: EventStore_Client_Users_DeleteReq.Options {
        get { _options ?? EventStore_Client_Users_DeleteReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    public var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    public mutating func clearOptions() { _options = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Options {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var loginName: String = .init()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public init() {}

    fileprivate var _options: EventStore_Client_Users_DeleteReq.Options?
}

public struct EventStore_Client_Users_DeleteResp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStore_Client_Users_EnableReq {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var options: EventStore_Client_Users_EnableReq.Options {
        get { _options ?? EventStore_Client_Users_EnableReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    public var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    public mutating func clearOptions() { _options = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Options {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var loginName: String = .init()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public init() {}

    fileprivate var _options: EventStore_Client_Users_EnableReq.Options?
}

public struct EventStore_Client_Users_EnableResp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStore_Client_Users_DisableReq {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var options: EventStore_Client_Users_DisableReq.Options {
        get { _options ?? EventStore_Client_Users_DisableReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    public var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    public mutating func clearOptions() { _options = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Options {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var loginName: String = .init()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public init() {}

    fileprivate var _options: EventStore_Client_Users_DisableReq.Options?
}

public struct EventStore_Client_Users_DisableResp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStore_Client_Users_DetailsReq {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var options: EventStore_Client_Users_DetailsReq.Options {
        get { _options ?? EventStore_Client_Users_DetailsReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    public var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    public mutating func clearOptions() { _options = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Options {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var loginName: String = .init()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public init() {}

    fileprivate var _options: EventStore_Client_Users_DetailsReq.Options?
}

public struct EventStore_Client_Users_DetailsResp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var userDetails: EventStore_Client_Users_DetailsResp.UserDetails {
        get { _userDetails ?? EventStore_Client_Users_DetailsResp.UserDetails() }
        set { _userDetails = newValue }
    }

    /// Returns true if `userDetails` has been explicitly set.
    public var hasUserDetails: Bool { _userDetails != nil }
    /// Clears the value of `userDetails`. Subsequent reads from it will return its default value.
    public mutating func clearUserDetails() { _userDetails = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct UserDetails {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var loginName: String = .init()

        public var fullName: String = .init()

        public var groups: [String] = []

        public var lastUpdated: EventStore_Client_Users_DetailsResp.UserDetails.DateTime {
            get { _lastUpdated ?? EventStore_Client_Users_DetailsResp.UserDetails.DateTime() }
            set { _lastUpdated = newValue }
        }

        /// Returns true if `lastUpdated` has been explicitly set.
        public var hasLastUpdated: Bool { _lastUpdated != nil }
        /// Clears the value of `lastUpdated`. Subsequent reads from it will return its default value.
        public mutating func clearLastUpdated() { _lastUpdated = nil }

        public var disabled: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct DateTime {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var ticksSinceEpoch: Int64 = 0

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}
        }

        public init() {}

        fileprivate var _lastUpdated: EventStore_Client_Users_DetailsResp.UserDetails.DateTime?
    }

    public init() {}

    private var _userDetails: EventStore_Client_Users_DetailsResp.UserDetails?
}

public struct EventStore_Client_Users_ChangePasswordReq {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var options: EventStore_Client_Users_ChangePasswordReq.Options {
        get { _options ?? EventStore_Client_Users_ChangePasswordReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    public var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    public mutating func clearOptions() { _options = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Options {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var loginName: String = .init()

        public var currentPassword: String = .init()

        public var newPassword: String = .init()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public init() {}

    fileprivate var _options: EventStore_Client_Users_ChangePasswordReq.Options?
}

public struct EventStore_Client_Users_ChangePasswordResp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct EventStore_Client_Users_ResetPasswordReq {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var options: EventStore_Client_Users_ResetPasswordReq.Options {
        get { _options ?? EventStore_Client_Users_ResetPasswordReq.Options() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    public var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    public mutating func clearOptions() { _options = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Options {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var loginName: String = .init()

        public var newPassword: String = .init()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public init() {}

    fileprivate var _options: EventStore_Client_Users_ResetPasswordReq.Options?
}

public struct EventStore_Client_Users_ResetPasswordResp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
    extension EventStore_Client_Users_CreateReq: @unchecked Sendable {}
    extension EventStore_Client_Users_CreateReq.Options: @unchecked Sendable {}
    extension EventStore_Client_Users_CreateResp: @unchecked Sendable {}
    extension EventStore_Client_Users_UpdateReq: @unchecked Sendable {}
    extension EventStore_Client_Users_UpdateReq.Options: @unchecked Sendable {}
    extension EventStore_Client_Users_UpdateResp: @unchecked Sendable {}
    extension EventStore_Client_Users_DeleteReq: @unchecked Sendable {}
    extension EventStore_Client_Users_DeleteReq.Options: @unchecked Sendable {}
    extension EventStore_Client_Users_DeleteResp: @unchecked Sendable {}
    extension EventStore_Client_Users_EnableReq: @unchecked Sendable {}
    extension EventStore_Client_Users_EnableReq.Options: @unchecked Sendable {}
    extension EventStore_Client_Users_EnableResp: @unchecked Sendable {}
    extension EventStore_Client_Users_DisableReq: @unchecked Sendable {}
    extension EventStore_Client_Users_DisableReq.Options: @unchecked Sendable {}
    extension EventStore_Client_Users_DisableResp: @unchecked Sendable {}
    extension EventStore_Client_Users_DetailsReq: @unchecked Sendable {}
    extension EventStore_Client_Users_DetailsReq.Options: @unchecked Sendable {}
    extension EventStore_Client_Users_DetailsResp: @unchecked Sendable {}
    extension EventStore_Client_Users_DetailsResp.UserDetails: @unchecked Sendable {}
    extension EventStore_Client_Users_DetailsResp.UserDetails.DateTime: @unchecked Sendable {}
    extension EventStore_Client_Users_ChangePasswordReq: @unchecked Sendable {}
    extension EventStore_Client_Users_ChangePasswordReq.Options: @unchecked Sendable {}
    extension EventStore_Client_Users_ChangePasswordResp: @unchecked Sendable {}
    extension EventStore_Client_Users_ResetPasswordReq: @unchecked Sendable {}
    extension EventStore_Client_Users_ResetPasswordReq.Options: @unchecked Sendable {}
    extension EventStore_Client_Users_ResetPasswordResp: @unchecked Sendable {}
#endif // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "event_store.client.users"

extension EventStore_Client_Users_CreateReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateReq"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_CreateReq, rhs: EventStore_Client_Users_CreateReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_CreateReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Users_CreateReq.protoMessageName + ".Options"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "login_name"),
        2: .same(proto: "password"),
        3: .standard(proto: "full_name"),
        4: .same(proto: "groups"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &loginName)
            case 2: try decoder.decodeSingularStringField(value: &password)
            case 3: try decoder.decodeSingularStringField(value: &fullName)
            case 4: try decoder.decodeRepeatedStringField(value: &groups)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !loginName.isEmpty {
            try visitor.visitSingularStringField(value: loginName, fieldNumber: 1)
        }
        if !password.isEmpty {
            try visitor.visitSingularStringField(value: password, fieldNumber: 2)
        }
        if !fullName.isEmpty {
            try visitor.visitSingularStringField(value: fullName, fieldNumber: 3)
        }
        if !groups.isEmpty {
            try visitor.visitRepeatedStringField(value: groups, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_CreateReq.Options, rhs: EventStore_Client_Users_CreateReq.Options) -> Bool {
        if lhs.loginName != rhs.loginName { return false }
        if lhs.password != rhs.password { return false }
        if lhs.fullName != rhs.fullName { return false }
        if lhs.groups != rhs.groups { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_CreateResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateResp"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_CreateResp, rhs: EventStore_Client_Users_CreateResp) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_UpdateReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".UpdateReq"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_UpdateReq, rhs: EventStore_Client_Users_UpdateReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_UpdateReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Users_UpdateReq.protoMessageName + ".Options"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "login_name"),
        2: .same(proto: "password"),
        3: .standard(proto: "full_name"),
        4: .same(proto: "groups"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &loginName)
            case 2: try decoder.decodeSingularStringField(value: &password)
            case 3: try decoder.decodeSingularStringField(value: &fullName)
            case 4: try decoder.decodeRepeatedStringField(value: &groups)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !loginName.isEmpty {
            try visitor.visitSingularStringField(value: loginName, fieldNumber: 1)
        }
        if !password.isEmpty {
            try visitor.visitSingularStringField(value: password, fieldNumber: 2)
        }
        if !fullName.isEmpty {
            try visitor.visitSingularStringField(value: fullName, fieldNumber: 3)
        }
        if !groups.isEmpty {
            try visitor.visitRepeatedStringField(value: groups, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_UpdateReq.Options, rhs: EventStore_Client_Users_UpdateReq.Options) -> Bool {
        if lhs.loginName != rhs.loginName { return false }
        if lhs.password != rhs.password { return false }
        if lhs.fullName != rhs.fullName { return false }
        if lhs.groups != rhs.groups { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_UpdateResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".UpdateResp"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_UpdateResp, rhs: EventStore_Client_Users_UpdateResp) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_DeleteReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DeleteReq"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_DeleteReq, rhs: EventStore_Client_Users_DeleteReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_DeleteReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Users_DeleteReq.protoMessageName + ".Options"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "login_name"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &loginName)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !loginName.isEmpty {
            try visitor.visitSingularStringField(value: loginName, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_DeleteReq.Options, rhs: EventStore_Client_Users_DeleteReq.Options) -> Bool {
        if lhs.loginName != rhs.loginName { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_DeleteResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DeleteResp"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_DeleteResp, rhs: EventStore_Client_Users_DeleteResp) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_EnableReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".EnableReq"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_EnableReq, rhs: EventStore_Client_Users_EnableReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_EnableReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Users_EnableReq.protoMessageName + ".Options"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "login_name"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &loginName)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !loginName.isEmpty {
            try visitor.visitSingularStringField(value: loginName, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_EnableReq.Options, rhs: EventStore_Client_Users_EnableReq.Options) -> Bool {
        if lhs.loginName != rhs.loginName { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_EnableResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".EnableResp"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_EnableResp, rhs: EventStore_Client_Users_EnableResp) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_DisableReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DisableReq"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_DisableReq, rhs: EventStore_Client_Users_DisableReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_DisableReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Users_DisableReq.protoMessageName + ".Options"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "login_name"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &loginName)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !loginName.isEmpty {
            try visitor.visitSingularStringField(value: loginName, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_DisableReq.Options, rhs: EventStore_Client_Users_DisableReq.Options) -> Bool {
        if lhs.loginName != rhs.loginName { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_DisableResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DisableResp"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_DisableResp, rhs: EventStore_Client_Users_DisableResp) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_DetailsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DetailsReq"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_DetailsReq, rhs: EventStore_Client_Users_DetailsReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_DetailsReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Users_DetailsReq.protoMessageName + ".Options"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "login_name"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &loginName)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !loginName.isEmpty {
            try visitor.visitSingularStringField(value: loginName, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_DetailsReq.Options, rhs: EventStore_Client_Users_DetailsReq.Options) -> Bool {
        if lhs.loginName != rhs.loginName { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_DetailsResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DetailsResp"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "user_details"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_userDetails)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _userDetails {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_DetailsResp, rhs: EventStore_Client_Users_DetailsResp) -> Bool {
        if lhs._userDetails != rhs._userDetails { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_DetailsResp.UserDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Users_DetailsResp.protoMessageName + ".UserDetails"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "login_name"),
        2: .standard(proto: "full_name"),
        3: .same(proto: "groups"),
        4: .standard(proto: "last_updated"),
        5: .same(proto: "disabled"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &loginName)
            case 2: try decoder.decodeSingularStringField(value: &fullName)
            case 3: try decoder.decodeRepeatedStringField(value: &groups)
            case 4: try decoder.decodeSingularMessageField(value: &_lastUpdated)
            case 5: try decoder.decodeSingularBoolField(value: &disabled)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !loginName.isEmpty {
            try visitor.visitSingularStringField(value: loginName, fieldNumber: 1)
        }
        if !fullName.isEmpty {
            try visitor.visitSingularStringField(value: fullName, fieldNumber: 2)
        }
        if !groups.isEmpty {
            try visitor.visitRepeatedStringField(value: groups, fieldNumber: 3)
        }
        try { if let v = self._lastUpdated {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        if disabled != false {
            try visitor.visitSingularBoolField(value: disabled, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_DetailsResp.UserDetails, rhs: EventStore_Client_Users_DetailsResp.UserDetails) -> Bool {
        if lhs.loginName != rhs.loginName { return false }
        if lhs.fullName != rhs.fullName { return false }
        if lhs.groups != rhs.groups { return false }
        if lhs._lastUpdated != rhs._lastUpdated { return false }
        if lhs.disabled != rhs.disabled { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_DetailsResp.UserDetails.DateTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Users_DetailsResp.UserDetails.protoMessageName + ".DateTime"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "ticks_since_epoch"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &ticksSinceEpoch)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if ticksSinceEpoch != 0 {
            try visitor.visitSingularInt64Field(value: ticksSinceEpoch, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_DetailsResp.UserDetails.DateTime, rhs: EventStore_Client_Users_DetailsResp.UserDetails.DateTime) -> Bool {
        if lhs.ticksSinceEpoch != rhs.ticksSinceEpoch { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_ChangePasswordReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ChangePasswordReq"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_ChangePasswordReq, rhs: EventStore_Client_Users_ChangePasswordReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_ChangePasswordReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Users_ChangePasswordReq.protoMessageName + ".Options"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "login_name"),
        2: .standard(proto: "current_password"),
        3: .standard(proto: "new_password"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &loginName)
            case 2: try decoder.decodeSingularStringField(value: &currentPassword)
            case 3: try decoder.decodeSingularStringField(value: &newPassword)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !loginName.isEmpty {
            try visitor.visitSingularStringField(value: loginName, fieldNumber: 1)
        }
        if !currentPassword.isEmpty {
            try visitor.visitSingularStringField(value: currentPassword, fieldNumber: 2)
        }
        if !newPassword.isEmpty {
            try visitor.visitSingularStringField(value: newPassword, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_ChangePasswordReq.Options, rhs: EventStore_Client_Users_ChangePasswordReq.Options) -> Bool {
        if lhs.loginName != rhs.loginName { return false }
        if lhs.currentPassword != rhs.currentPassword { return false }
        if lhs.newPassword != rhs.newPassword { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_ChangePasswordResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ChangePasswordResp"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_ChangePasswordResp, rhs: EventStore_Client_Users_ChangePasswordResp) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_ResetPasswordReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ResetPasswordReq"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "options"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_ResetPasswordReq, rhs: EventStore_Client_Users_ResetPasswordReq) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_ResetPasswordReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = EventStore_Client_Users_ResetPasswordReq.protoMessageName + ".Options"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "login_name"),
        2: .standard(proto: "new_password"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &loginName)
            case 2: try decoder.decodeSingularStringField(value: &newPassword)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !loginName.isEmpty {
            try visitor.visitSingularStringField(value: loginName, fieldNumber: 1)
        }
        if !newPassword.isEmpty {
            try visitor.visitSingularStringField(value: newPassword, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_ResetPasswordReq.Options, rhs: EventStore_Client_Users_ResetPasswordReq.Options) -> Bool {
        if lhs.loginName != rhs.loginName { return false }
        if lhs.newPassword != rhs.newPassword { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension EventStore_Client_Users_ResetPasswordResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ResetPasswordResp"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: EventStore_Client_Users_ResetPasswordResp, rhs: EventStore_Client_Users_ResetPasswordResp) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
